<?php

require_once('grn/rss.csp');

define('GRN_RSS_PARSER_RSS2_0', 'rss2.0');
define('GRN_RSS_TAG_RSS2_0', 'RSS');

class plugin_grn_common_rss_50rss2_0 extends GRN_RSS_ParserBase
{
    /**
     * top level tag
     *
     * @access   protected
     */
    var $__Tag
        = [
            '' => ['children' => ['' => ['RSS']]]
        ];

    var $_RSS_Tag
        = [
            '' => ['children' => ['' => ['CHANNEL']]]
        ];

    var $_CHANNEL_Tag
        = [
            '' => [
                'children' => [
                    ''   => [
                        'TITLE',
                        'LINK',
                        'DESCRIPTION',
                        'PUBDATE',
                        'LASTBUILDDATE',
                        'ITEM'
                    ],
                    'DC' => ['DATE']
                ]
            ]
        ];

    var $_ITEM_Tag
        = [
            '' => [
                'children' => [
                    ''   => [
                        'TITLE',
                        'LINK',
                        'DESCRIPTION',
                        'AUTHOR',
                        'CATEGORY',
                        'GUID',
                        'PUBDATE'
                    ],
                    'DC' => ['SUBJECT', 'DATE', 'CREATOR']
                ]
            ]
        ];

    var $_openResource = false;

    function __construct()
    {
        parent::__construct(GRN_RSS_PARSER_RSS2_0);
    }

    /**
     * Check rss format
     *
     * @param object $cache
     * @param array  $error
     * @param string $tag
     *
     * @return bool
     */
    function checkFormat(& $cache, & $error, $tag = null)
    {
        $tag = GRN_RSS_TAG_RSS2_0;

        return parent::checkFormat($cache, $error, $tag);
    }

    /**
     * get channel information
     * you must override this function in the inherited class.
     *
     * @param    resource $file_path file handler
     * @param    array    $error     error information
     *
     * @return   mixed      channel info array
     *                      return FALSE if the channel info doesn't exist in the RSS data
     *
     * return['title']       => string   channel title
     *       ['channel_url'] => string   channel URL
     *       ['description'] => string   channel description
     *       ['ptime']       => string   channel published time
     */
    function getChannelInfo($file_path, & $error)
    {
        $this->_elementInfo = [];

        $this->setStartConditionFunc('channelStartCondition');
        $this->setEndConditionFunc('channelEndCondition');
        $this->setParseFunc('parseChannel');

        $this->open($file_path);

        if ($this->_openResource) {
            $ret = parent::_parse();
            $error = libxml_get_errors();
            if ( ! $ret) {
                $this->close();

                return false;
            }
        }

        if ( ! array_key_exists('ptime', $this->_elementInfo)) {
            $ptime = new CB_TimeStamp();
            $ptime->unix_ts = time();
            $this->_elementInfo['ptime'] = $ptime;
        }

        return $this->_elementInfo;
    }

    function channelStartCondition()
    {
        return $this->_condition(XMLReader::ELEMENT, 'RSS', 'CHANNEL');
    }

    function channelEndCondition()
    {
        return $this->_condition(XMLReader::END_ELEMENT, 'RSS', 'CHANNEL');
    }

    function parseChannel()
    {
        $ret = $this->_parse('CHANNEL', [
            'TITLE'         => 'title',
            'LINK'          => 'channel_url',
            'DESCRIPTION'   => 'description',
            'PUBDATE'       => 'ptime',
            'LASTBUILDDATE' => 'ptime',
            'DC:DATE'       => 'ptime'
        ]);

        if ( ! $ret) {
            return false;
        }

        return true;

    }

    function getNextItemInfo($file_path, & $error)
    {
        $this->_elementInfo = [];

        $this->setStartConditionFunc('itemStartCondition');
        $this->setEndConditionFunc('itemEndCondition');
        $this->setParseFunc('parseItem');

        $this->open($file_path);

        if ($this->_openResource) {
            $ret = parent::_parse();
            $error = libxml_get_errors();
            if ( ! $ret) {
                $this->close();

                return false;
            }
        }

        if ( ! array_key_exists('id', $this->_elementInfo)) {
            if (array_key_exists('url', $this->_elementInfo)) {
                $this->_elementInfo['id'] = $this->_elementInfo['url'];
            } else {
                return false;
            }
        }

        return $this->_elementInfo;
    }

    function itemStartCondition()
    {
        return $this->_condition(XMLReader::ELEMENT, 'CHANNEL', 'ITEM');
    }

    function itemEndCondition()
    {
        return $this->_condition(XMLReader::END_ELEMENT, 'CHANNEL', 'ITEM');
    }

    function parseItem()
    {
        $ret = $this->_parse('ITEM', [
            'GUID'        => 'id',
            'TITLE'       => 'title',
            'LINK'        => 'url',
            'DESCRIPTION' => 'description',
            'CATEGORY'    => 'category',
            'DC:SUBJECT'  => 'category',
            'PUBDATE'     => 'ptime',
            'DC:DATE'     => 'ptime',
            'AUTHOR'      => 'author',
            'DC:CREATOR'  => 'author'
        ]);

        if ( ! $ret) {
            return false;
        }

        return true;
    }

    function _condition($type, $parent_tag, $tag)
    {
        end($this->_node_stack);
        $parent = prev($this->_node_stack);

        if (strcmp($parent['tag'], $parent_tag) == 0
            && $this->_reader->nodeType == $type
            && strcmp(strtoupper($this->_reader->name), $tag) == 0
        ) {
            return true;
        }

        return false;
    }


    /**
     * parse rss/rdf data
     *
     * @param string $tag
     * @param string $map
     *
     * @return bool
     */
    function _parse($tag = null, $map = null)
    {
        end($this->_node_stack);
        $parent = prev($this->_node_stack);

        if (strcmp($parent['tag'], $tag) == 0) {
            $node = strtoupper($this->_reader->name);

            if (array_key_exists($node, $map)) {
                @$this->_reader->read();

                // 値が空の場合があるので
                if ($this->_reader->nodeType === XMLReader::END_ELEMENT) {
                    if ($this->_parsing) {
                        if (call_user_func([$this, $this->_endConditionFunc])) {
                            array_pop($this->_node_stack);

                            return false;
                        }
                    }

                    array_pop($this->_node_stack);

                } else {
                    $val = $this->_reader->value;
                    if (strcmp($map[$node], 'ptime') == 0) {
                        if (strcmp($node, 'DC:DATE') == 0) // W3CDTF
                        {
                            if ( ! ($val =& grn_rss_w3cdtf2unix_ts($val))) {
                                $val = null;
                            }
                        } else                                  // RFC822
                        {
                            $ts = strtotime($val);

                            if ($ts !== -1) {
                                $val = new CB_TimeStamp();
                                $val->unix_ts = $ts;
                            } else {
                                $val = null;
                            }
                        }

                        if ( ! is_null($val)) {
                            if (array_key_exists('ptime',
                                $this->_elementInfo)
                            ) {
                                $ts = $this->_elementInfo['ptime'];
                                // use new data
                                if ($ts->unix_ts > $val->unix_ts) {
                                    $val =& $ts;
                                }
                            }

                            $this->_elementInfo['ptime'] = $val;
                        }
                    } else {
                        $this->_elementInfo[$map[$node]] = $val;
                    }
                }
            }
        }

        return true;
    }

}


