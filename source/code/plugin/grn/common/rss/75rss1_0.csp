<?php

/**
 * RSS 1.0 Parser
 *
 * @author  Eiji TAEN    2005.3
 * @version 1.0
 * @package grn.common.rss
 */

require_once('grn/rss.csp');

define('GRN_RSS_PARSER_RSS1_0', 'rss1.0');
define('GRN_RSS_TAG_RSS1_0', 'RDF:RDF');

/**
 * RSS 1.0 Parser class
 *
 * @author  Eiji TAEN    2005.3
 * @version 1.0
 * @package grn.common.rss
 */
class plugin_grn_common_rss_75rss1_0 extends GRN_RSS_ParserBase
{
    /**
     * top level tag
     *
     * @access   protected
     */
    var $__Tag
        = [
            '' => ['children' => ['RDF' => ['RDF']]]
        ];

    /**
     * rdf tag
     *
     * @access   protected
     */
    var $_RDF_Tag
        = [
            'RDF' => ['children' => ['' => ['CHANNEL', 'ITEM']]]
        ];

    /**
     * channel tag
     *
     * @access   protected
     */
    var $_CHANNEL_Tag
        = [
            '' => [
                'children' => [
                    ''   => ['TITLE', 'LINK', 'DESCRIPTION'],
                    'DC' => ['DATE']
                ]
            ]
        ];

    /**
     * item tag
     *
     * @access   protected
     */
    var $_ITEM_Tag
        = [
            '' => [
                'children' => [
                    ''   => ['TITLE', 'LINK', 'DESCRIPTION'],
                    'DC' => ['SUBJECT', 'DATE', 'CREATOR']
                ]
            ]
        ];

    function __construct()
    {
        parent::__construct(GRN_RSS_PARSER_RSS1_0);
    }

    /**
     * Check rss data format
     *
     * @param object $cache GRN_RSS_Cache
     * @param array  $error error information
     * @param string $tag   identification tag (e.g. 'rss')
     *
     * @return bool
     */
    function checkFormat(& $cache, & $error, $tag = null)
    {
        $tag = GRN_RSS_TAG_RSS1_0;

        return parent::checkFormat($cache, $error, $tag);
    }

    /**
     * get channel information
     * you must override this function in the inherited class.
     *
     * @param    resource $file_path file handler
     * @param    array    $error     error information
     *
     * @return   mixed      channel info array
     *                      return FALSE if the channel info doesn't exist in the RSS data
     *
     * return['title']       => string   channel title
     *       ['channel_url'] => string   channel URL
     *       ['description'] => string   channel description
     *       ['ptime']       => string   channel published time
     */
    function getChannelInfo($file_path, & $error)
    {
        $this->_elementInfo = [];

        $this->setStartConditionFunc('channelStartCondition');
        $this->setEndConditionFunc('channelEndCondition');
        $this->setParseFunc('parseChannel');

        $this->open($file_path);

        if ($this->_openResource) {
            $ret = parent::_parse();
            $error = libxml_get_errors();
            if ( ! $ret) {
                $this->close();

                return false;
            }
        }

        if ( ! array_key_exists('ptime', $this->_elementInfo)) {
            $ptime = new CB_TimeStamp();
            $ptime->unix_ts = time();
            $this->_elementInfo['ptime'] = $ptime;
        }

        /*
        // html decode
        $this->_elementInfo['channel_url'] = html_entity_decode( $this->_elementInfo['channel_url'] );
         */

        return $this->_elementInfo;
    }

    function channelStartCondition()
    {
        return $this->_condition(XMLReader::ELEMENT, 'CHANNEL');
    }

    function channelEndCondition()
    {
        return $this->_condition(XMLReader::END_ELEMENT, 'CHANNEL');
    }

    function parseChannel()
    {
        $ret = $this->_parse('CHANNEL', [
            'TITLE'       => 'title',
            'LINK'        => 'channel_url',
            'DESCRIPTION' => 'description',
            'DC:DATE'     => 'ptime'
        ]);

        if ( ! $ret) {
            return false;
        }

        return true;

    }

    function getNextItemInfo($file_path, & $error)
    {
        $this->_elementInfo = [];

        $this->setStartConditionFunc('itemStartCondition');
        $this->setEndConditionFunc('itemEndCondition');
        $this->setParseFunc('parseItem');

        $this->open($file_path);

        if ($this->_openResource) {
            $ret = parent::_parse();
            $error = libxml_get_errors();
            if ( ! $ret) {
                $this->close();

                return false;
            }
        }

        if ( ! array_key_exists('id', $this->_elementInfo)) {
            if (array_key_exists('url', $this->_elementInfo)) {
                $this->_elementInfo['id'] = $this->_elementInfo['url'];
            } else {
                return false;
            }
        }

        /*
        // html decode
        // なんかCB_XMLReaderのなかでdecodeされて返ってきてるっぽい
        $this->_elementInfo['url'] = html_entity_decode( $this->_elementInfo['url'] );
         */

        return $this->_elementInfo;
    }

    function itemStartCondition()
    {
        $ret = $this->_condition(XMLReader::ELEMENT, 'ITEM');

        return $ret;
    }

    function itemEndCondition()
    {
        return $this->_condition(XMLReader::END_ELEMENT, 'ITEM');
    }

    function parseItem()
    {
        if (strcmp(strtoupper($this->_reader->name), 'ITEM') == 0) {
            if ($id = $this->_reader->getAttribute('rdf:about')) {
                $this->_elementInfo['id'] = $id;
            }
        } else {
            $ret = $this->_parse('ITEM', [
                'TITLE'       => 'title',
                'LINK'        => 'url',
                'DESCRIPTION' => 'description',
                'DC:SUBJECT'  => 'category',
                'DC:DATE'     => 'ptime',
                'DC:CREATOR'  => 'author'
            ]);

            if ( ! $ret) {
                return false;
            }
        }

        return true;
    }

    function _condition($type, $tag)
    {
        end($this->_node_stack);
        $parent = prev($this->_node_stack);

        if (strcmp($parent['tag'], 'RDF:RDF') == 0
            && $this->_reader->nodeType == $type
            && strcmp(strtoupper($this->_reader->name), $tag) == 0
        ) {
            return true;
        }

        return false;
    }

    /**
     * parse rss/rdf data
     *
     * @param string $tag
     * @param string $map
     *
     * @return bool
     */
    function _parse($tag = null, $map = null)
    {
        end($this->_node_stack);
        $parent = prev($this->_node_stack);

        if (strcmp($parent['tag'], $tag) == 0) {
            $node = strtoupper($this->_reader->name);

            if (array_key_exists($node, $map)) {
                @$this->_reader->read();

                // 値が空の場合があるので
                if ($this->_reader->nodeType === XMLReader::END_ELEMENT) {
                    if ($this->_parsing) {
                        if (call_user_func([$this, $this->_endConditionFunc])) {
                            array_pop($this->_node_stack);

                            return false;
                        }
                    }

                    array_pop($this->_node_stack);

                } else {
                    $val = $this->_reader->value;
                    if (strcmp($node, 'DC:DATE') === 0) {
                        if ( ! ($val =& grn_rss_w3cdtf2unix_ts($val))) {
                            $val = new CB_TimeStamp();
                            $val->unix_ts = time();
                        }
                    }
                    $this->_elementInfo[$map[$node]] = $val;
                }
            }
        }

        return true;
    }

}


