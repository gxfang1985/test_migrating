<?php

if (strcasecmp(@ $_SERVER['REQUEST_METHOD'], 'POST') == 0) {
    /*
        // instantiate an Smarty object
        require_once( "grn/smarty.csp" );
        $t = new GRN_Smarty;

        // Validation check
        require_once('SmartyValidate.class.php');
        SmartyValidate::connect($t);

        // validate after a POST
        if(SmartyValidate::is_valid($G_INPUT)) {
            // the validation session is finished
            SmartyValidate::disconnect();
    */
    // --------
    // brabrabra after success
    // --------
    // イベントの取得
    require_once('schedule/application.csp');
    $app = GRN_Schedule_Application::getInstance();

    $user_id = @ $G_INPUT['uid'];
    $group_id = @ $G_INPUT['gid'];
    $str_date = @ $G_INPUT['bdate'];
    $event_id = @ $G_INPUT['event'];
    $follow_id = @ $G_INPUT['follow_id'];
    $referer_key = @ $G_INPUT['referer_key'];

    global $G_container_base;
    $uum = $G_container_base->getInstance('uum');

    $login = $uum->getLoginUser();

    $date = new CB_Date();
    if ( ! $date->parse($str_date)) {
        $date = null;
    }

    // イベントの取得
    // イベントがあるかどうか見れるかどうかの確認
    $event = $app->getEvent($login, $event_id, $date);
    if ( ! $event) {
        cb_throw_error(E_GRN_SCHD_NOTFOUND_EVENT);
    }

    // アクセス権のチェック
    require_once('schedule/access_logic.csp');
    $acc_logic = GRN_Schedule_Access_Logic::getInstance();
    $dynamic_role = $uum->listGrantedRoles();
    $access = $acc_logic->getEventAccess($login, $event,
        ['read', 'add', 'modify', 'delete'], $dynamic_role);

    if ($access['read'] == GRN_SCHD_ACCESS_DENY) {
        cb_throw_error(E_GRN_SCHD_ACCESSDENY_EVENT);
    }

    $app->deleteFollow($login, $event->id, $follow_id);

    $tsex = new CB_TimeStampEx();
    $notify_date = $tsex->getDate();
    $date = $event->getFirstDate($notify_date);

    if ($notify_date->compare($date) <= 0) {
        if (is_array($event->users) && count($event->users) > 0) {
            $title = _schedule_command_delete_follow_getNotifyTitle($event);
            $app->setNotify($event->users, $login, $event, $date, $title, '',
                GRN_SCHEDULE_NOTIFY_FOLLOWDELETE, $tsex);
        }

        // 通知先の指定がある場合
        if ($event->private && is_array($event->notify_address)
            && count($event->notify_address) > 0
        ) {
            $title = _schedule_command_delete_follow_getNotifyTitle($event);
            $app->sendNotificationsToPublic($login, $event, $date, '', $tsex,
                $title, false, false, GRN_SCHEDULE_NOTIFY_FOLLOWDELETE);
        }
    }
    cb_redirect('schedule/view', [
        'event'       => $event_id,
        'bdate'       => $str_date,
        'gid'         => $group_id,
        'uid'         => $user_id,
        'referer_key' => $referer_key
    ]);
}

function _schedule_command_delete_follow_getNotifyTitle($event)
{
    require_once('schedule/notification.csp');
    $util = GRN_Schedule_Notify_Logic::getInstance();

    return $util->getNotifyTitle(html_entity_decode($event->getTitle()));
}

