<?php

use grn\grn\JSONResponse;

if (0 == strcasecmp(@ $_SERVER['REQUEST_METHOD'], 'POST')) {
    global $G_INPUT;
    $json = JSONResponse::create();

    $page_name = 'workflow/cancel';

    $folder_id = null;
    if (array_key_exists('fid', $G_INPUT)) {
        $folder_id = $G_INPUT['fid'];
    }
    $petition_id = null;
    if (array_key_exists('pid', $G_INPUT)) {
        $petition_id = $G_INPUT['pid'];
    }
    $comment = null;
    if (array_key_exists('comment', $G_INPUT)) {
        $comment = $G_INPUT['comment'];
    }
    $session_flag = false;
    if (array_key_exists('cpsf', $G_INPUT)) {
        $session_flag = $G_INPUT['cpsf'];
    }
    $cancel = false;
    if (array_key_exists('cancel', $G_INPUT)) {
        $cancel = $G_INPUT['cancel'];
    }
    $handle = false;
    if (array_key_exists('handle', $G_INPUT)) {
        $handle = $G_INPUT['handle'];
    }

    //Get Session Key
    require_once('workflow/controller_util.csp');
    require_once('grn/controller.csp');
    $tmp_key = grn_get_temporary_key();

    global $G_container_base;
    $uum =& $G_container_base->getInstance('uum');
    $login =& $uum->getLoginUser();
    $user_id = $login->getOID();

    if ($session_flag) {
        require_once('fw/session_manager.csp');
        $session_manager = CB_SessionManager::getInstance();
        $session =& $session_manager->getSession('workflow/handle'
                                                 . $tmp_key);

        $params = $session->get('batch');
        if ( ! is_array($params) || 0 == count($params)) {
            // 連続処理のパラメータが空
            require_once('workflow/error_code.csp');
            cb_throw_error(E_GRN_WRKF_EMPTY_BATCH_PARAMS);
        }
        $folder_id = $params['fid'];
        $simple = $params['simple'];
        $folder_relations = $params['folder_relations'];
        if ( ! is_array($folder_relations) || 0 == count($folder_relations)) {
            $session->unset_by('batch');
            cb_redirect('workflow/index', ['fid' => $folder_id]);
        }

        require_once('workflow/folderrelation_logic.csp');
        $logic = GRN_Workflow_FolderRelation_Logic::getInstance();
        $tmp = $logic->getSpecificListByOID(array_keys($folder_relations),
            $folder_id);
        if ( ! is_array($tmp) || 0 == count($tmp)) {
            $session->unset_by('batch');
            cb_redirect('workflow/index', ['fid' => $folder_id]);
        }

        foreach (array_keys($folder_relations) as $folder_relation_id) {
            if ( ! array_key_exists($folder_relation_id, $tmp)) {
                unset($folder_relations[$folder_relation_id]);
            }
        }

        $folder_relation = current($folder_relations);
        if ( ! $cancel) {
            unset($folder_relations[$folder_relation['r__id']]);
            $params['folder_relations'] = $folder_relations;
            $session->set('batch', $params);
        }

        if ($petition_id != $folder_relation['p__id']) {
            cb_redirect('workflow/handle',
                ['sf' => true, 'tmp_key' => $tmp_key]);
        }

        require_once('workflow/petition_logic.csp');
        $logic = GRN_Workflow_Petition_Logic::getInstance();
        $petition = $logic->get($petition_id);

        if ($user_id != $petition['col_user']
            && $user_id != $petition['col_agent_user']
        ) {
            // ログインユーザーは申請者でない
            cb_throw_error(E_GRN_WRKF_DENY_CANCEL_NOT_APPLICANT);
        }
    } else {
        /**
         * 制限事項
         * ・ログインユーザーは申請者でない
         * ・ログインユーザーはフォルダの所有者でない
         * ・フォルダは送信一覧、未処理一覧（申請の進行状況は差し戻し）でない
         * ・フォルダにフォルダリレーションがない
         */

        require_once('workflow/petition_logic.csp');
        $logic = GRN_Workflow_Petition_Logic::getInstance();
        $petition = $logic->get($petition_id);
        if ($user_id != $petition['col_creator']
            && $user_id != $petition['col_user']
        ) {
            if ($petition['col_agent_user']
                && $user_id != $petition['col_agent_user']
            ) {
                // ログインユーザーは申請者でない
                cb_throw_error(E_GRN_WRKF_DENY_CANCEL_NOT_APPLICANT);
            }
        }

        if (GRN_WORKFLOW_STATUS_UNPROCESSING != $petition['col_status']
            && GRN_WORKFLOW_STATUS_IN_PROCESS != $petition['col_status']
            && GRN_WORKFLOW_STATUS_REMAND != $petition['col_status']
        ) {
            cb_throw_error(E_GRN_WRKF_PETITION_STATUS_DENY_CANCEL);
        }

        require_once('workflow/folder_logic.csp');
        $logic = GRN_Workflow_Folder_Logic::getInstance();
        $folder = $logic->get($user_id, $folder_id);
        if ( ! is_array($folder) || 0 == count($folder)) {
            // ログインユーザーはフォルダの所有者でない
            cb_throw_error(E_GRN_WRKF_FOLDER_INVALID_FOLDER_ID);
        }
        if (GRN_WORKFLOW_FOLDER_TYPE_UNPROCESSED_ID
            == $folder['col_folder_type']
        ) {
            if (GRN_WORKFLOW_STATUS_REMAND != $petition['col_status']) {
                // フォルダは未処理一覧（申請の進行状況は差し戻しでない）
                cb_throw_error(E_GRN_WRKF_DENY_CANCEL_FOLDER);
            }
        } elseif (GRN_WORKFLOW_FOLDER_TYPE_OUT_ID
                  != $folder['col_folder_type']
        ) {
            // フォルダは送信一覧でない
            cb_throw_error(E_GRN_WRKF_DENY_CANCEL_FOLDER);
        }

        require_once('workflow/folderrelation_logic.csp');
        $logic = GRN_Workflow_FolderRelation_Logic::getInstance();
        $folder_relation = $logic->getSpecific($folder_id, $petition_id);
        if ( ! is_array($folder_relation) || 0 == count($folder_relation)) {
            // フォルダにフォルダリレーションがない
            cb_throw_error(E_GRN_WRKF_FOLDER_FOLDERRELATION_NOT_FOUND);
        }
    }

    if ( ! $cancel) {
        // 申請の状況を取り戻し（取り消し）に変更
        require_once('workflow/petition_logic.csp');
        $logic = GRN_Workflow_Petition_Logic::getInstance();
        if (GRN_WORKFLOW_STATUS_UNPROCESSING != $petition['col_status']
            && GRN_WORKFLOW_STATUS_IN_PROCESS != $petition['col_status']
        ) {
            $petition['col_status'] = GRN_WORKFLOW_STATUS_IN_PROCESS;
        }
        $status = GRN_WORKFLOW_STATUS_UNPROCESSING_CANCEL
                  + $petition['col_status'];
        $ptime = time();


        $agent_id = null;
        if ($user_id != $petition['col_user']) {
            $agent_id = $user_id;
            $user_id = $petition['col_user'];
        }

        $logic->modifyStatus($petition_id, $status, $user_id, $comment, $ptime,
            $agent_id);


//        //申請者のIDを使用する
//        $user_id = $petition['col_creator'];
        $user_id = $petition['col_user'];

        if (GRN_WORKFLOW_STATUS_UNPROCESSING == $petition['col_status']) {
            // 取り戻したは、下書きのみ
            require_once('workflow/controller_util.csp');
            $controller_util = new GRN_Workflow_ControllerUtil($page_name);
            $controller_util->removeAllPetitions($petition_id, $user_id);

            if ( ! is_null($petition['col_agent_user'])) {
                $controller_util->removeAllPetitions($petition_id,
                    $petition['col_agent_user']);
            }

            // 取り戻しの場合、申請者の下書きに申請を送信
            require_once('workflow/controller_util.csp');
            $controller_util = new GRN_Workflow_ControllerUtil($page_name);

            $uids = [];
            if ( ! is_null($petition['col_agent_user'])) {
                $uids = [$petition['col_agent_user']];
            } else {
                $uids = [$user_id];
            }
            $foreign_keys = ['TEMP_FOLDER_FOREIGN_KEY'];
            $controller_util->sendPetition($petition_id, $uids, $foreign_keys);
        } else {
            require('workflow/auto_schedule_register_logic.csp');
            $wf_register_logic
                = GRN_Workflow_Auto_Schedule_Register_Logic::getInstance();
            $wf_register_logic->delete($petition_id);
        }

        //監査する
        require_once('workflow/inspection.csp');
        $inspection = GRN_Workflow_Petition_Inspection::getInstance();
        if ($inspection->isEnabled()) {
            $message_type = 'petition_cancel';

            $message_args['pid'] = $petition_id;
            $message_args['uid'] = $user_id;
            $message_args['status'] = $status;
            $message_args['comment'] = $comment;
            $message_args['ptime'] = $ptime;

            //Record Inspection
            $inspection->record($message_type, $message_args);
        }

        if ($handle) {
            // 処理者の申請を削除
            require_once('workflow/controller_util.csp');
            $controller_util = new GRN_Workflow_ControllerUtil($page_name);
            $controller_util->removePetition($petition_id, $user_id,
                'UNPROCESSED_FOLDER_FOREIGN_KEY');
            if ( ! is_null($petition['col_agent_user'])) {
                $controller_util->removePetition($petition_id,
                    $petition['col_agent_user'],
                    'UNPROCESSED_FOLDER_FOREIGN_KEY');
            }
        }
    }

    // 連続処理
    if ($session_flag) {
        if (is_array($folder_relations) && 0 < count($folder_relations)) {
            $json->response([
                'link' => cb_get_full_url('workflow/handle',
                    ['cpsf' => true, 'tmp_key' => $tmp_key])
            ]);
            cb_safe_exit();
        }
        $session->unset_by('batch');
    }
    $json->response([
        'link' => cb_get_full_url('workflow/index', ['fid' => $folder_id])
    ]);
    cb_safe_exit();
}


