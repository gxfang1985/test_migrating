<?php

use grn\kintone\bean\GrnKintoneAppRelationSetting;
use grn\schedule\scheduleKintoneAppRelationLogic;
use grn\schedule\AttendanceStatusLogic;
use grn\schedule\ScheduleMemberLogic;
use grn\kintone\AppRelationSettingLogic;

require_once dirname(dirname(__DIR__)) . '/_api.csp';
require_once 'cbpapi/util.csp';

unset($cbpapi_service);
require_once dirname(dirname(dirname(__DIR__)))
             . '/cbpapi/schedule/schedule_get_events_by_target.csp';


$in = JSON::getInput();

$infoType = false;
$dateTimeOrder = false;
global $G_container_base;
/** @var GRN_Uum $uum */
$uum = $G_container_base->getInstance('uum');

$appId = null;
$limit = null;
$offset = 0;

if (defined('ON_FOREST')) {
    if (isset($in->appId)) {
        if ( ! is_numeric($in->appId)) {
            throw new APIException('Parameter:appId is invalid.', 202);
        } else {
            $appId = $in->appId;
        }
    }

    $recordId = [];
    if (isset($in->recordId)) {
        if (is_null($appId)) {
            cb_throw_error("GRN_SCHD_13318");
        }

        if ( ! is_array($in->recordId)) {
            throw new APIException('Parameter:recordId is invalid format.',
                203);
        } else {
            $recordId = $in->recordId;
        }
    }

    $startUTC = null;
    $endUTC = null;
    if ( ! is_null($appId)) {
        if (isset($in->start) && is_string($in->start)
            && (strlen($in->start) > 0)
        ) {
            $startUTC = CB_ISO8601Util::toUTCDateTime($in->start);
            if ($startUTC === false) {
                throw new APIException('Parameter:start is invalid format.',
                    203);
            }
        }

        if (isset($in->end) && is_string($in->end) && (strlen($in->end) > 0)) {
            $endUTC = CB_ISO8601Util::toUTCDateTime($in->end);
            if ($endUTC === false) {
                throw new APIException('Parameter:end is invalid format.', 203);
            }
        }

        if ( ! is_null($startUTC) && ! is_null($endUTC)) {
            $comp = $startUTC->compare($endUTC);
            if ($comp == 0) {
                throw new APIException('Start date is equal to end date.', 205);
            }
            if ($comp > 0) {
                throw new APIException('Start date is greater than end date.',
                    204);
            }
        }
    } else {
        if ( ! isset($in->start)) {
            throw new APIException('Parameter:start is not specified.', 201);
        }
        $startUTC = CB_ISO8601Util::toUTCDateTime($in->start);
        if ($startUTC === false) {
            throw new APIException('Parameter:start is invalid format.', 203);
        }

        if ( ! isset($in->end)) {
            throw new APIException('Parameter:end is not specified.', 201);
        }
        $endUTC = CB_ISO8601Util::toUTCDateTime($in->end);
        if ($endUTC === false) {
            throw new APIException('Parameter:end is invalid format.', 203);
        }

        $comp = $startUTC->compare($endUTC);
        if ($comp == 0) {
            throw new APIException('Start date is equal to end date.', 205);
        }
        if ($comp > 0) {
            throw new APIException('Start date is greater than end date.', 204);
        }
    }


    $login = $uum->getLoginUser();
    $login_id = $login->getOID();

    $user = null;
    if ( ! isset($in->userId)) {
        if ( ! is_null($appId)) {
        } else {
            $user = $uum->getLoginUser();
        }
    } elseif (is_numeric($in->userId)) {
        $user = $uum->getUser($in->userId);
        if ( ! $user) {
            throw new APIException('User is not found.', 301);
        }
    } else {
        throw new APIException('Parameter:userId is invalid.', 202);
    }

    if (isset($in->offset) && ! is_null($appId)) {
        if (is_numeric($in->offset) && $in->offset >= 0) {
            $offset = $in->offset;
        } else {
            throw new APIException('Parameter:offset is invalid.', 202);
        }
    }

    if (isset($in->limit) && ! is_null($appId)) {
        if (is_numeric($in->limit) && $in->limit >= 0) {
            $limit = $in->limit;
        } else {
            throw new APIException('Parameter:limit is invalid.', 202);
        }
    }

    if (isset($in->infoType)) {
        if (is_null($appId)) {
            cb_throw_error("GRN_SCHD_13318");
        }

        if ( ! is_numeric($in->infoType)) {
            throw new APIException('Parameter:infoType is invalid.', 202);
        }

        $infoType = $in->infoType == 1 ? true : false;
    }

    if (isset($in->dateTimeOrder)) {
        if (is_null($appId)) {
            cb_throw_error("GRN_SCHD_13318");
        }

        if ( ! is_numeric($in->dateTimeOrder)) {
            throw new APIException('Parameter:dateTimeOrder is invalid.', 202);
        }

        $dateTimeOrder = $in->dateTimeOrder == 1 ? true : false;
    }

    if ( ! is_null($appId)) {
        if (is_object($user)) {
            // アクセス権の評価を行う
            require_once('schedule/access_logic.csp');
            $acc_logic = GRN_Schedule_Access_logic::getInstance();
            $dynamic_roles = $uum->listGrantedRoles();
            $access = $acc_logic->evaluateAccess($login, $user, ['read'],
                $dynamic_roles);
            if ( ! $access) {
                cb_throw_error(E_GRN_SCHD_ACCESSDENY_VIEW);
            }
        }

        // re-format ISO8601
        $start = is_null($startUTC) ? null : formatISO8601($startUTC);
        $end = is_null($endUTC) ? null : formatISO8601($endUTC);

        $startdatetime = is_null($start) ? null
            : grn_cbpapi_parse_iso8601($start);
        $enddatetime = is_null($end) ? null : grn_cbpapi_parse_iso8601($end);

        require_once('schedule/view_util.csp');
        $util = GRN_Schedule_View_Util::getInstance();
        $setdate = null;
        if ( ! is_null($startdatetime)) {
            $startdatetime = grn_cbpapi_convert_utc_to_local($startdatetime);
            $tsex = new CB_TimeStampEx();
            $tsex->setDateTime($startdatetime);
            $timestamp = $tsex->unix_ts;
            $dateex = new CB_DateEx($startdatetime);
            $setdate = [
                'format'    => $dateex->format(),
                'type'      => $util->getDayType($dateex),
                'date'      => $dateex,
                'timestamp' => $timestamp
            ];
        }

        $enddate = null;
        if ( ! is_null($enddatetime)) {
            $enddatetime = grn_cbpapi_convert_utc_to_local($enddatetime);
            $tsex = new CB_TimeStampEx();
            $tsex->setDateTime($enddatetime);
            $timestamp = $tsex->unix_ts;
            $dateex = new CB_DateEx($enddatetime);
            $enddate = [
                'format'    => $dateex->format(),
                'type'      => $util->getDayType($dateex),
                'date'      => $dateex,
                'timestamp' => $timestamp
            ];
        }

        require_once('schedule/eventfactory.csp');
        $event_factory = GRN_Schedule_EventFactory::getInstance();

        require_once('schedule/system_logic.csp');
        $systemlogic = GRN_Schedule_SystemLogic::getInstance();
        $hiddenprivate = $systemlogic->getHiddenPrivate();

        $schedule_type = GRN_SCHEDULE_EVENT_TYPE_NORMAL
                         + GRN_SCHEDULE_EVENT_TYPE_DAILYEVENT;
        $user_id = is_null($user) ? null : $user->getOID();
        $attendanceStatusLogic = new AttendanceStatusLogic();
        $isEnableAttendanceStatus
            = $attendanceStatusLogic->isEnableAttendanceCheck();
        $events = $event_factory->getEventsWithRelateKintone(
            $schedule_type, $appId, $recordId, $setdate, $enddate, $user_id,
            'user', $hiddenprivate,
            $isEnableAttendanceStatus
        );
        if ($isEnableAttendanceStatus) {
            foreach (['normal', 'daily'] as $type) {
                $events[$type] = $util->filterAbsentEvents($events[$type]);
            }
        }

        require_once('cbpapi/schedule_logic.csp');
        $cbpapi_base_logic = GRN_CBPApi_Schedule_Logic::getInstance();

        $tmpEvents = [];
        $normal_events = $events['normal'];
        foreach ($normal_events as $event) {
            $deny = false;
            $tmp_event = $cbpapi_base_logic->getEventsForViewByIds($login,
                [$event['id']], false, $deny, true);

            if ($deny !== true) {
                if ($event['private']) {
                    $evnt = $event_factory->getEvent($event['id'],
                        null, CB_DATABASE_NO_LOCK, GRN_SCHEDULE_GET_MEMBER_ID);
                    $is_event_available = ScheduleMemberLogic::getInstance()
                                                             ->isEventAvailableForUser($login,
                                                                 $evnt,
                                                                 GRN_SCHEDULE_GET_MEMBER_ID);
                    if ( ! $is_event_available) {
                        continue;
                    }
                }
            } else {
                continue;
            }

            if (isset($event['repeat']) && $event['repeat'] == 1) {
                $tmp_event[$event['id']]['start_date_time']
                    = grn_cbpapi_iso8601($event['setdatetime']);
                $tmp_event[$event['id']]['end_date_time']
                    = grn_cbpapi_iso8601($event['enddatetime']);
            }
            $tmpEvents[] = $tmp_event;
        }

        $daily_events = $events['daily'];
        foreach ($daily_events as $event) {
            $deny = false;
            $tmp_event = $cbpapi_base_logic->getEventsForViewByIds($login,
                [$event['id']], false, $deny, true);
            if ($deny !== true) {
                if ($event['private']) {
                    $evnt = $event_factory->getEvent($event['id'],
                        null, CB_DATABASE_NO_LOCK, GRN_SCHEDULE_GET_MEMBER_ID);
                    $is_event_available = ScheduleMemberLogic::getInstance()
                                                             ->isEventAvailableForUser($login,
                                                                 $evnt,
                                                                 GRN_SCHEDULE_GET_MEMBER_ID);
                    if ( ! $is_event_available) {
                        continue;
                    }
                }
            } else {
                continue;
            }
            if (isset($event['repeat']) && $event['repeat'] == 1) {
                $tmp_event[$event['id']]['start_date_time']
                    = $event['setdate']->getDate()->format();
                $tmp_event[$event['id']]['end_date_time']
                    = $event['enddate']->getDate()->format();
            }
            $tmpEvents[] = $tmp_event;
        }
    } else {
        // re-format ISO8601
        $start = formatISO8601($startUTC);
        $end = formatISO8601($endUTC);

        $tmpEvents = getEventsByTarget($start, $end, 'user', $user->getOID());
    }
} else {
    if ( ! isset($in->start)) {
        throw new APIException('Parameter:start is not specified.', 201);
    }
    $startUTC = CB_ISO8601Util::toUTCDateTime($in->start);
    if ($startUTC === false) {
        throw new APIException('Parameter:start is invalid format.', 203);
    }
    if ( ! isset($in->end)) {
        throw new APIException('Parameter:end is not specified.', 201);
    }
    $endUTC = CB_ISO8601Util::toUTCDateTime($in->end);
    if ($endUTC === false) {
        throw new APIException('Parameter:end is invalid format.', 203);
    }
    $comp = $startUTC->compare($endUTC);
    if ($comp == 0) {
        throw new APIException('Start date is equal to end date.', 205);
    }
    if ($comp > 0) {
        throw new APIException('Start date is greater than end date.', 204);
    }

    global $G_container_base;
    $uum = $G_container_base->getInstance('uum');

    if ( ! isset($in->userId)) {
        $user = $uum->getLoginUser();
    } elseif (is_numeric($in->userId)) {
        $user = $uum->getUser($in->userId);
        if ( ! $user) {
            throw new APIException('User is not found.', 301);
        }
    } else {
        throw new APIException('Parameter:userId is invalid.', 202);
    }

    // re-format ISO8601
    $start = formatISO8601($startUTC);
    $end = formatISO8601($endUTC);

    $tmpEvents = getEventsByTarget($start, $end, 'user', $user->getOID());
}

function formatISO8601(CB_DateTime $datetime)
{
    return sprintf('%04d-%02d-%02dT%02d:%02d:%02dZ', $datetime->year,
        $datetime->month, $datetime->day, $datetime->hour, $datetime->minute,
        $datetime->second);
}


function makeTemporaryEvent($eventId, $facilityId, $item)
{
    $temporaryEvent = new stdClass();
    $temporaryEvent->id = $eventId;
    $temporaryEvent->temporaryId = safeMember($item, 'temporary_id');
    $temporaryEvent->facilityId = $facilityId;
    $temporaryEvent->start = safeMember($item, 'setdatetime');
    $temporaryEvent->end = safeMember($item, 'enddatetime');

    return $temporaryEvent;
}

require_once('schedule/facility_system_logic.csp');
$facility_logic = GRN_Facility_SystemLogic::getInstance();

$temporaryEventIds = [];
$events = [];
foreach ($tmpEvents as $tmpEvent) {
    foreach ($tmpEvent as $e) {

        $type = $e['event_type'];

        $eventId = $e['id'];
        if ($type == 'temporary' && in_array($eventId, $temporaryEventIds)) {
            continue;
        }

        $event = new stdClass();
        $event->id = intval($eventId);
        $event->private = (safeMember($e, 'public_type') == 'private');
        $event->allDay = ($type == 'banner'
                          || (safeMember($e, 'allday') == 'true'));
        $event->banner = ($type == 'banner');
        if ($type == 'repeat') {
            if ($event->allDay) {
                $start = explode(' ', $e['start_date_time']);
                $event->start = $start[0];
                $end = safeMember($e, 'end_date_time', null);
                if ($end) {
                    $end = explode(' ', $end);
                    $event->end = $end[0];
                } else {
                    $event->end = null;
                }
            } else {
                $event->start = $e['start_date_time'];
                $event->end = safeMember($e, 'end_date_time', null);
            }
            $repeat = new stdClass();
            $repeatType = $e['repeat_type'];
            $repeat->from = $e['start_date'];
            $repeat->until = null;
            $until = safeMember($e, 'end_date', null);
            if ($until) {
                $untilDate = new CB_Date();
                if ($untilDate->parse($until)) {
                    $untilDate = new CB_DateEx($untilDate);
                    $untilDate->moveDays(1);
                    $repeat->until = $untilDate->format();
                }
            }
            $repeat->type = $repeatType;
            if ($repeatType == 'day' || $repeatType == 'weekday') {
            } elseif ($repeatType == 'month') {
                $repeat->mday = $e['day'];
            } elseif (strpos($repeatType, 'week') !== false) {
                $repeat->wday = $e['week'];
            }
            if ( ! $event->allDay) {
                $repeat->start = safeMember($e, 'start_time', null);
                $repeat->end = safeMember($e, 'end_time', null);
                $repeat->timezone = safeMember($e, 'timezone', null);
                //if ($timezone) {
                //    $tzOffset = cb_get_timezone_offset($timezone);
                //    $tzOffsetHour = intval($tzOffset / 3600);
                //    $tzOffsetMin = intval(($tzOffset % 3600) / 60);
                //    $repeat->tzOffset = sprintf('%+03d:%02d', $tzOffsetHour, $tzOffsetMin);
                //}
            }
            $event->recurrence = $repeat;
            $event->temporary = null;
        } elseif ($type == 'temporary') {
            $event->start = null;
            $event->end = null;
            $event->recurrence = null;
            $event->temporary = null;
        } else {
            $event->start = safeMember($e, 'start_date', null);
            $event->end = safeMember($e, 'end_date', null);
            $event->recurrence = null;
            $event->temporary = null;
        }

        $plan = safeMember($e, 'plan');
        $detail = safeMember($e, 'detail');
        $event->title = (strlen($plan) && strlen($detail))
            ? "{$plan}:{$detail}" : ($plan . $detail);
        $event->plan = $plan;
        $event->detail = $detail;
        $event->body = safeMember($e, 'memo');

        $users = [];
        if (isset($e['users'])) {
            foreach ($e['users'] as $item) {
                if ( ! is_null($appId) && $infoType) {
                    $user_info = $uum->getUserInfo($item['id']);
                    $user_info_class = new stdClass();
                    $user_info_class->login_name
                        = $user_info['col_foreign_key'];

                    require_once("grn/controller.csp");
                    $user_info_class->display_name
                        = GRN_ControllerUtil::getUserNameText($uum->getLoginUser()
                                                                  ->getOID(),
                        $item['id'], [], false);
                    $users[] = $user_info_class;
                } else {
                    $users[] = intval($item['id']);
                }
            }
        }
        $event->users = $users;

        $facilities = [];
        if (isset($e['facilities'])) {
            foreach ($e['facilities'] as $item) {
                if ( ! is_null($appId) && $infoType) {
                    $facility_info
                        = $facility_logic->getFacilityInfo($item['id']);
                    $facilities[] = $facility_info['col_name'];
                } else {
                    $facilities[] = intval($item['id']);
                }
            }
        }
        $event->facilities = $facilities;

        if (defined('ON_FOREST')) {
            $appIdTmp = [];
            $recordIdTmp = [];
            if ($e['event_type'] == 'normal') {
                $relation_setting_logic = new AppRelationSettingLogic();
                $relation_settings
                    = $relation_setting_logic->getAllRelationSettings("schedule/add");
                $own_related_kintoneapp = [];
                foreach ($relation_settings as $r_key => $r_value) {
                    if (array_key_exists(AppRelationSettingLogic::ALL_MENU,
                            $r_value)
                        && $r_value[AppRelationSettingLogic::ALL_MENU]
                    ) {
                        $own_related_kintoneapp[$r_key]
                            = $r_value[AppRelationSettingLogic::KINTONE_APP];
                    } elseif (array_key_exists(AppRelationSettingLogic::MENUS,
                            $r_value)
                              && in_array($plan,
                            $r_value[AppRelationSettingLogic::MENUS])
                    ) {
                        $own_related_kintoneapp[$r_key]
                            = $r_value[AppRelationSettingLogic::KINTONE_APP];
                    }
                }

                $schedule_kintone_logic = new scheduleKintoneAppRelationLogic();
                $schedule_kintone_records
                    = $schedule_kintone_logic->getRelatedAppRecords(intval($eventId),
                    $own_related_kintoneapp);
                foreach ($schedule_kintone_records as $k_key => $k_records) {
                    if (cb_at($schedule_kintone_records, $k_key)) {
                        $appIdTmp[]
                            = $k_records[GrnKintoneAppRelationSetting::VALUE_KEY_APP_ID];
                        if ( ! is_null($k_records["record_id"])
                             && strlen($k_records["record_id"]) > 0
                        ) {
                            $recordIdTmp[] = $k_records["record_id"];
                        }
                    }
                }
            }
            $event->appId = $appIdTmp;
            $event->recordId = $recordIdTmp;
        }

        if ($type != 'temporary') {
            // not temporary event
            $events[] = $event;
            continue;
        }

        // temporary event

        $temporaries = safeMember($e, 'temporary');
        if ( ! is_array($temporaries)) {
            continue;
        }

        $temporary = new stdClass();
        $temporary->temporaryId = null;
        if (safeMember($e, 'temporary_type') == 'or') {
            $temporary->type = 'OR';
            $temporary->events = [];
            foreach ($temporaries as $item) {
                $facilityId = safeMember($item, 'facility_id');
                if ( ! is_null($appId) && $infoType) {
                    $facilityId
                        = $facility_logic->getFacilityInfo($facilityId)['col_name'];
                }
                $dates = safeMember($item, 'dates');
                if ( ! is_array($dates)) {
                    continue;
                }
                foreach ($dates as $item) {
                    $temporary->events[] = makeTemporaryEvent($eventId,
                        $facilityId, $item);
                }
            }
        } else {
            $facilityId = count($facilities) ? reset($facilities) : null;
            $temporary->type = 'AND';
            $temporary->events = [];
            foreach ($temporaries as $item) {
                $temporary->events[] = makeTemporaryEvent($eventId, $facilityId,
                    $item);
            }
        }

        foreach ($temporary->events as $item) {
            if ( ! $item->start) {
                continue;
            }
            if (strcmp($end, $item->start) <= 0) {
                continue;
            }
            if (strcmp($item->start, $start) < 0) {
                if ( ! $item->end) {
                    continue;
                }
                if (strcmp($item->end, $start) <= 0) {
                    continue;
                }
            }

            $cloneEvent = clone $event;
            $cloneEvent->temporary = clone $temporary;
            $cloneEvent->temporary->temporaryId = $item->temporaryId;
            $cloneEvent->start = $item->start;
            $cloneEvent->end = $item->end;
            if ($temporary->type == 'OR') {
                $cloneEvent->facilities = [$item->facilityId];
            }
            $events[] = $cloneEvent;
        }

        $temporaryEventIds[] = $eventId;
    }
}

//GTM-1543 F5.1 with when appid not null ORDER BY START TIME
if (defined('ON_FOREST') && ! is_null($appId)) {
    usort($events, function ($a, $b) {
        $aTimeTmp = preg_match("/^([0-9]+)-([0-9]+)-([0-9]+)$/", $a->start)
            ? $a->start . "T00:00:00Z" : $a->start;
        $aTime = grn_cbpapi_parse_iso8601($aTimeTmp);
        $atsex = new CB_TimeStampEx();
        $atsex->setDateTime($aTime);

        $bTimeTmp = preg_match("/^([0-9]+)-([0-9]+)-([0-9]+)$/", $b->start)
            ? $b->start . "T00:00:00Z" : $b->start;
        $bTime = grn_cbpapi_parse_iso8601($bTimeTmp);
        $btsex = new CB_TimeStampEx();
        $btsex->setDateTime($bTime);

        if ($atsex->unix_ts == $btsex->unix_ts) {
            if ($a->id > $b->id) {
                return 1;
            } elseif ($a->id < $b->id) {

                return -1;
            } else {
                return 0;
            }
        }
        if ($atsex->unix_ts > $btsex->unix_ts) {
            global $dateTimeOrder;

            return $dateTimeOrder ? -1 : 1;
        }
        if ($atsex->unix_ts < $btsex->unix_ts) {
            global $dateTimeOrder;

            return $dateTimeOrder ? 1 : -1;
        }
    });
} else {
    usort($events, function ($a, $b) {
        if ($a->start < $b->start) {
            return -1;
        }
        if ($a->start > $b->start) {
            return 1;
        }
        if (is_null($a->end) && is_null($b->end)) {
            return 0;
        }
        if (is_null($a->end)) {
            return -1;
        }
        if (is_null($b->end)) {
            return 1;
        }
        if ($a->end < $b->end) {
            return -1;
        }
        if ($a->end > $b->end) {
            return 1;
        }

        return 0;
    });
}

$next = null;
if (defined('ON_FOREST') && ! is_null($appId)) {
    if ( ! is_null($limit)) {
        $all_events_num = count($events);
        $next = $offset + $limit >= $all_events_num ? null
            : $offset + $limit;
        $events = array_slice($events, $offset, $limit);
    } else {
        $events = array_slice($events, $offset);
    }
}
$result = new stdClass();
$result->success = true;
$result->rows = $events;
if (defined('ON_FOREST') && ! is_null($appId)) {
    $result->next = $next;
}
echo json_encode($result);
