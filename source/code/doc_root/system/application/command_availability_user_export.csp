<?php

use grn\grn\access\utility\AppAvailabilityUtil;
use grn\grn\access\logic\AvailabilitySettingLogic;
use grn\grn\access\bean\Availability;

$charset = null;
if (array_key_exists('charset', $G_INPUT)) {
    $charset = $G_INPUT['charset'];
}

if (0 == strlen($charset)) {
    global $G_config_common;
    $charset = $G_config_common->get('I18N', 'default_external_encoding');
}

$item_name = null;
if (array_key_exists('item_name', $G_INPUT)) {
    $item_name = $G_INPUT['item_name'];
}

global $G_container_base;
$uum = $G_container_base->getInstance('uum');

require_once('fw/csv.csp');
$temp_dir = cb_tmpdir();
$temp_file_name = tempnam($temp_dir, 'path_');
$csv_writer = new CB_CSVWriter($charset, $temp_file_name);

require_once('grn/application.csp');
$locator = GRN_ApplicationLocator::instance();
$activated_app_ids = AppAvailabilityUtil::getActiveAppIds();

if ($item_name) {
    require_once('fw/i18n.csp');
    $header = [];
    $header[] = cb_msg('grn.system.application', 'availability_csv_item');
    $header[] = cb_msg('grn.system.application', 'availability_csv_target');

    foreach ($activated_app_ids as $app_id) {
        $app = $locator->getInstance($app_id, true);
        $header[] = $app->getName();
    }
    $csv_writer->writeLine($header);
}

$availability_setting_logic = new AvailabilitySettingLogic();

$targets = [
    'dynamic_role' => Availability::DYNAMIC_ROLE,
    'static_role'  => Availability::STATIC_ROLE,
    'group'        => Availability::GROUP,
    'user'         => Availability::USER
];

foreach ($targets as $item => $target_type) {
    $availabilities = $availability_setting_logic->getAll($target_type);

    foreach ($availabilities as $availability) {
        $export_apps = [];
        $export_apps['item'] = $item;

        $target_id = $availability->getTarget();

        if ($target_type === Availability::STATIC_ROLE) {
            $target = _getTargetID($uum, $target_type, $target_id);
        } elseif ($target_type === Availability::GROUP) {
            $target = _getTargetID($uum, $target_type, $target_id);
        } elseif ($target_type === Availability::USER) {
            $target = _getTargetID($uum, $target_type, $target_id);
        } else {
            $target = $target_id;
        }

        if ($target === false) {
            continue;
        }
        $export_apps['target'] = $target;

        $apps = $availability->getAppsAvailability();

        foreach ($apps as $app => $value) {
            if ( ! in_array($app, $activated_app_ids)) {
                continue;
            }

            if ($value['internal'] === AppAvailabilityUtil::ACCESS_ALLOWED) {
                if ($value['external']
                    === AppAvailabilityUtil::ACCESS_ALLOWED
                ) {
                    $export_apps[$app]
                        = AppAvailabilityUtil::APP_USE_UNPROHIBITED;
                } else {
                    $export_apps[$app]
                        = AppAvailabilityUtil::APP_USE_EXTERNAL_PROHIBITED;
                }
            } else {
                $export_apps[$app] = AppAvailabilityUtil::APP_USE_PROHIBITED;
            }
        }

        $csv_writer->writeLine($export_apps);
    }
}

$csv_writer->close();

require_once('grn/logger.csp');
$logger_manager = CB_LoggerManager::getInstance();
$_logger = &$logger_manager->getLogger('grn.common');
$log_params = [];
$_logger->noticeEx('export', 'availability_user_export', $log_params);

cb_prepare_download('paths.csv', 'application/csv', false);
$fp = fopen($temp_file_name, 'rb');
$file_size = filesize($temp_file_name);

if (0 < $file_size) {
    echo fread($fp, $file_size);
}

fclose($fp);
unlink($temp_file_name);

function _getTargetID($uum, $target_type, $target_id)
{
    switch ($target_type) {
        case Availability::STATIC_ROLE:
            $target = $uum->getStaticRole($target_id);
            break;
        case Availability::GROUP:
            $target = $uum->getGroup($target_id);
            break;
        case Availability::USER:
            $target = $uum->getUser($target_id);
            break;
    }

    $foreignkey = false;
    if (is_object($target)) {
        $foreignkey = $target->get('foreign_key');
    }

    return $foreignkey;
}
