<?php

use grn\grn\access\bean\Availability;
use grn\grn\access\logic\AvailabilitySettingLogic;
use grn\grn\access\utility\AppAvailabilityUtil;

if (array_key_exists('REQUEST_METHOD', $_SERVER)
    && 0 == strcasecmp($_SERVER['REQUEST_METHOD'], 'POST')
) {
    //Get Session
    require_once('fw/session_manager.csp');
    $session_manager = CB_SessionManager::getInstance();

    $session_name = 'system.availability_user_add';
    $session =& $session_manager->getSession($session_name);
    $session_uids = $session->get('target_ids');

    if ( ! is_array($session_uids) || 0 == count($session_uids)) {
        cb_redirect('system/application/availability_user_list',
            ['sf' => true]);
    }

    //Add Availability Right
    if (0 < count($session_uids)) {
        $external_setting
            = AvailabilitySettingLogic::getExternalAccessSetting();
        $app_availability_setting_logic = new AvailabilitySettingLogic();
        $apps_active
            = $app_availability_setting_logic->getActiveAppIds();

        $creation_time = time();
        $apps_active = array_fill_keys($apps_active, false);
        $app_log = array_fill_keys(AppAvailabilityUtil::$appIdsPrefix, 0);

        $target_type_map = [
            'user'         => Availability::USER,
            'group'        => Availability::GROUP,
            'dynamic_role' => Availability::DYNAMIC_ROLE,
            'static_role'  => Availability::STATIC_ROLE
        ];
        $apps_setting = [];
        $apps_ext = array_fill_keys(cb_at($G_INPUT, 'ext_appIds', []),
            true);
        $apps = array_fill_keys(cb_at($G_INPUT, 'appIds', []), true);
        $apps_active = array_merge($apps_active, $apps);
        foreach ($apps_active as $app_id => $is_active_app) {
            $apps_setting[$app_id]
                = [
                'internal' => AppAvailabilityUtil::ACCESS_DENIED,
                'external' => AppAvailabilityUtil::ACCESS_DENIED
            ];
            $log_app_key = cb_at(AppAvailabilityUtil::$appIdsPrefix,
                $app_id);
            $app_log[$log_app_key] = AppAvailabilityUtil::APP_USE_PROHIBITED;

            if ($is_active_app) {
                $apps_setting[$app_id]['internal']
                    = AppAvailabilityUtil::ACCESS_ALLOWED;
                $app_log[$log_app_key]
                    = AppAvailabilityUtil::APP_USE_UNPROHIBITED;

                if ($external_setting
                    == AvailabilitySettingLogic::ACCESS_TYPE_UNRESTRICTED
                ) {
                    $apps_setting[$app_id]['external']
                        = AppAvailabilityUtil::ACCESS_ALLOWED;
                } elseif (array_key_exists($app_id, $apps_ext)
                          && $apps_ext[$app_id]
                ) {
                    $apps_setting[$app_id]['external']
                        = AppAvailabilityUtil::ACCESS_ALLOWED;
                }
                if ($app_id !== 'cellular'
                    && $apps_setting[$app_id]['external']
                       === AppAvailabilityUtil::ACCESS_DENIED
                ) {
                    $app_log[$log_app_key]
                        = AppAvailabilityUtil::APP_USE_EXTERNAL_PROHIBITED;
                }
            }
        }
        $str_message_body = http_build_query($app_log, null, ",");
        $str_message_body = str_replace("=", ":", $str_message_body);
        $log_messages = [];
        $apps_availability = [];
        foreach (array_keys($session_uids) as $value) {
            $id_pair = explode(':', $value);
            if (count($id_pair) != 2) {
                continue;
            }
            $type = $id_pair[0];
            $ids = $id_pair[1];
            $log_messages["{$type}_{$ids}"] = $str_message_body;

            $app_availability = new Availability();
            $app_availability->setCreationTime($creation_time);
            $app_availability->setTarget($ids);
            $app_availability->setTargetType($type);
            $app_availability->setAppsAvailability(['availability' => $apps_setting]);

            $apps_availability[$type][$ids] = $app_availability;
        }
        if (array_key_exists('user', $apps_availability)
            && count($apps_availability['user']) > 0
        ) {
            global $G_container_base;
            $uum = $G_container_base->getInstance('uum');
            $users_info
                = $uum->getUsersInfo(array_keys($apps_availability['user']));
            $invalid_users = array_diff(array_keys($apps_availability['user']),
                array_keys($users_info));
            foreach ($invalid_users as $invalid_user) {
                unset($log_messages["user_" . $invalid_user]);
                unset($apps_availability['user'][$invalid_user]);
            }
        }

        foreach ($target_type_map as $key => $type) {
            if (array_key_exists($key, $apps_availability)
                && count($apps_availability[$key]) > 0
            ) {
                $app_availability_setting_logic->deleteByTargetIds(array_keys($apps_availability[$key]),
                    $type);
                $app_availability_setting_logic->insertTargets($apps_availability[$key],
                    $type);
            }
        }

        //write log
        if (count($log_messages) > 0) {
            require_once('grn/logger.csp');
            $logger_manager = CB_LoggerManager::getInstance();
            $_logger = &$logger_manager->getLogger('grn.common');
            $_logger->noticeEx('add', 'availability_user_add', $log_messages);
        }
    }

    cb_redirect('system/application/availability_user_list', ['sf' => true]);
}
