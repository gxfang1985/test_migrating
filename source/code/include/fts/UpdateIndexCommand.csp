<?php

namespace grn\fts;

class UpdateIndexCommand
{
    private static $UPDATE_DOCUMENTS
        = [
            2 => ['message.folderRelation'],
            3 => ['space.todo', 'space.todoComment']
        ];

    const DEFAULT_MAX_JOB_NUM = 10;

    /** @var int */
    private $currentSchemaVersion;
    /** @var int */
    private $latestSchemaVersion;

    /** @var  string[] */
    private $input;

    function __construct()
    {
        $this->currentSchemaVersion = Application::getSchemaVersion();
        $this->latestSchemaVersion = Application::LATEST_SCHEMA_VERSION;

        global $G_INPUT;
        $this->input = $G_INPUT;
    }

    public function execute()
    {
        if ( ! Application::isAvailable()) {
            cb_throw_error(E_GRN_APPLICATION_NOT_AVAILABLE);
        }

        $this->setupOutputBuffering();

        if ($this->currentSchemaVersion === $this->latestSchemaVersion) {
            echo 'No need to update index.' . PHP_EOL;
            cb_safe_exit(0);
        }

        if ( ! isset($this->input['exec'])) {
            echo "Current schema version: {$this->currentSchemaVersion}"
                 . PHP_EOL;
            echo "Latest schema version: {$this->latestSchemaVersion}"
                 . PHP_EOL;
            cb_safe_exit(0);
        }

        if ( ! isset ($this->input['maxJobNum'])) {
            $this->input['maxJobNum'] = self::DEFAULT_MAX_JOB_NUM;
        }

        $this->input['document'] = implode(',',
            $this->calculateDocumentsToUpdate());

        $factory = new FullIndexerFactory($this->input);
        $indexer = $factory->createFullIndexer();
        $indexer->execute();
    }

    private function calculateDocumentsToUpdate()
    {
        $documentsToUpdate = [];
        for (
            $next = $this->currentSchemaVersion + 1;
            $next <= $this->latestSchemaVersion; $next++
        ) {
            $documentsToUpdate = array_merge($documentsToUpdate,
                self::$UPDATE_DOCUMENTS[$next]);
        }

        return $documentsToUpdate;
    }

    private function setupOutputBuffering()
    {
        // disable output buffering for command-line
        while (ob_get_level() > 0) {
            ob_end_clean();
        }
        // enable automatic flushing upon every 'echo'.
        ob_implicit_flush();
    }
}
