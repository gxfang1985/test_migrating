<?php
declare(strict_types=1);

namespace grn\api\validator\schedule;

use grn\api\v1\schedule\GetEventsApi;
use grn\api\validator\CheckerBase;
use grn\api\exception\ErrorCode;
use grn\api\exception\validation\ValidationFailedException;
use grn\schedule\rest_api\EventCheckUtil;

class GetEventsCorrelationChecker extends CheckerBase
{

    const PARAM_KEYWORD = GetEventsApi::PARAM_KEYWORD;
    const PARAM_EXCLUDE_FROM_SEARCH = GetEventsApi::PARAM_EXCLUDE_FROM_SEARCH;
    const PARAM_TARGET = GetEventsApi::PARAM_TARGET;
    const PARAM_TARGET_TYPE = GetEventsApi::PARAM_TARGET_TYPE;
    const PARAM_RANGE_START = GetEventsApi::PARAM_RANGE_START;
    const PARAM_RANGE_END = GetEventsApi::PARAM_RANGE_END;

    const DEFAULT_SETDATE = GetEventsApi::DEFAULT_SETDATE;
    const DEFAULT_ENDDATE = GetEventsApi::DEFAULT_ENDDATE;

    /**
     * @param array|string $param_name
     * @param array        $input
     *
     * @return bool
     */
    public function check($param_name, array $input): bool
    {
        $this->checkRangeStartAndRangeEnd($input);
        $this->checkTargetAndTargetType($input);
        $this->checkKeywordAndExcludeFromSearch($input);

        return true;
    }

    /**
     * @param array $input
     *
     * @return bool
     * @throws ValidationFailedException
     */
    private function checkKeywordAndExcludeFromSearch(array $input): bool
    {
        $keyword = $input[self::PARAM_KEYWORD] ?? null;
        $excludeFromSearch = $input[self::PARAM_EXCLUDE_FROM_SEARCH] ?? null;

        if ( ! is_null($excludeFromSearch)) {
            if (is_null($keyword)) {
                throw new ValidationFailedException(ErrorCode::MISSING_RELEVANT_PARAMETER,
                    null, null,
                    [
                        'param1' => self::PARAM_EXCLUDE_FROM_SEARCH,
                        'param2' => self::PARAM_KEYWORD
                    ]);
            }

            $exclude_options = ['subject', 'company', 'notes', 'comments'];
            $excludes = explode(',', $excludeFromSearch);
            foreach ($excludes as $exclude) {
                if (in_array($exclude, $exclude_options, true) === false) {
                    throw new ValidationFailedException(ErrorCode::INVALID_ITEM_TYPE,
                        self::PARAM_EXCLUDE_FROM_SEARCH);
                }
            }
        }

        return true;
    }

    /**
     * @param string[] $input
     *
     * @return bool
     * @throws ValidationFailedException
     */
    private function checkTargetAndTargetType(array $input): bool
    {
        $target = $input[self::PARAM_TARGET] ?? null;
        $target_type = $input[self::PARAM_TARGET_TYPE] ?? null;

        if (is_null($target) && is_null($target_type)) {
            return true;
        }

        if ( ! is_null($target) && is_null($target_type)) {
            throw new ValidationFailedException(ErrorCode::MISSING_RELEVANT_PARAMETER,
                null, null,
                [
                    'param1' => self::PARAM_TARGET,
                    'param2' => self::PARAM_TARGET_TYPE
                ]);
        }
        if (is_null($target) && ! is_null($target_type)) {
            throw new ValidationFailedException(ErrorCode::MISSING_RELEVANT_PARAMETER,
                null, null,
                [
                    'param1' => self::PARAM_TARGET_TYPE,
                    'param2' => self::PARAM_TARGET
                ]);
        }

        $options = ['organization', 'facility', 'user'];
        if (in_array($target_type, $options, true) === false) {
            throw new ValidationFailedException(ErrorCode::INVALID_ITEM_TYPE,
                self::PARAM_TARGET_TYPE);
        }

        $upper_target_type = mb_strtoupper($target_type);
        if (EventCheckUtil::isIdExist($target, $upper_target_type) === false) {
            throw new ValidationFailedException(ErrorCode::TARGET_DOES_NOT_EXIST,
                self::PARAM_TARGET);
        }
        $has_authority = EventCheckUtil::hasAuthorityToTarget($target,
            $upper_target_type, ['read']);
        if ($has_authority === false) {
            throw new ValidationFailedException(ErrorCode::TARGET_IS_NOT_ACCESSIBLE,
                self::PARAM_TARGET);
        }

        return true;
    }

    /**
     * @param array $input
     *
     * @return bool
     * @throws ValidationFailedException
     */
    private function checkRangeStartAndRangeEnd(array $input): bool
    {
        $setdate = \CB_ISO8601Util::toUTCDateTime(
            $input[self::PARAM_RANGE_START] ?? self::DEFAULT_SETDATE);
        $enddate = \CB_ISO8601Util::toUTCDateTime(
            $input[self::PARAM_RANGE_END] ?? self::DEFAULT_ENDDATE);

        if ($enddate->compare($setdate) <= 0) {
            throw new ValidationFailedException(ErrorCode::INCOMPATIBLE_PARAMETERS,
                null,
                null, [
                    "param1" => self::PARAM_RANGE_END,
                    'param2' => self::PARAM_RANGE_START
                ]);
        }

        return true;
    }
}
