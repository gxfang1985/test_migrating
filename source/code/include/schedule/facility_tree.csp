<?php

use grn\grn\JSONResponse;

require_once('grn/org_tree.csp');
require_once('schedule/resources.csp');

define('GRN_FACILITY_TREE_STATUS_TYPE', 'status');
define('GRN_FACILITY_TREE_STATUS_NORMAL', 'normal');
define('GRN_FACILITY_TREE_STATUS_GRAY', 'gray');
define('GRN_FACILITY_TREE_STATUS_SELF', 'self');

class GRN_FacilityTree extends GRN_OrgTree
{
    public $_nodes = null;

    public $_tree = null;

    public $_selectedNode = null;

    public $_groups_have_childs = null;

    public $_uid = null;

    function __construct()
    {
        $this->_groups_have_childs = [];
        //$this->initialize();
    }

    /**
     * @param int $uid
     */
    function setUID($uid)
    {
        $this->_uid = $uid;
    }

    function getUID()
    {
        return $this->_uid;
    }

    /**
     * @access private
     * 子組織数を取得する。
     *
     * @param int $oid 親組織ID
     *
     * @return int  子組織数
     */
    function _getChildCount($oid)
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();
        $groups = $fsl->getFacilityGroupChildrenInfo($oid);

        return count($groups);
    }

    /**
     * @access private
     * 子組織を取得する。
     *
     * @param int $oid 親組織ID
     *
     * @return array 子組織
     */
    function _getChildren($oid)
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        return $fsl->getFacilityGroupChildrenInfo($oid);
    }

    /**
     * 選択中のノードOIDを取得する。
     *
     * @return int oid
     */
    function getSelectedNode()
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();
        //for check if it really exist
        if ( ! is_null($this->_selectedNode)) {
            $select_node = $fsl->getFacilityGroup($this->_selectedNode);
            if ($select_node === false) {
                $this->_selectedNode = null;
                $this->initialize();

                return null;
            }
        }

        return $this->_selectedNode;
    }

    /**
     * ツリーの子ノードを構築する。
     *
     * @param int  $parent_oid 親ノードID
     * @param bool $expanded
     * @param bool $force
     *
     * @return array|bool  構築した子ノード
     */
    function buildChild($parent_oid, $expanded = false, $force = true)
    {
        return $this->_buildChild($parent_oid, $expanded, $force);
    }

    /**
     * @param int $oid
     *
     * @return  array associated array
     */
    function _getAncestors($oid)
    {
        if ($oid < 1) {
            return null;
        }

        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        $parents = $fsl->getAncestors([$oid => 1]);
        $parents = array_reverse($parents[$oid]);

        if (is_null($parents)) {
            return null;
        }

        $ret = [];
        foreach ($parents as $pid) {
            $ret[$pid] = $pid;
        }

        return $ret;
    }
}

class GRN_FacilityAccessTree extends GRN_OrgTree
{
    public $_nodes = null;

    public $_tree = null;

    public $_selectedNode = null;

    public $_groups_have_childs = null;

    public $_uid = null;

    public $_access_list = null;

    private $lax_evaluate = false;

    function __construct($access_list = null)
    {
        $this->_groups_have_childs = [];
        if (is_null($access_list)) {
            $access_list = ['read'];
        }
        $this->_access_list = $access_list;
    }

    /**
     * @param int $uid
     */
    function setUID($uid)
    {
        $this->_uid = $uid;
    }

    function getUID()
    {
        return $this->_uid;
    }

    /**
     * @access private
     * 子組織数を取得する。
     *
     * @param int $oid 親組織ID
     *
     * @return int 子組織数
     */
    function _getChildCount($oid)
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();
        require_once('schedule/access_logic.csp');
        $acc_logic = GRN_Schedule_Access_Logic::getInstance();

        global $G_container_base;
        $uum = $G_container_base->getInstance('uum');
        $dynamic_roles = $uum->listGrantedRoles();
        $login = $uum->getLoginUser();

        $groups = $fsl->getFacilityGroupChildrenInfo($oid);
        $evaluated_groups = $acc_logic->evaluateAccessesById($login, $groups,
            $this->_access_list, $dynamic_roles, 'facilitygroup', false,
            $this->lax_evaluate);

        return count($evaluated_groups);
    }

    /**
     * @access private
     * 子組織を取得する。
     *
     * @param int $oid 親組織ID
     *
     * @return array 子組織
     */
    function _getChildren($oid)
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();
        require_once('schedule/access_logic.csp');
        $acc_logic = GRN_Schedule_Access_Logic::getInstance();

        global $G_container_base;
        $uum = $G_container_base->getInstance('uum');
        $dynamic_roles = $uum->listGrantedRoles();
        $login = $uum->getLoginUser();

        $groups = $fsl->getFacilityGroupChildrenInfo($oid);
        $evaluated_groups = $acc_logic->evaluateAccessesById($login, $groups,
            $this->_access_list, $dynamic_roles, 'facilitygroup', false,
            $this->lax_evaluate);

        return $evaluated_groups;
    }

    /**
     * 選択中のノードOIDを取得する。
     *
     * @return int oid
     */
    function getSelectedNode()
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();
        require_once('schedule/access_logic.csp');
        $acc_logic = GRN_Schedule_Access_Logic::getInstance();

        global $G_container_base;
        $uum = $G_container_base->getInstance('uum');
        $dynamic_roles = $uum->listGrantedRoles();
        $login = $uum->getLoginUser();

        $fgroup = $fsl->getFacilityGroup($this->_selectedNode);
        if ($fgroup === false) {
            $evaluated = [];
        } else {
            $fgroup_array = [$fgroup->getOID() => 1];
            $evaluated = $acc_logic->evaluateAccessesById($login,
                $fgroup_array, $this->_access_list, $dynamic_roles,
                'facilitygroup');
        }

        if ( ! is_null($this->_selectedNode) && count($evaluated) == 0) {
            $this->_selectedNode = null;
            $this->initialize();

            return null;
        } else {
            return $this->_selectedNode;
        }
    }

    /**
     * ツリーの子ノードを構築する。
     *
     * @param int  $parent_oid 親ノードID
     * @param bool $expanded
     * @param bool $force
     *
     * @return array|bool 構築した子ノード
     */
    function buildChild($parent_oid, $expanded = false, $force = true)
    {
        return $this->_buildChild($parent_oid, $expanded, $force);
    }

    /**
     * To get ancestors of a node
     * The return value of this method provides data for expandTo() method to expand the tree to selected node
     *
     * @param int $oid
     *
     * @return  array associated array
     */
    function _getAncestors($oid)
    {
        if ($oid < 1) {
            return null;
        }

        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        $parents = $fsl->getAncestors([$oid => 1]);
        $parents = array_reverse($parents[$oid]);

        if (is_null($parents)) {
            return null;
        }

        // If a user can access to $oid, then he/she can also access to the ancestors
        // Therefore we return all ancestors
        $ret = [];
        foreach ($parents as $pid) {
            $ret[$pid] = $pid;
        }

        return $ret;
    }

    /**
     * @param bool $value
     */
    public function setLaxEvaluate($value = false)
    {
        $this->lax_evaluate = $value;
    }
}

class GRN_FacilityPrivilegeTree extends GRN_OrgTree
{
    public $_nodes = null;

    public $_tree = null;

    public $_selectedNode = null;

    public $_groups_have_childs = null;

    public $_uid = null;

    function __construct()
    {
        $this->_groups_have_childs = [];
        //$this->initialize();
    }

    /**
     * @param int $uid
     */
    function setUID($uid)
    {
        $this->_uid = $uid;
    }

    function getUID()
    {
        return $this->_uid;
    }

    /**
     * @access private
     * 子組織数を取得する。
     *
     * @param int $oid 親組織ID
     *
     * @return int 子組織数
     */
    function _getChildCount($oid)
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();
        require_once('schedule/facility_privilege.csp');
        $privilege_logic = Grn_Facility_Privilege_Logic::getInstance();

        global $G_container_base;
        $uum = $G_container_base->getInstance('uum');
        $dynamic_roles = $uum->listGrantedRoles();
        $login = $uum->getLoginUser();

        $groups = $fsl->getFacilityGroupChildren($oid);
        $evaluated_groups = [];
        foreach ($groups as $key => $group) {
            if ($privilege_logic->hasPrivilegeOfFacilityGroup($login, $group)) {
                $evaluated_groups[] =& $group;
            }
        }

        return count($evaluated_groups);
    }

    /**
     * @access private
     * 子組織を取得する。
     *
     * @param int $oid 親組織ID
     *
     * @return array 子組織
     */
    function _getChildren($oid)
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();
        require_once('schedule/facility_privilege.csp');
        $privilege_logic = Grn_Facility_Privilege_Logic::getInstance();

        global $G_container_base;
        $uum = $G_container_base->getInstance('uum');
        $user = $uum->getUser($this->getUID());

        if ($oid == null) {
            $facilityGroupBeanList
                = $privilege_logic->getPrivilegeFacilityGroupListBeanByTopLevel($user);

            $evaluated_groups = [];
            foreach ($facilityGroupBeanList as $key => $facilityGroupBean) {
                $evaluated_groups[$key] = [
                    '_id'      => $facilityGroupBean->getId(),
                    'col_name' => $facilityGroupBean->getName()
                ];
            }
        } else {
            $facilityGroupBeanList = $fsl->getFacilityGroupChildrenBean($oid);

            $evaluated_groups = [];
            foreach ($facilityGroupBeanList as $key => $facilityGroupBean) {
                if ($privilege_logic->hasPrivilegeOfFacilityGroupByID($user,
                    $facilityGroupBean->getId())
                ) {
                    $evaluated_groups[$key]
                        = [
                        '_id'      => $facilityGroupBean->getId(),
                        'col_name' => $facilityGroupBean->getName()
                    ];
                }
            }
        }

        return $evaluated_groups;
    }

    /**
     * 選択中のノードOIDを取得する。
     *
     * @return int oid
     */
    function getSelectedNode()
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();
        require_once('schedule/facility_privilege.csp');
        $privilege_logic = Grn_Facility_Privilege_Logic::getInstance();

        global $G_container_base;
        $uum = $G_container_base->getInstance('uum');
        $dynamic_roles = $uum->listGrantedRoles();
        $login = $uum->getLoginUser();

        $fgroup = $fsl->getFacilityGroup($this->_selectedNode);

        $evaluated = [];
        if ($privilege_logic->hasPrivilegeOfFacilityGroup($login, $fgroup)) {
            $evaluated =& $fgroup;
        }

        if ( ! is_null($this->_selectedNode) && ! $evaluated) {
            $this->_selectedNode = null;
            $this->initialize();

            return null;
        } else {
            return $this->_selectedNode;
        }
    }

    /**
     * ツリーの子ノードを構築する。
     *
     * @param int  $parent_oid 親ノードID
     * @param bool $expanded
     * @param bool $force
     *
     * @return array|bool 構築した子ノード
     */
    function buildChild($parent_oid, $expanded = false, $force = true)
    {
        return $this->_buildChild($parent_oid, $expanded, $force);
    }

    /**
     * To get ancestors of a node
     * The return value of this method provides data for expandTo() method to expand the tree to selected node
     *
     * @param int $oid
     *
     * @return  array associated array
     */
    function _getAncestors($oid)
    {
        if ($oid < 1) {
            return null;
        }

        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        $parents = $fsl->getAncestors([$oid => 1]);
        $parents = array_reverse($parents[$oid]);

        if (is_null($parents)) {
            return null;
        }

        // If a user can access to $oid, then he/she can also access to the ancestors
        // Therefore we return all ancestors
        $ret = [];
        foreach ($parents as $pid) {
            $ret[$pid] = $pid;
        }

        return $ret;
    }
}

class GRN_FacilityGroupMoveTree extends GRN_OrgTree
{
    public $_nodes = null;

    public $_tree = null;

    public $_selectedNode = null;

    public $_groups_have_childs = null;

    public $_uid = null;

    public $_fagid = null;

    public $_my_children = null;

    function __construct($param)
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();
        if (array_key_exists('fagid', $param)) {
            $this->_fagid = $param['fagid'];
        }
        $this->_groups_have_childs = [];
        $this->_my_children
            = array_keys($fsl->getFacilityGroupChildrenInfo($this->getFAGID()));
        $this->_my_children[] = $this->getFAGID();
        //$this->initialize();
    }

    function initialize($expanded = false)
    {
        $this->_nodes = [];
        $this->_tree = [];
        $this->_groups_have_childs = [];
        $this->_my_children = [];
        $this->buildChild(null);

        return $this->_tree;
    }

    function setFAGID($fagid)
    {
        $this->_fagid = $fagid;
    }

    function getFAGID()
    {
        return $this->_fagid;
    }

    /**
     * @access private
     * 子組織数を取得する。
     *
     * @param int $oid 親組織ID
     *
     * @return int 子組織数
     */
    function _getChildCount($oid)
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        $fgroup_children = $this->_getChildren($oid);
        $this->_groups_have_childs[$oid] = count($fgroup_children);

        return $this->_groups_have_childs[$oid];
    }

    /**
     * @access private
     * 子組織を取得する。
     *
     * @param int $oid 親組織ID
     *
     * @return array 子組織
     */
    function _getChildren($oid)
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        $fgroup_children = $fsl->getFacilityGroupChildrenInfo($oid);

        if ($this->_my_children == null) {
            $this->_my_children
                = array_keys($fsl->getFacilityGroupChildrenInfo($this->getFAGID()));
            $this->_my_children[] = $this->getFAGID();
        }

        foreach (array_keys($fgroup_children) as $key) {
            if (array_search($key, $this->_my_children) !== false) {
                unset($fgroup_children[$key]);
            }
        }

        return $fgroup_children;
    }

    /**
     * 選択中のノードOIDを取得する。
     *
     * @return int oid
     */
    function getSelectedNode()
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        if ( ! is_null($this->_selectedNode)
             && $fsl->getFacilityGroup($this->_selectedNode) === false
        ) {
            $this->_selectedNode = null;
            $this->initialize();

            return null;
        } else {
            return $this->_selectedNode;
        }
    }

    /**
     * ツリーの子ノードを構築する。
     *
     * @param int  $parent_oid 親ノードID
     * @param bool $expanded
     * @param bool $force
     *
     * @return array|bool 構築した子ノード
     */
    function buildChild($parent_oid, $expanded = false, $force = true)
    {
        return $this->_buildChild($parent_oid, $expanded, $force);
    }

    /**
     * Build child node of tree.
     *
     * @param      $parent_oid
     * @param bool $expanded
     * @param bool $force
     * @param bool $subtree
     *
     * @return mixed The built child node
     */
    function _buildChild(
        $parent_oid,
        $expanded = false,
        $force = true,
        $subtree = false
    ) {
        if ($parent_oid) {
            $this->isInitialized();
            // (for non-root)
            $parent =& $this->_nodes[$parent_oid];
            if ( ! is_array($parent)) {
                $__ret = false;

                return $__ret;
            }

            if ( ! $force) {
                if (count($parent[GRN_ORG_TREE_CHILDREN])
                    == $parent[GRN_ORG_TREE_COUNT]
                ) {
                    return;
                }
            }

            // 循環参照を防ぐ
            unset($this->_nodes[$parent_oid]);

            $parent[GRN_ORG_TREE_CHILDREN] = [];
        }

        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        if ( ! is_null($parent_oid)) {
            $parent_oid_keys = [$parent_oid => $parent_oid];
            $parent_counts = $fsl->countAncestors($parent_oid_keys);
            $parent_counts = $parent_counts[$parent_oid];
        } else {
            $parent_counts = 0;
        }
        $children_count = $fsl->countTreeChildrenLength($this->getFAGID());
        if ($parent_counts + $children_count
            < GRN_SCHD_MAX_FACILITY_GROUP_TREE
        ) {
            $status = GRN_FACILITY_TREE_STATUS_NORMAL;
        } else {
            $status = GRN_FACILITY_TREE_STATUS_GRAY;
        }

        $child_rows = $this->_getChildren($parent_oid);

        foreach (array_keys($child_rows) as $id) {
            $oid = $child_rows[$id]['_id'];

            $children[$oid] = [
                GRN_ORG_TREE_OID              => $oid,
                GRN_ORG_TREE_NAME             => $child_rows[$id]['col_name'],
                GRN_ORG_TREE_PARENT           => $parent_oid,
                GRN_ORG_TREE_EXPANDED         => 0,
                GRN_FACILITY_TREE_STATUS_TYPE => $status
            ];
            if ($oid == $this->getFAGID()) {
                $children[$oid][GRN_FACILITY_TREE_STATUS_TYPE]
                    = GRN_FACILITY_TREE_STATUS_SELF;
            }
            $child_count = $this->_getChildCount($oid);
            $children[$oid][GRN_ORG_TREE_COUNT] = $child_count;
            $children[$oid][GRN_ORG_TREE_CHILDREN] = [];

            $node =& $this->_nodes[$oid];
            $this->_nodes[$oid] =& $children[$oid];
            if (is_array($node)) {
                if ($child_count > 0 && $node[GRN_ORG_TREE_EXPANDED] == 1) {
                    // recursive rebuild
                    $this->_buildChild($oid, $expanded, $force);
                }
            }
        }
        if ($parent_oid) {
            $parent[GRN_ORG_TREE_CHILDREN] =& $children;
            //$parent[ GRN_ORG_TREE_COUNT ] = count( $children );
            $parent[GRN_ORG_TREE_EXPANDED] = $expanded ? 1 : 0;
            $this->_nodes[$parent_oid] =& $parent;
        } else {
            $this->_tree =& $children;
        }

        return $children;
    }

    /**
     * To get ancestors of a node
     * The return value of this method provides data for expandTo() method to expand the tree to selected node
     *
     * @param int $oid
     *
     * @return  array associated array
     */
    function _getAncestors($oid)
    {
        if ($oid < 1) {
            return null;
        }

        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        $parents = $fsl->getAncestors([$oid => 1]);
        $parents = array_reverse($parents[$oid]);

        if (is_null($parents)) {
            return null;
        }

        // If a user can access to $oid, then he/she can also access to the ancestors
        // Therefore we return all ancestors
        $ret = [];
        foreach ($parents as $pid) {
            $ret[$pid] = $pid;
        }

        return $ret;
    }
}

class GRN_FacilityGroupMovePrivilegeTree extends GRN_OrgTree
{
    public $_nodes = null;

    public $_tree = null;

    public $_selectedNode = null;

    public $_groups_have_childs = null;

    public $_uid = null;

    public $_fagid = null;

    public $_my_children = null;

    function __construct($param)
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();
        if (array_key_exists('fagid', $param)) {
            $this->_fagid = $param['fagid'];
        }
        $this->_groups_have_childs = [];
        $this->_my_children
            = array_keys($fsl->getFacilityGroupChildrenInfo($this->getFAGID()));
        $this->_my_children[] = $this->getFAGID();
        //$this->initialize();
    }

    function setFAGID($fagid)
    {
        $this->_fagid = $fagid;
    }

    function getFAGID()
    {
        return $this->_fagid;
    }

    /**
     * @access private
     * 子組織数を取得する。
     *
     * @param int $oid 親組織ID
     *
     * @return int 子組織数
     */
    function _getChildCount($oid)
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        return count($this->_getChildren($oid));
        $fgroup_children = $this->_getChildren($oid);
        $this->_groups_have_childs[$oid] = count($fgroup_children);

        return $this->_groups_have_childs[$oid];
    }

    /**
     * @access private
     * 子組織を取得する。
     *
     * @param int $oid 親組織ID
     *
     * @return array 子組織
     */
    function _getChildren($oid)
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();
        require_once('schedule/facility_privilege.csp');
        $privilege_logic = Grn_Facility_Privilege_Logic::getInstance();

        global $G_container_base;
        $uum = $G_container_base->getInstance('uum');
        $user = $uum->getUser($this->getUID());

        if ($oid == null) {
            $facilityGroupBeanList
                = $privilege_logic->getPrivilegeFacilityGroupListBeanByTopLevel($user);

            $evaluated_groups = [];
            foreach ($facilityGroupBeanList as $key => $facilityGroupBean) {
                $evaluated_groups[$key] = [
                    '_id'      => $facilityGroupBean->getId(),
                    'col_name' => $facilityGroupBean->getName()
                ];
            }
        } else {
            $facilityGroupBeanList = $fsl->getFacilityGroupChildrenBean($oid);

            $evaluated_groups = [];
            foreach ($facilityGroupBeanList as $key => $facilityGroupBean) {
                if ($privilege_logic->hasPrivilegeOfFacilityGroupByID($user,
                    $facilityGroupBean->getId())
                ) {
                    $evaluated_groups[$key]
                        = [
                        '_id'      => $facilityGroupBean->getId(),
                        'col_name' => $facilityGroupBean->getName()
                    ];
                }
            }
        }

        return $evaluated_groups;
    }

    /**
     * 選択中のノードOIDを取得する。
     *
     * @return int oid
     */
    function getSelectedNode()
    {
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        if ( ! is_null($this->_selectedNode)
             && $fsl->getFacilityGroup($this->_selectedNode) === false
        ) {
            $this->_selectedNode = null;
            $this->initialize();

            return null;
        } else {
            return $this->_selectedNode;
        }
    }

    /**
     * ツリーの子ノードを構築する。
     *
     * @param int  $parent_oid 親ノードID
     * @param bool $expanded
     * @param bool $force
     *
     * @return array|bool 構築した子ノード
     */
    function buildChild($parent_oid, $expanded = false, $force = true)
    {
        return $this->_buildChild($parent_oid, $expanded, $force);
    }

    /**
     * Build the child node of tree
     *
     * @param      $parent_oid
     * @param bool $expanded
     * @param bool $force
     * @param bool $subtree
     *
     * @return mixed The built child node
     */
    function _buildChild(
        $parent_oid,
        $expanded = false,
        $force = true,
        $subtree = false
    ) {
        if ($parent_oid) {
            $this->isInitialized();
            // (for non-root)
            $parent =& $this->_nodes[$parent_oid];
            if ( ! is_array($parent)) {
                $__ret = false;

                return $__ret;
            }

            if ( ! $force) {
                if (array_key_exists(GRN_ORG_TREE_CHILDREN, $parent)
                    && array_key_exists(GRN_ORG_TREE_COUNT, $parent)
                ) {
                    if (count($parent[GRN_ORG_TREE_CHILDREN])
                        == $parent[GRN_ORG_TREE_COUNT]
                    ) {
                        return;
                    }
                }
            }

            // 循環参照を防ぐ
            unset($this->_nodes[$parent_oid]);

            $parent[GRN_ORG_TREE_CHILDREN] = [];
        }

        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        if ( ! is_null($parent_oid)) {
            $parent_oid_keys = [$parent_oid => $parent_oid];
            $parent_counts = $fsl->countAncestors($parent_oid_keys);
            $parent_counts = $parent_counts[$parent_oid];
        } else {
            $parent_counts = 0;
        }
        $children_count = $fsl->countTreeChildrenLength($this->getFAGID());
        if ($parent_counts + $children_count
            < GRN_SCHD_MAX_FACILITY_GROUP_TREE
        ) {
            $status = GRN_FACILITY_TREE_STATUS_NORMAL;
        } else {
            $status = GRN_FACILITY_TREE_STATUS_GRAY;
        }

        $child_rows = $this->_getChildren($parent_oid);

        foreach (array_keys($child_rows) as $id) {
            $oid = $child_rows[$id]['_id'];

            $children[$oid] = [
                GRN_ORG_TREE_OID              => $oid,
                GRN_ORG_TREE_NAME             => $child_rows[$id]['col_name'],
                GRN_ORG_TREE_PARENT           => $parent_oid,
                GRN_ORG_TREE_EXPANDED         => 0,
                GRN_FACILITY_TREE_STATUS_TYPE => $status
            ];
            if ($oid == $this->getFAGID()) {
                $children[$oid][GRN_FACILITY_TREE_STATUS_TYPE]
                    = GRN_FACILITY_TREE_STATUS_SELF;
            }
            $child_count = $this->_getChildCount($oid);
            $children[$oid][GRN_ORG_TREE_COUNT] = $child_count;
            $children[$oid][GRN_ORG_TREE_CHILDREN] = [];

            $node =& $this->_nodes[$oid];
            $this->_nodes[$oid] =& $children[$oid];
            if (is_array($node)) {
                if ($child_count > 0 && $node[GRN_ORG_TREE_EXPANDED] == 1) {
                    // recursive rebuild
                    $this->_buildChild($oid, $expanded, $force);
                }
            }
        }
        if ($parent_oid) {
            $parent[GRN_ORG_TREE_CHILDREN] =& $children;
            //$parent[ GRN_ORG_TREE_COUNT ] = count( $children );
            $parent[GRN_ORG_TREE_EXPANDED] = $expanded ? 1 : 0;
            $this->_nodes[$parent_oid] =& $parent;
        } else {
            $this->_tree =& $children;
        }

        return $children;
    }

    /**
     * To get ancestors of a node
     * The return value of this method provides data for expandTo() method to expand the tree to selected node
     *
     * @param int $oid
     *
     * @return  array associated array
     */
    function _getAncestors($oid)
    {
        if ($oid < 1) {
            return null;
        }

        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        $parents = $fsl->getAncestors([$oid => 1]);
        $parents = array_reverse($parents[$oid]);

        if (is_null($parents)) {
            return null;
        }

        // If a user can access to $oid, then he/she can also access to the ancestors
        // Therefore we return all ancestors
        $ret = [];
        foreach ($parents as $pid) {
            $ret[$pid] = $pid;
        }

        return $ret;
    }
}

/**
 * This function creates data for json_encode.
 * The json is almost same as a json which is created by schedule/facility_json.tpl.
 * The different point is that schedule/facility_json.tpl creates invalid JSON data.
 *
 * @param array $children
 *
 * @return array
 */
function create_facility_move_tree_json_data(array $children)
{
    $list = [];
    foreach ($children as $child) {
        $data = [
            'oid'      => (string)$child['oid'],
            'name'     => htmlspecialchars($child['name'], ENT_QUOTES),
            'expanded' => (string)$child['expanded'],
            'count'    => (string)$child['count'],
        ];

        $data['status'] = (string)cb_at($child, 'status', '');

        if ($child['count'] > 0 && count($child['children']) > 0) {
            $data['children']
                = create_facility_move_tree_json_data($child['children']);
        } else {
            $data['children'] = [];
        }
        $list[] = $data;
    }

    return $list;
}

function facility_move_tree_json($oid, $action, $page, $class_name)
{
    if (strcasecmp(@ $_SERVER['REQUEST_METHOD'], 'POST') != 0) {
        cb_safe_exit();
    } // for javascript hijacking

    global $G_state_set;
    $G_state_set->set('copyright_should_be_written', false);
    $G_state_set->set('html_should_be_closed', false);

    require_once('grn/org_tree.csp');

    $oid = $oid;
    $action = $action;
    $page_name = $page;
    $class_name = $class_name;

    $util = GRN_OrgTreeUtil::getInstance();
    $tree =& $util->getTree($page_name, @$class_name, @$params);

    $children = [];
    if ($tree && is_numeric($oid)) {
        switch ($action) {
            case 'getchild':
                $tree->expandToAndDisplayChild($oid);
                $children = @$tree->_nodes[$oid]['children'];
                if ( ! $children || count($children) == 0) {
                    $children = [];
                }
                break;
            case 'expand':
                $tree->expand($oid);
                break;
            case 'collapse':
                $tree->collapse($oid);
                break;
        }
        $util->setTree($page_name, $tree);
    }

    $data_for_json = create_facility_move_tree_json_data($children);

    $json = JSONResponse::create();
    $json->response(
        $data_for_json, true, JSONResponse::JSON_HEADER,
        JSONResponse::ENCODE_OPTION & ~JSON_FORCE_OBJECT
    );
}

function grn_schedule_rebuild_facility_group_tree_system(
    $page_name,
    $class_name,
    $expanded_fagid = null,
    $params = null
) {
    $util = GRN_OrgTreeUtil::getInstance();
    $tree = $util->getTree($page_name, $class_name, $params);
    if ($tree->containNode($expanded_fagid)) {
        return;
    }
    $tree->rebuild();

    require_once('schedule/facility_system_logic.csp');
    $fsl = GRN_Facility_SystemLogic::getInstance();

    if ( ! is_null($expanded_fagid)) {
        $ancestors = $fsl->getAncestors([$expanded_fagid => $expanded_fagid]);
        $ancestors[$expanded_fagid][] = null;
        $ancestors
            = array_reverse($ancestors[$expanded_fagid]);
    } else {
        $ancestors = [null];
    }

    foreach ($ancestors as $ancestor) {
        $tree->buildChild($ancestor);
    }
    $util->setTree($page_name, $tree);
}

function grn_schedule_rebuild_facility_group_tree_operation(
    $page_name,
    $class_name,
    $expanded_fagid = null
) {
    $util = GRN_OrgTreeUtil::getInstance();
    $tree = $util->getTree($page_name, $class_name);
    if ($tree->containNode($expanded_fagid)) {
        return;
    }
    $tree->rebuild();

    require_once('schedule/facility_system_logic.csp');
    $fsl = GRN_Facility_SystemLogic::getInstance();

    require_once('schedule/facility_privilege.csp');
    $priv = GRN_Facility_Privilege_Logic::getInstance();

    global $G_container_base;
    $uum = $G_container_base->getInstance('uum');
    $login = $uum->getLoginUser();

    if ( ! is_null($expanded_fagid)) {
        $ancestors = $fsl->getAncestors([$expanded_fagid => $expanded_fagid]);
        $ancestors = array_reverse($ancestors[$expanded_fagid]);
        $auth_fgroups = $priv->getFacilityGroupWithAuthority($login);
        $auth_fgroups_ids = [];
        foreach ($auth_fgroups as $auth_fgroup) {
            $auth_fgroups_ids[] = $auth_fgroup->getOID();
        }

        foreach ($ancestors as $id) {
            if (array_search($id, $auth_fgroups_ids) !== false) {
                break;
            } else {
                array_shift($ancestors);
            }
        }
        array_unshift($ancestors, null);
    } else {
        $ancestors = [null];
    }


    foreach ($ancestors as $a) {
        $tree->buildChild($a);
    }
    $util->setTree($page_name, $tree);
}
