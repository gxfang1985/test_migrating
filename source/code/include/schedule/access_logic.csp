<?php
/**
 *
 * @author      A.Shima     2004/12/21
 * @package     grn.schedule
 */

/**
 * @author vuminh@Cybozu 2009/06/10
 * Create a new structure cache to store data
 */

require_once('schedule/resources.csp');
require_once('schedule/error_code.csp');
require_once('grn/application.csp');

require_once('grn/org_tree.csp');

class GRN_Schedule_Access_Logic
{
    private function __construct()
    {
        $this->_deny_users_list = [];
        $this->_deny_roles_list = [];
        $this->_deny_groups_list = [];
        $this->_deny_facilities_list = [];
        $this->_deny_facility_groups_list = [];
        $this->_permit_users_list = [];
        $this->_permit_roles_list = [];
        $this->_permit_groups_list = [];
        $this->_permit_facilities_list = [];
        $this->_permit_facility_groups_list = [];
        $this->_evaluate_users_list = [];
        $this->_evaluate_groups_list = [];
        $this->_evaluate_roles_list = [];
        $this->_evaluate_facilities_list = [];
        $this->_evaluate_facility_groups_list = [];

        $this->_have_setting_user_list = [];
        $this->_have_setting_group_list = [];
        $this->_have_setting_role_list = [];
        $this->_have_setting_facility_list = [];
        $this->_have_setting_facilitygroup_list = [];

        $this->_facility_group_hierarchy = [];
        // Add by vuminh
        $this->_cache = [];
    }

    private $_cache_option = true;

    /**
     * Store a ($key, $value) to cache, return true if success
     */
    function save_to_cache($key, $value)
    {
        $this->_cache[$key] = $value;

        return true;
    }

    /**
     * Get a value by a $key, return null if error)
     */
    function get_from_cache($key)
    {
        if (array_key_exists($key, $this->_cache) === true) {
            return $this->_cache[$key];
        }

        return null;
    }

    /**
     * Should call this function to reset cache data whenever we commit change to the database
     */
    function reset_cache()
    {
        unset($this->_cache);
        $this->_cache = [];
    }

    private static $_instance = null;

    /**
     * @return GRN_Schedule_Access_Logic
     */
    public static function getInstance()
    {
        if ( ! isset(self::$_instance)) {
            $c = __CLASS__;
            self::$_instance = new $c;
        }

        return self::$_instance;
    }

    /**
     * アクセス権がかかるもの
     *
     * @access private
     */
    private $_target_tables
        = [
            GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE => null,
            GRN_SCHD_TARGET_TYPE_STATIC_ROLE  => 'cb_role',
            GRN_SCHD_TARGET_TYPE_GROUP        => 'cb_group',
            GRN_SCHD_TARGET_TYPE_USER         => 'cb_user',
        ];

    /**
     * アクセス権の種類
     *
     * @access private
     */
    private $_access_type
        = [
            'read',
            'add',
            'modify',
            'delete',
        ];

    /**
     * @access private
     */
    private $_user_securitymodels = null;
    /**
     * @access private
     */
    private $_group_securitymodels = null;
    /**
     * @access private
     */
    private $_facility_securitymodels = null;
    /**
     * @access private
     */
    private $_role_securitymodels = null;
    /**
     * @access private
     */
    private $_facilitygroup_securitymodels = null;
    /**
     * @access private
     */
    private $_deny_users_list = null;
    /**
     * @access private
     */
    private $_deny_groups_list = null;
    /**
     * @access private
     */
    private $_deny_roles_list = null;
    /**
     * @access private
     */
    private $_deny_facilities_list = null;
    /**
     * @access private
     */
    private $_deny_facility_groups_list = null;

    /**
     * @access private
     */
    private $_permit_users_list = null;
    /**
     * @access private
     */
    private $_permit_groups_list = null;
    /**
     * @access private
     */
    private $_permit_roles_list = null;
    /**
     * @access private
     */
    private $_permit_facilities_list = null;
    /**
     * @access private
     */
    private $_permit_facility_groups_list = null;

    /**
     * @access private
     */
    private $_evaluate_users_list = null;
    /**
     * @access private
     */
    private $_evaluate_groups_list = null;
    /**
     * @access private
     */
    private $_evaluate_roles_list = null;
    /**
     * @access private
     */
    private $_evaluate_facilities_list = null;
    /**
     * @access private
     */
    private $_evaluate_facility_groups_list = null;

    /**
     * @access private
     */
    private $_user_groups = null;
    /**
     * @access private
     */
    private $_user_roles = null;

    /**
     * @access private
     */
    private $_have_setting_user_list = null;
    /**
     * @access private
     */
    private $_have_setting_group_list = null;
    /**
     * @access private
     */
    private $_have_setting_role_list = null;
    /**
     * @access private
     */
    private $_have_setting_facility_list = null;
    /**
     * @access private
     */
    private $_have_setting_facilitygroup_list = null;
    private $_db = null;

    private $_facility_group_hierarchy = null;
    // Add by vuminh
    private $_cache = null;
    private $_user_dynamic_roles = null;
    private $_prev_uid = null;

    const SUFFIX_FOR_LAX_AUTHORITY_TYPE = '_lax';

    /**
     * @access private
     */
    function _getDBConnection()
    {
        // 初期化されいなければ初期化
        if (is_null($this->_db)) {
            $app_locator = GRN_ApplicationLocator::instance();
            $this->_db = $app_locator->getConnection('schedule');
        }

        return $this->_db;
    }

    /**
     * @access private
     */
    function _initilize($user)
    {
        // 初期化済みの場合
        if ( ! is_null($this->_user_groups)) {
            return;
        }

        $cur_uid = $user->getOID();

        // Skip initialize if the current user is the same user as inprevious initializing
        if ( ! is_null($this->_prev_uid) && $this->_prev_uid === $cur_uid) {
            return;
        }

        $this->_prev_uid = $cur_uid;

        global $G_container_base;
        $uum = $G_container_base->getInstance('uum');
        // CB_Userからuidを取得しているので、第2引数にTRUEを渡して削除フラグチェックを行わないようにする
        $this->_user_groups = $uum->getUserGroupsInfo($cur_uid, true);
        $this->_user_roles = $uum->getUserRolesInfo($cur_uid, true);
        $this->_user_dynamic_roles = $uum->listGrantedRoles();
    }

    /**
     * アクセス権の種類を取得する
     */
    function getAccessType()
    {
        return $this->_access_type;
    }

    /**
     * テーブル情報を取得する
     *
     * @param string $table_name テーブル名
     *
     * @return CB_TableInfo
     * @access private
     */
    function _getTableInfo($table_name)
    {
        $app_locator = GRN_ApplicationLocator::instance();
        $table_manager = $app_locator->getTableManager('schedule');
        $table_info = $table_manager->getTableInfo($table_name);

        return $table_info;
    }

    /**
     * 権限名の一覧を取得する
     *
     * @param \CB_TableInfo $table_info テーブル情報オブジェクト
     *
     * @return array
     * @access private
     */
    function _getAuthorityNames($table_info)
    {
        $column_infos = $table_info->getColumnInfo();
        $column_names = [];

        foreach (array_keys($column_infos) as $column_name) {
            if (false !== strpos($column_name, 'authority_')) {
                $column_names[] = mb_substr($column_name, 10);
            }
        }

        return $column_names;
    }

    /**
     * テーブル名を取得する
     *
     * @param mixed $object
     * @param mixed $target
     * @param       $is_force boolean
     *
     * @return string
     * @access private
     */
    function _getTableName(& $object, & $target, $is_force = false)
    {
        if (is_object($object)) {
            $object_id = strtolower(get_class($object));
            $index = mb_strrpos($object_id, '_') + 1;
            $object_id = 'schedule_access_' . mb_substr($object_id, $index);
        } elseif (is_string($object)) {
            $object_id = $object;
        } else {
            assert('FALSE');
        }

        if ($is_force) {
            $target_id = $target;
        } elseif (is_object($target)) {
            if (is_a($target, 'cb_role')) {
                $target_id = GRN_SCHD_TARGET_TYPE_STATIC_ROLE;
            } else {
                $target_id = strtolower(get_class($target));
                $index = mb_strrpos(strtolower(get_class($target)), '_')
                         + 1;
                $target_id = mb_substr($target_id, $index);
            }
        } elseif (is_string($target)) {
            $target_id = GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE;
        } else {
            assert('FALSE');
        }

        return 'grn_' . $object_id . '_' . $target_id;
    }

    /**
     * アクセス権テーブルを生成する
     *
     * @param   array                    $table_data 下記をキーに持つ連想配列
     *                                               to_table string  アクセス制御するオブジェクトのクラス名
     *                                               object   string  オブジェクト
     *                                               authority array  権限名の配列
     * @param CB_DatabaseConnection|null $dbconn_alt
     */
    function createAccessTable($table_data, $dbconn_alt = null)
    {
        if ( ! is_array($table_data)) {
            assert('FALSE');
        }

        $target_tables =& $this->_target_tables;

        $table_prefix = mb_substr($table_data['to_table'], 4);

        $dbconn_tmp = null;

        foreach ($target_tables as $target_id => $target_table) {
            $table_name = $this->_getTableName($table_prefix, $target_id, true);

            $table_info =& $this->_getTableInfo($table_name);
            if ($dbconn_alt) {
                $dbconn_tmp = $table_info->getDBConnection();
                $table_info->_table_manager->_dbconn = $dbconn_alt;
            }
            $table_info->addColumn('object',
                ['type' => 'relation', 'to' => $table_data['object']]);
            if (is_null($target_table)) {
                $table_info->addColumn('target',
                    ['type' => 'char', 'length' => 100]);
            } else {
                $table_info->addColumn('target',
                    ['type' => 'relation', 'to' => $target_table]);
            }
            $authorities =& $table_data['authority'];
            foreach ($authorities as $authority) {
                $table_info->addColumn('authority_' . $authority,
                    ['type' => 'int']);
            }
            $table_info->addIndex('access',
                ['cols' => ['object', 'target'], 'unique' => true]);
            $table_info->createTable();
            if ($dbconn_tmp) {
                $table_info->_table_manager->_dbconn = $dbconn_tmp;
            }
        }
    }


    /**
     * アクセス権テーブルを削除する
     *
     * @param   array                    $table_data 下記をキーに持つ連想配列
     *                                               to_table string  アクセス制御するオブジェクトのクラス名
     *                                               authority array  権限名の配列
     * @param CB_DatabaseConnection|null $dbconn_alt
     */
    function dropAccessTable($table_data, $dbconn_alt = null)
    {
        if ( ! is_array($table_data)) {
            assert('FALSE');
        }

        $target_tables =& $this->_target_tables;

        $object_id = mb_substr($table_data['to_table'], 4);

        $dbconn_tmp = null;

        foreach ($target_tables as $target_id => $target_table) {
            $table_name = $this->_getTableName($object_id, $target_id, true);
            $table_info =& $this->_getTableInfo($table_name);
            if ($dbconn_alt) {
                $dbconn_tmp = $table_info->getDBConnection();
                $table_info->_table_manager->_dbconn = $dbconn_alt;
            }
            $table_info->dropTable();
            if ($dbconn_tmp) {
                $table_info->_table_manager->_dbconn = $dbconn_tmp;
            }
        }
    }

    /**
     * アクセス権テーブル行を取得する
     *
     * @param   mixed $object
     * @param   mixed $target
     *
     * @return  object GRN_Access_Base
     * @access  private
     */
    function _getRow(& $object, & $target)
    {
        $table_name = $this->_getTableName($object, $target);
        $table_info =& $this->_getTableInfo($table_name);
        if ( ! $table_info->exists()) {
            {
                $___ret = null;

                return $___ret;
            }
        }

        $rowset = new CB_RowSet($table_info);

        $query = $rowset->queryf("col_object = '@S' AND col_target = ",
            $object->getOID());

        if (is_object($target)) {
            $query .= $rowset->queryf("'@S'", $target->getOID());
        } elseif (is_string($target)) {
            // $target が文字列で渡された場合のみ、targetの削除フラグチェックを行う必要がある。
            // $object 及び $target がオブジェクトで渡ってきた場合は、削除フラグチェックを行う必要がない。
            if (strcasecmp('user', $target) == 0) {
                $user_table =& $this->_getTableInfo('CB_User');
                $table_name = CB_DATABASE_TABLE_PREFIX .
                              $this->_getTableName($object, $target, $is_force);
                $on = $table_name
                      . '.col_target = tu._id AND tu.col_deleted IS NULL';
                $rowset->addJoin($user_table, $on, CB_DATABASE_INNER_JOIN,
                    'tu');
            }
            $query .= $rowset->queryf("'@S'", $target);
        } else {
            assert('FALSE');
        }

        $rowset->addCondition($query);
        $row = $rowset->iterate();
        $rowset->destroy();

        return $row;
    }

    /**
     * @access private
     */

    function _getTarget($target_type, $target_id)
    {
        global $G_container_base;
        $uum = $G_container_base->getInstance('uum');

        // ターゲットを取得する
        switch ($target_type) {
            case GRN_SCHD_TARGET_TYPE_USER:
                $target = $uum->getUser($target_id);
                break;
            case GRN_SCHD_TARGET_TYPE_GROUP:
                $target = $uum->getGroup($target_id);
                break;
            case GRN_SCHD_TARGET_TYPE_STATIC_ROLE:
                $target = $uum->getStaticRole($target_id);
                break;
            case GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE:
                $target = $target_id;
                break;
            default:
                assert('FALSE');
        }

        return $target;
    }

    /**
     * アクセス権を設定する
     *
     * @param   mixed  $object      アクセス制御するオブジェクトID
     * @param   string $target_type アクセス制御するターゲットの種類
     * @param   string $target_id   アクセス制御するターゲットID
     * @param   array  $authorities キーに権限名、値に権限値を持つ連想配列
     */
    function setAccess(& $object, $target_type, $target_id, $authorities)
    {
        if (is_null($object) || ! is_object($object)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_OBJECT);
        }

        if (is_null($target_type) || 0 == strlen($target_type)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_TARGET_TYPE);
        }

        if (is_null($target_id) || 0 == strlen($target_id)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_TARGET_ID);
        }

        if (is_null($authorities)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_AUTHORITY_NOT_FOUND);
        }


        // オブジェクトテーブル行を取得する
        $target =& $this->_getTarget($target_type, $target_id);
        $table_name = $this->_getTableName($object, $target);

        $table_info =& $this->_getTableInfo($table_name);
        if ( ! $table_info->exists()) {
            return;
        }

        $row = $this->_getRow($object, $target);
        // まだ追加されていない場合は新規に追加
        if ( ! $row) {
            $row = $table_info->newRow();
        }
        $row->set('object', $object);
        $row->set('target', $target);
        foreach ($authorities as $key => $value) {
            $row->set('authority_' . $key, intval($value));
        }
        $row->registerNow();
    }

    /**
     * アクセス権を削除する
     *
     * @param mixed  $object アクセス制御するオブジェクト
     * @param string $target_type
     * @param string $target_id
     *
     * @return boolean  TRUEのときは正常終了、FALSEのときは失敗
     */
    function deleteAccess(& $object, $target_type, $target_id)
    {
        if (is_null($object) || ! is_object($object)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_OBJECT);
        }

        if (is_null($target_type) || 0 == strlen($target_type)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_TARGET_TYPE);
        }

        if (is_null($target_id) || 0 == strlen($target_id)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_TARGET_ID);
        }

        // オブジェクトテーブル行を取得する
        $target = $this->_getTarget($target_type, $target_id);

        $row = $this->_getRow($object, $target);
        if ( ! is_null($row)) {
            $row->delete();

            return true;
        }

        return false;
    }

    /**
     * アクセス権情報を取得する
     *
     * @access private
     */
    function _getAccess(& $row, $object_id)
    {
        $target = $row->get('target');
        $target_type = gettype($target);

        $access = [];
        if ('object' == $target_type) {
            if (is_a($target, 'cb_user')) {
                $access['tid'] = $target->getOID();
                $access['type'] = GRN_SCHD_TARGET_TYPE_USER;
                $access['target_name'] = $target->get('display_name');;
            } elseif (is_a($target, 'cb_group')) {
                global $G_container_base;
                $uum = $G_container_base->getInstance('uum');
                $groupObj = $uum->getGroup($target->getOID());

                $access['tid'] = $target->getOID();
                $access['type'] = GRN_SCHD_TARGET_TYPE_GROUP;
                $access['target_name'] = $groupObj->get('name');
            } elseif (is_a($target, 'cb_role')) {
                $access['tid'] = $target->getOID();
                $access['type'] = GRN_SCHD_TARGET_TYPE_STATIC_ROLE;
                $access['target_name'] = $target->get('foreign_key');
            }
        } elseif ('string' == $target_type) {
            require_once('grn/uum_util.csp');
            $uum_util = GRN_UumUtil::getInstance();
            $dynamic_roles = $uum_util->listDynamicRoles();
            $access['tid'] = $target;
            $access['type'] = GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE;
            $access['target_name'] = $dynamic_roles[$target]['name'];
        } else {
            assert('FALSE');
        }
        $access['id'] = $row->getOID();
        $access['oid'] = $object_id;

        $access['data'] = [];
        $table_info = $row->getTableInfo();
        $authorities = $this->_getAuthorityNames($table_info);
        foreach ($authorities as $authority) {
            $access['data'][$authority] = $row->get('authority_' . $authority);
        }

        return $access;
    }

    /**
     * アクセス権情報を取得する
     *
     * @param   mixed  $object      アクセス制御するオブジェクト
     * @param   string $target_type アクセス制御するターゲットの種類
     * @param   string $target_id   アクセス制御するターゲットID
     *
     * @return  mixed
     */
    function getAccess(& $object, $target_type, $target_id)
    {
        if (is_null($object) || ! is_object($object)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_OBJECT);
        }

        $target = $this->_getTarget($target_type, $target_id);

        $row = $this->_getRow($object, $target);

        $access = null;
        if ( ! is_null($row)) {
            $access = $this->_getAccess($row, $object->getOID());
        }

        return $access;
    }

    /**
     * アクセス権テーブル行の集合の一覧を取得する
     *
     * @access private
     */
    function _getRowSetList(& $object)
    {
        $target_tables =& $this->_target_tables;

        $object_id = strtolower(get_class($object));
        $index = mb_strrpos($object_id, '_') + 1;
        $object_id = 'schedule_access_' . mb_substr($object_id, $index);

        $rowset_list = [];
        foreach ($target_tables as $target_id => $target_table) {
            $table_name = $this->_getTableName($object_id, $target_id, true);
            $table_info =& $this->_getTableInfo($table_name);
            if ( ! $table_info->exists()) {
                continue;
            }
            $rowset = new CB_RowSet($table_info);

            // object はオブジェクトからidを取得しているので、削除フラグチェックを行う必要がない。
            // target のみ削除フラグチェックを行う。
            if (strcasecmp('user', $target_id) == 0) {
                $user_table =& $this->_getTableInfo('CB_User');
                $on = 'tab_' . $table_name
                      . '.col_target = tu._id AND tu.col_deleted IS NULL';
                $rowset->addJoin($user_table, $on, CB_DATABASE_INNER_JOIN,
                    'tu');
            }

            $query = $rowset->queryf("col_object = '@S'", $object->getOID());

            $rowset->addCondition($query);
            $rowset_list[$target_id] = $rowset;
            unset($rowset);
        }

        return $rowset_list;
    }

    /**
     * アクセス権情報の一覧を取得する
     *
     * @param   mixed $object      アクセス制御するオブジェクト
     * @param   array $access_keys アクセス権キーの一覧
     *                             アクセス権キーは下記の通り
     *                             {アクセス制御するターゲットの種類}.':'.{アクセス権ID}を持つ配列
     *
     * @return array  下記をキーに持つ連想配列
     *  id int  アクセス権ID
     *  oid int  アクセス制御するオブジェクトID
     *  tid mixed  アクセス制御するターゲットID
     *  type string  アクセス制御するターゲットの種類
     *  data int  権限の値
     */
    function getAccesses($object, $access_keys = null)
    {
        if (is_null($object) || ! is_object($object)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_OBJECT);
        }

        // アクセス権テーブル行の集合の一覧を取得する
        $rowset_list = $this->_getRowSetList($object);

        $object_id = $object->getOID();

        // アクセス権の一覧を生成する
        $accesses = [];
        foreach (array_keys($rowset_list) as $list_id) {
            $rowset = $rowset_list[$list_id];
            while ( ! is_null($row = $rowset->iterate())) {
                $accesses[] = $this->_getAccess($row, $object_id);
            }
        }

        if ( ! is_null($access_keys)) {
            foreach (array_keys($accesses) as $key) {
                $access =& $accesses[$key];
                if (false === array_search($access['type'] . ':'
                                           . $access['id'], $access_keys)
                ) {
                    unset($accesses[$key]);
                }
            }
        }

        return $accesses;
    }

    /**
     * アクセス権の一覧を削除する
     *
     * @param   mixed $object   アクセス制御するオブジェクト
     * @param   array $accesses 下記をキーに持つ連想配列を持つ配列
     *                          id int  アクセス権ID
     *                          type string  アクセス制御するターゲットの種類
     */
    function deleteAccesses($object, $accesses)
    {
        if (is_null($object) || ! is_object($object)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_OBJECT);
        }

        if ( ! is_array($accesses)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INFOMATION_NOT_FOUND);
        }

        if (0 == count($accesses)) {
            return;
        }

        // アクセス権のデータ構造を変換する
        $accesses_list = [];
        foreach ($accesses as $access) {
            if ( ! is_array($access) || 0 == count($access)) {
                cb_throw_error(E_GRN_SCHD_ACCESS_INFORMATION_NOT_FOUND);
            }

            $target_type = $access['type'];
            $access_id = $access['id'];

            if ( ! array_key_exists($target_type, $accesses_list)) {
                $accesses_list[$target_type] = [];
            }
            $accesses_list[$target_type][] = $access_id;
        }

        $target_tables =& $this->_target_tables;

        $object_id = strtolower(get_class($object));
        $index = mb_strrpos($object_id, '_') + 1;
        $object_id = 'schedule_access_' . mb_substr($object_id, $index);

        $rowset_list = [];
        foreach (array_keys($accesses_list) as $target_type) {
            $table_name = $this->_getTableName($object_id, $target_type, true);
            $table_info =& $this->_getTableInfo($table_name);
            if ( ! $table_info->exists()) {
                continue;
            }

            $query = '';
            $rowset = new CB_RowSet($table_info);
            foreach ($accesses_list[$target_type] as $access_id) {
                $query .= $rowset->queryf("_id = '@S' OR ", $access_id);
            }
            $query = mb_substr($query, 0, -4);

            $rowset->addCondition($query);
            $rowset->deleteAllMatched();
        }
    }


    /**
     * @access private
     */
    function _getSecurityModelTable()
    {
        require_once('schedule/table.csp');
        $app_locator = GRN_ApplicationLocator::instance();
        $tm = $app_locator->getTableManager('schedule');

        $security_model_table = $tm->getTableInfo(GRN_SCHEDULE_SECURITYMODEL);

        return $security_model_table;
    }

    /**
     * @access private
     */
    function _getSecurityModelRow(& $object)
    {
        $table = $this->_getSecurityModelTable();
        $rowset = new CB_RowSet($table);
        if (is_a($object, 'CB_User')) {
            // オブジェクトからidを取得しているので、削除フラグチェックは行わない。
            $rowset->addCondition("col_user = " . $rowset->queryf("'@S'",
                    $object->getOID()));
        } elseif (is_a($object, 'CB_Group')) {
            $rowset->addCondition("col_group = " . $rowset->queryf("'@S'",
                    $object->getOID()));
        } elseif (is_a($object, 'CB_Role')) {
            $rowset->addCondition("col_role = " . $rowset->queryf("'@S'",
                    $object->getOID()));
        } elseif (is_a($object, 'GRN_Facility_Facility')) {
            $rowset->addCondition("col_facility = " . $rowset->queryf("'@S'",
                    $object->getOID()));
        } elseif (is_a($object, 'GRN_Facility_FacilityGroup')) {
            $rowset->addCondition("col_facilitygroup = "
                                  . $rowset->queryf("'@S'", $object->getOID()));
        }
        $row = $rowset->iterate();
        $rowset->destroy();

        return $row;
    }

    /**
     * @access private
     */
    function _getSecurityModel(& $object)
    {
        if (is_a($object, 'CB_User')) {
            return $this->_getSecurityModelById($object->getOID(), 'user');
        } elseif (is_a($object, 'CB_Group')) {
            return $this->_getSecurityModelById($object->getOID(), 'group');
        } elseif (is_a($object, 'CB_Role')) {
            return $this->_getSecurityModelById($object->getOID(), 'role');
        } elseif (is_a($object, 'GRN_Facility_Facility')) {
            return $this->_getSecurityModelById($object->getOID(), 'facility');
        } elseif (is_a($object, 'GRN_Facility_FacilityGroup')) {
            return $this->_getSecurityModelById($object->getOID(),
                'facilitygroup');
        }

        return false;
    }

    /**
     * スケジュールのデフォルトのセキュリティモデルを取得する
     */
    function _getDefaultSecurityModel()
    {
        static $schedule_default_mode = null;

        if (is_null($schedule_default_mode)) {
            global $G_container_app;
            $policy = $G_container_app->getInstance('common_policy');

            require_once('schedule/application.csp');
            $app = GRN_Schedule_Application::getInstance();
            if ('revoke' == $policy->getPolicy($app->getApplicationId(),
                    'security_model')
            ) {
                $schedule_default_mode = GRN_SCHD_SECURITY_MODEL_TYPE_REVOKE;
            } else {
                $schedule_default_mode = GRN_SCHD_SECURITY_MODEL_TYPE_GRANT;
            }
        }

        return $schedule_default_mode;
    }

    /**
     * セキュリティ・モデルを取得する
     *
     * @param   mixed $object アクセス制御するオブジェクト
     *
     * @return  string      セキュリティモデル
     */
    function getSecurityModel($object)
    {
        if (is_null($object) || ! is_object($object)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_OBJECT);
        }

        $security_model = $this->_getSecurityModel($object);

        return (GRN_SCHD_SECURITY_MODEL_TYPE_REVOKE == $security_model)
            ? 'revoke' : 'grant';
    }

    /**
     * セキュリティ・モデルを変更する
     * アクセス権はすべて削除する
     *
     * @param   mixed  $object         アクセス制御するオブジェクト
     * @param   string $security_model セキュリティ・モデル
     */
    function setSecurityModel($object, $security_model)
    {
        if (is_null($object) || ! is_object($object)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_OBJECT);
        }

        if ( ! is_string($security_model) || 0 == strlen($security_model)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_SECURITY_MODEL);
        }

        $old_security_model = $this->getSecurityModel($object);
        if ($old_security_model != $security_model) {
            // まだ登録されていない
            $model_row = $this->_getSecurityModelRow($object);
            if (is_null($model_row)) {
                $table = $this->_getSecurityModelTable();
                $model_row = $table->newRow();
                $target = '';
                if (is_a($object, 'CB_User')) {
                    $target = 'user';
                } elseif (is_a($object, 'CB_Group')) {
                    $target = 'group';
                } elseif (is_a($object, 'CB_Role')) {
                    $target = 'role';
                } elseif (is_a($object, 'GRN_Facility_Facility')) {
                    $target = 'facility';
                } elseif (is_a($object, 'GRN_Facility_FacilityGroup')) {
                    $target = 'facilitygroup';
                }
                $model_row->set($target, $object);
            }

            if ('grant' == $security_model) {
                $security_model = GRN_SCHD_SECURITY_MODEL_TYPE_GRANT;
            } elseif ('revoke' == $security_model) {
                $security_model = GRN_SCHD_SECURITY_MODEL_TYPE_REVOKE;
            } else {
                cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_SECURITY_MODEL);
            }

            $model_row->set('security_model', intval($security_model));

            // 登録されているアクセス権をすべて取得
            $accesses = $this->getAccesses($object);

            // 現在の設定をすべてクリアする
            $this->deleteAccesses($object, $accesses);

            if (is_a($object, 'CB_User')) {
                $this->_user_securitymodels[$object->getOID()]
                    = $security_model;
            } elseif (is_a($object, 'CB_Group')) {
                $this->_group_securitymodels[$object->getOID()]
                    = $security_model;
            } elseif (is_a($object, 'CB_Role')) {
                $this->_role_securitymodels[$object->getOID()]
                    = $security_model;
            } elseif (is_a($object, 'GRN_Facility_Facility')) {
                $this->_facility_securitymodels[$object->getOID()]
                    = $security_model;
            } elseif (is_a($object, 'GRN_Facility_FacilityGroup')) {
                $this->_facilitygroup_securitymodels[$object->getOID()]
                    = $security_model;
            }
        }
    }

    /**
     * 単体オブジェクトのアクセス権評価値を計算する
     *
     * @access      private
     */
    function _evaluateAccess(
        $user,
        & $object,
        $authorities
    ) {
        $dynamic_roles = $this->_user_dynamic_roles;
        $user_groups = $this->_user_groups;
        $user_roles = $this->_user_roles;

        $user_id = $user->getOID();
        $targets_list = [];

        $db = $this->_getDBConnection();

        // ダイナミックロールを取得する
        if (is_array($dynamic_roles) && count($dynamic_roles) > 0) {
            $target_array = [];
            foreach (array_keys($dynamic_roles) as $key) {
                //$target_array[] = '\''.$key.'\'';
                $target_array[] = cb_queryf($db, "'@S'", $key);
            }
            $targets_list[GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE] = implode(',',
                $target_array);
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE] = null;
        }

        // スタティックロールを取得する
        if (false === $user_roles) {
            return false;
        }
        if (is_array($user_roles) && count($user_roles) > 0) {
            $target_array = [];
            foreach (array_keys($user_roles) as $key) {
                $target_array[] = cb_queryf($db, "'@S'", $key);
            }
            $targets_list[GRN_SCHD_TARGET_TYPE_STATIC_ROLE] = implode(',',
                $target_array);
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_STATIC_ROLE] = null;
        }

        // 組織を取得する
        if (false === $user_groups) {
            return false;
        }
        if (is_array($user_groups) && count($user_groups) > 0) {
            $target_array = [];
            foreach (array_keys($user_groups) as $key) {
                $target_array[] = cb_queryf($db, "'@S'", $key);
            }
            $targets_list[GRN_SCHD_TARGET_TYPE_GROUP] = implode(',',
                $target_array);
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_GROUP] = null;
        }

        $temp_array = [];
        foreach ($authorities as $authority) {
            $temp_array[] = "col_authority_" . $authority . " = '1'";
        }
        $authorities_str = implode(' OR ', $temp_array);

        // ユーザーを取得する
        $targets_list[GRN_SCHD_TARGET_TYPE_USER] = (string)$user_id;

        $object_id = strtolower(get_class($object));
        $index = mb_strrpos($object_id, '_') + 1;
        $object_id = 'schedule_access_' . mb_substr($object_id, $index);

        $target_tables =& $this->_target_tables;

        $values = [];
        foreach ($authorities as $authority) {
            $values[$authority] = 0;
        }

        foreach ($target_tables as $target_id => $target_table) {
            if (is_null($targets_list[$target_id])
                || 0 === count($targets_list[$target_id])
            ) {
                continue;
            }

            $table_name = $this->_getTableName($object_id, $target_id, true);

            // Try to get value from cache
            $cache_success = true;
            $_object_id = $object->getOID();
            foreach ($authorities as $authority) {
                $cache_key = "user!" . $user_id . "_" . $table_name . "!"
                             . $_object_id . "_" . $authority;
                $value = (array_key_exists($cache_key, $this->_cache)
                    ? $this->_cache[$cache_key] : null);
                if (is_null($value)) {
                    $cache_success = false;
                    $this->save_to_cache($cache_key, 0);
                } else {

                    $values[$authority] = max(array_key_exists($authority,
                        $values) ? $values[$authority] : 0, $value);
                }
            }

            if ($cache_success && $this->_cache_option === true) {
                $foo = 1;
                continue;
            }


            // object はオブジェクトからidを取得しているので、削除フラグチェックを行わない
            // $targets_list['user'] もオブジェクトから取得したidしか入らないので、削除フラグチェックを
            // 行う必要はない。
            $query = "SELECT * FROM tab_" . $table_name
                     . " WHERE ( ( col_object = ";
            $query .= cb_queryf($db, "'@S'", $object->getOID());
            $query .= " ) AND ( col_target IN (" . $targets_list[$target_id]
                      . ") ) AND ( " . $authorities_str . " ) )";

            $query = $db->select_format($query);

            $result = $db->query($query);
            if ($result === false) {
                $db->throwError([
                    'query' => 'failed query on SELECT: ' . $query
                ]);
            }

            while ($row = $db->fetch_assoc($result)) {
                $_object_id = $row['col_object'];
                $evalval = 1;
                foreach ($authorities as $authority) {
                    $value = $row['col_authority_' . $authority];
                    $value = is_null($value) ? 0 : intval($value);
                    $values[$authority] = max($values[$authority], $value);
                    $evalval = $evalval & $values[$authority];

                    $cache_key = "user!" . $user_id . "_" . $table_name . "!"
                                 . $_object_id . "_" . $authority;
                    $this->save_to_cache($cache_key, $values[$authority]);
                }
                if (1 === $evalval) {
                    break;
                }
            }

            // 結果の開放
            $db->free_result($result);
        }

        return $values;
    }

    /**
     * アクセス権の評価を行う
     *  $authoritiesで与えられたすべての操作ができるかどうかをチェックする
     *
     * @param   CB_User $user          ユーザー
     * @param   mixed   $object        評価対象
     * @param   array   $authorities   操作
     * @param   array   $dynamic_roles ダイナミックロール
     *
     * @return  mixed   成功した場合は評価したアクセス
     */
    function evaluateAccess($user, & $object, $authorities, $dynamic_roles)
    {
        $this->_initilize($user);

        // ログインユーザーはOK
        if (is_a($object, 'CB_User') && $user->getOID() == $object->getOID()) {
            return true;
        }

        // どういった値がDBに設定されているかを取得
        $list = $this->_evaluateAccess($user, $object, $authorities);

        $return_value = null;
        // ひとつしかない場合
        if (count($authorities) == 1) {
            switch ($this->_getSecurityModel($object)) {
                case GRN_SCHD_SECURITY_MODEL_TYPE_GRANT:
                    $retval_true = true;
                    $retval_false = false;
                    break;
                case GRN_SCHD_SECURITY_MODEL_TYPE_REVOKE:
                    $retval_true = false;
                    $retval_false = true;
                    break;
            }

            if (intval(reset($list)) == 1) {
                $return_value = $retval_true;
            } else {
                $return_value = $retval_false;
            }
        } else {
            $access = 1;
            $old_access = null;
            $b_first = true;
            foreach ($authorities as $authority) {
                $value = array_key_exists($authority, $list) ? $list[$authority]
                    : 0;
                $value = intval($value);
                if ($b_first) {
                    $b_first = false;
                    $access &= $value;
                    $old_access = $value;
                    continue;
                }

                // 値が違っている場合は、どのケースでもアクセスできない
                if ($old_access != $value) {
                    return false;
                }

                $access &= $value;
            }

            switch ($this->_getSecurityModel($object)) {
                case GRN_SCHD_SECURITY_MODEL_TYPE_GRANT:
                    $retval_true = true;
                    $retval_false = false;
                    break;
                case GRN_SCHD_SECURITY_MODEL_TYPE_REVOKE:
                    $retval_true = false;
                    $retval_false = true;
                    break;
            }
            $return_value = $access ? $retval_true : $retval_false;
        }
        if ( ! is_a($object, 'CB_User') || $return_value === false) {
            return $return_value;
        }

        $target_object = [$object->getOID() => $object];
        $have_access_setting = $this->getHaveAccessSettingList($user,
            $target_object, 'user', $dynamic_roles);
        if (is_array($have_access_setting) && count($have_access_setting) > 0) {
            return $return_value;
        }

        $no_group = false;
        $no_roles = false;

        // ユーザーの場合は組織とロールについて判断する
        global $G_container_base;
        $uum = $G_container_base->getInstance('uum');

        // CB_Userからuidを取得しているので、第2引数にTRUEを渡して削除フラグチェックを行わない
        $groups = $uum->getUserGroupsInfo($object->getOID(), true);
        $groups = $this->getHaveAccessSettingList($user, $groups, 'group',
            $dynamic_roles);
        if (count($groups) > 0) {
            $retval = $this->evaluateAccessesById($user, $groups, $authorities,
                $dynamic_roles, 'group');

            if (count($retval) > 0) {
                return true;
            }

        } else {
            $no_group = true;
        }

        // CB_Userからuidを取得しているので、第2引数にTRUEを渡して削除フラグチェックを行わない
        $roles = $uum->getUserRolesInfo($object->getOID(), true);
        $roles = $this->getHaveAccessSettingList($user, $roles, 'role',
            $dynamic_roles);
        if (count($roles) > 0) {
            $retval = $this->evaluateAccessesById($user, $roles, $authorities,
                $dynamic_roles, 'role');

            if (count($retval) > 0) {
                return true;
            }

        } else {
            $no_roles = true;
        }

        if ($no_group && $no_roles) {
            return true;
        }

        return false;
    }

    /**
     * アクセスが許可された複数オブジェクトを取得する
     *
     * @param               $objects
     * @param               $targets_list
     * @param               $object_table
     * @param               $authorities
     * @param               $is_grant
     * @param               $deny_cache_list
     * @param               $permit_cache_list
     * @param   bool        $lax_evaluate Permit: When logged-in user has one right authority at all evaluation authorities that exclude "read".
     *
     * @return array
     */
    function _getAllowSingleObjects(
        $objects,
        $targets_list,
        $object_table,
        $authorities,
        $is_grant,
        &$deny_cache_list,
        &$permit_cache_list,
        $lax_evaluate = false
    ) {
        if (0 === count($objects)) {
            return [];
        }

        $db = $this->_getDBConnection();

        $target_tables =& $this->_target_tables;

        $values_list = [];


        if ($object_table === 'schedule_access_facilitygroup') {
            return $this->_getAllowSingleObjectsFacilityGroup($objects,
                $targets_list, $object_table, $authorities, $deny_cache_list,
                $permit_cache_list, $lax_evaluate);
        } elseif ($object_table === 'schedule_access_facility') {
            return $this->_getAllowSingleObjectsFacility($objects,
                $targets_list, $object_table, $authorities, $deny_cache_list,
                $permit_cache_list, $lax_evaluate);
        } else {
            $objects_str = "";
            foreach (array_keys($objects) as $object) {
                $objects_str .= cb_queryf($db, "'@S',", $object);
            }
            $objects_str = substr($objects_str, 0, strlen($objects_str) - 1);

            $temp_str = [];
            $read_authority_exist = false;
            foreach ($authorities as $authority) {
                $temp_str[] = 'col_authority_' . $authority;
                if ($authority == 'read') {
                    $read_authority_exist = true;
                }
            }
            $authorities_str = implode(' OR ', $temp_str);


            foreach ($target_tables as $target_id => $target_table) {
                if (is_null($targets_list[$target_id])
                    || 0 === count($targets_list[$target_id])
                ) {
                    continue;
                }
                $targets =& $targets_list[$target_id];

                $table_name = $this->_getTableName($object_table, $target_id,
                    true);

                // ユーザー削除フラグを確認
                $join = '';
                if (strcmp($object_table, 'schedule_access_user') == 0) {
                    $join .= ' INNER JOIN tab_cb_user AS ou ON tab_'
                             . $table_name
                             . '.col_object = ou._id AND ou.col_deleted IS NULL';
                }
                if (strcmp($target_id, 'user') == 0) {
                    $join .= ' INNER JOIN tab_cb_user AS tu ON tab_'
                             . $table_name
                             . '.col_target = tu._id AND tu.col_deleted IS NULL';
                }

                $query = 'SELECT * FROM tab_' . $table_name . $join
                         . ' WHERE ( ( col_object IN (' . $objects_str
                         . ') ) AND ( col_target IN ('
                         . $targets_list[$target_id] . ') ) AND ( '
                         . $authorities_str . ' ) )';

                $query = $db->select_format($query);


                $result = $db->query($query);
                if ($result === false) {
                    $db->throwError([
                        'query' => 'failed query on SELECT: ' . $query
                    ]);
                }

                while ($row = $db->fetch_assoc($result)) {
                    $object_id = $row['col_object'];

                    // アクセス権の権限値の一覧を取得する
                    if (array_key_exists($object_id, $values_list)) {
                        $values =& $values_list[$object_id];
                    } else {
                        $values_list[$object_id] = [];
                        $values =& $values_list[$object_id];
                        foreach ($authorities as $authority) {
                            $values[$authority] = 0;
                        }
                    }
                    // アクセス権を評価する
                    foreach ($authorities as $authority) {
                        $value = $row['col_authority_'
                                      . $authority];
                        $value = is_null($value) ? 0
                            : intval($value);
                        $value = max($values[$authority], $value);
                        $values[$authority] = $value;
                    }
                }
                // 結果の開放
                $db->free_result($result);
            }
            $retval = [];
            $authorities_count = count($authorities);
            foreach (array_keys($values_list) as $object_id) {
                $values = &$values_list[$object_id];
                $sum_authorities = array_sum($values);

                if ($authorities_count > 1 && $lax_evaluate) {
                    $lax_grant_permit_condition = (($read_authority_exist
                                                    && $sum_authorities > 1)
                                                   || ( ! $read_authority_exist
                                                        && $sum_authorities
                                                           > 0));
                    if ($is_grant && $lax_grant_permit_condition) {
                        $retval[$object_id] = &$objects[$object_id];
                        $permit_cache_list[$object_id] = $object_id;
                        continue;
                    }

                    $lax_revoke_permit_condition = (($read_authority_exist
                                                     && $values['read'] != 1
                                                     && $sum_authorities
                                                        != ($authorities_count
                                                            - 1))
                                                    || ( ! $read_authority_exist
                                                         && $sum_authorities
                                                            != $authorities_count));
                    if ($lax_revoke_permit_condition) {
                        continue;
                    }
                }

                if ($sum_authorities != 0
                    && $authorities_count != $sum_authorities
                ) {
                    // だめなリストにオブジェクトを追加
                    $deny_cache_list[$object_id] = $object_id;
                    unset($objects[$object_id]);
                    continue;
                }

                if ($is_grant && $sum_authorities != 0) {
                    $retval[$object_id] =& $objects[$object_id];
                    $permit_cache_list[$object_id] = $object_id;
                } else {
                    // だめなリストにオブジェクトを追加
                    $deny_cache_list[$object_id] = $object_id;
                    unset($objects[$object_id]);
                }
            }

            $object_keys = array_keys($objects);
            $value_keys = array_keys($values_list);
            $no_records = array_diff($object_keys, $value_keys);

            if ($is_grant) {
                // GRANTでアクセス権設定の無いものは拒否としてキャッシュ
                foreach ($no_records as $no_record) {
                    $deny_cache_list[$no_record] = $no_record;
                }

                return $retval;
            } else {
                // REVOKEでアクセス権設定の無いものは許可としてキャッシュ
                foreach ($no_records as $no_record) {
                    $permit_cache_list[$no_record] = $no_record;
                }

                return $objects;
            }
        }

    }

    /**
     * アクセスが許可された複数オブジェクトを取得する
     *
     * @param   object CB_User  $user
     * @param   array           $objects
     * @param                   $object_type
     * @param   array           $authorities
     * @param   array           $dynamic_roles
     * @param                   $user_groups
     * @param                   $user_roles
     * @param                   $deny_cache_list
     * @param                   $permit_cache_list
     * @param   bool            $lax_evaluate
     *
     * @return array
     */
    function _getAllowMultiObjects(
        $user,
        $objects,
        $object_type,
        $authorities,
        & $dynamic_roles,
        & $user_groups,
        & $user_roles,
        & $deny_cache_list,
        & $permit_cache_list,
        $lax_evaluate = false
    ) {
        $user_id = $user->getOID();
        $targets_list = [];

        $app_locator = GRN_ApplicationLocator::instance();
        $dbconn = $app_locator->getConnection('schedule');

        // ダイナミックロールを取得する
        if (is_array($dynamic_roles) && count($dynamic_roles) > 0) {
            $target_array = [];
            foreach (array_keys($dynamic_roles) as $key) {
                $target_array[] = '\'' . $dbconn->escape($key) . '\'';
            }
            $targets_list[GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE] = implode(',',
                $target_array);
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE] = null;
        }

        // スタティックロールを取得する
        $targets_list[GRN_SCHD_TARGET_TYPE_STATIC_ROLE] = $user_roles;
        if (false === $user_roles) {
            return false;
        }
        if (is_array($user_roles) && count($user_roles) > 0) {
            $targets_list[GRN_SCHD_TARGET_TYPE_STATIC_ROLE] = implode(',',
                array_keys($user_roles));
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_STATIC_ROLE] = null;
        }

        // 組織を取得する
        $targets_list[GRN_SCHD_TARGET_TYPE_GROUP] = $user_groups;
        if (false === $user_groups) {
            return false;
        }
        if (is_array($user_groups) && count($user_groups) > 0) {
            $targets_list[GRN_SCHD_TARGET_TYPE_GROUP] = implode(',',
                array_keys($user_groups));
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_GROUP] = null;
        }

        // ユーザーを取得する
        $targets_list[GRN_SCHD_TARGET_TYPE_USER] = $user->getOID();

        $alreadys = [];    // 既に評価済み
        $temporary_ids = [];
        $object = null;
        foreach (array_keys($objects) as $object_Id) {
            // だめなもの
            if (array_key_exists($object_Id, $deny_cache_list)) {
                continue;
            }

            // いいもの
            if (array_key_exists($object_Id, $permit_cache_list)) {
                $alreadys[$object_Id] = $object_Id;
                continue;
            }

            $temporary_ids[$object_Id] = $object_Id;
        }

        $grants = [];
        $revokes = [];
        if (count($temporary_ids) > 0) {
            $security_list = $this->_getSecurityModels($temporary_ids,
                $object_type);
            foreach ($security_list as $key => $value) {
                switch ($value) {
                    case GRN_SCHD_SECURITY_MODEL_TYPE_GRANT:
                        $grants[$key] = $key;
                        break;
                    case GRN_SCHD_SECURITY_MODEL_TYPE_REVOKE:
                        $revokes[$key] = $key;
                        break;
                }
            }
        }

        $table_type = 'schedule_access_' . $object_type;

        $grants = $this->_getAllowSingleObjects($grants, $targets_list,
            $table_type, $authorities, true, $deny_cache_list,
            $permit_cache_list, $lax_evaluate);
        $revokes = $this->_getAllowSingleObjects($revokes, $targets_list,
            $table_type, $authorities, false, $deny_cache_list,
            $permit_cache_list, $lax_evaluate);
        $retval = $grants + $revokes;

        $ids_list = array_keys($retval);
        // ここに組織とロールのアクセス権のチェックを追加
        if ($object_type == 'user') {
            global $G_container_base;
            $uum = $G_container_base->getInstance('uum');
            // CB_Userからuidを取得しているので、第2引数にTRUEを渡して削除フラグチェックを行わない
            $groups_list = $uum->getUsersGroupsInfo($ids_list, true);
            $roles_list = $uum->getUsersRolesInfo($ids_list, true);

            $have_access_setting = $this->getHaveAccessSettingList($user,
                $objects, 'user', $dynamic_roles);

            $group_user_map = [];
            $role_user_map = [];
            $authorities_type = implode('_', $authorities);
            if ($lax_evaluate) {
                $authorities_type .= self::SUFFIX_FOR_LAX_AUTHORITY_TYPE;
            }

            foreach ($ids_list as $key) {
                // ユーザーにアクセス権設定があったら最優先
                if (array_key_exists($key, $have_access_setting) === true) {
                    continue;
                }

                $groups = array_key_exists($key, $groups_list)
                    ? $groups_list[$key] : [];

                // アクセス権設定の有無をキャッシュから取得
                $cache_list = null;
                if (array_key_exists($user_id,
                    $this->_have_setting_group_list)
                ) {
                    $cache_list = $this->_have_setting_group_list[$user_id];
                }

                $have_setting_count = 0;
                if ( ! is_null($cache_list)) {
                    foreach (array_keys($groups) as $group_id) {
                        if ( ! array_key_exists($group_id, $cache_list)) {
                            continue;
                        }

                        // アクセス権設定無しでキャッシュされている
                        if ($cache_list[$group_id] === false) {
                            unset($groups[$group_id]);
                        } // アクセス権設定有りでキャッシュされている
                        else {
                            $have_setting_count++;
                        }
                    }
                }
                // アクセス権設定がキャッシュされている組織はgetHaveAccessSettingListを呼ばない
                $groups_count = count($groups);
                if ($groups_count > 0
                    && $groups_count !== $have_setting_count
                ) {
                    $groups = $this->getHaveAccessSettingList($user, $groups,
                        'group', $dynamic_roles);
                }

                $groups_count = count($groups);
                if ($groups_count > 0) {
                    if ( ! array_key_exists($authorities_type,
                        $this->_deny_groups_list)
                    ) {
                        $this->_deny_groups_list[$authorities_type] = [];
                        $this->_permit_groups_list[$authorities_type] = [];
                    }

                    $b_found = false;
                    foreach (array_keys($groups) as $key2) {
                        if (array_key_exists($key2,
                            $this->_permit_groups_list[$authorities_type])
                        ) {
                            $b_found = true;
                            continue;
                        }

                        // ループの外で所属組織の評価を行うため配列に溜めておく
                        if ( ! array_key_exists($key2, $group_user_map)) {
                            $group_user_map[$key2] = [];
                        }
                        $group_user_map[$key2][$key] = $key;
                    }
                    if ($b_found) {
                        // いい人リストにユーザーを追加
                        $permit_cache_list[$key] = $key;
                        $alreadys[$key] = $key;
                        continue;
                    }
                }

                $roles = array_key_exists($key, $roles_list) ? $roles_list[$key]
                    : [];

                // アクセス権設定の有無をキャッシュから取得
                $cache_list = null;
                if (array_key_exists($user_id,
                    $this->_have_setting_role_list)
                ) {
                    $cache_list = $this->_have_setting_role_list[$user_id];
                }
                $have_setting_count = 0;
                if ( ! is_null($cache_list)) {
                    foreach (array_keys($roles) as $role_id) {
                        if ( ! array_key_exists($role_id, $cache_list)) {
                            continue;
                        }

                        // アクセス権設定無しでキャッシュされている
                        if ($cache_list[$role_id] === false) {
                            unset($roles[$role_id]);
                        } // アクセス権設定有りでキャッシュされている
                        else {
                            $have_setting_count++;
                        }
                    }
                }
                // アクセス権設定の有無がキャッシュされているロールはgetHaveAccessSettingListを呼ばない
                $roles_count = count($roles);
                if ($roles_count > 0 && $roles_count !== $have_setting_count) {
                    $roles = $this->getHaveAccessSettingList($user, $roles,
                        'role', $dynamic_roles);
                }

                $roles_count = count($roles);
                if ($roles_count > 0) {
                    if ( ! array_key_exists($authorities_type,
                        $this->_deny_roles_list)
                    ) {
                        $this->_deny_roles_list[$authorities_type] = [];
                        $this->_permit_roles_list[$authorities_type] = [];
                    }

                    $b_found = false;
                    foreach (array_keys($roles) as $key2) {
                        if (array_key_exists($key2,
                            $this->_permit_roles_list[$authorities_type])
                        ) {
                            $b_found = true;
                            continue;
                        }

                        // ループの外で所持ロールの評価を行うため配列に溜めておく
                        if ( ! array_key_exists($key2, $role_user_map)) {
                            $role_user_map[$key2] = [];
                        }
                        $role_user_map[$key2][$key] = $key;
                    }
                    if ($b_found) {
                        // いい人リストにユーザーを追加
                        $permit_cache_list[$key] = $key;
                        $alreadys[$key] = $key;
                        continue;
                    }
                }
            }

            // ユーザー毎の所属組織,所持ロールの評価はループの外でまとめて行う
            $permit_users = [];
            $deny_group_keys = [];
            $deny_role_keys = [];

            // 各ユーザーの所属組織の評価
            $group_count = count($group_user_map);
            if ($group_count > 0) {
                $permit_groups = $this->_getAllowMultiObjects($user,
                    $group_user_map, 'group', $authorities, $dynamic_roles,
                    $user_groups, $user_roles,
                    $this->_deny_groups_list[$authorities_type],
                    $this->_permit_groups_list[$authorities_type],
                    $lax_evaluate);
                // 許可された組織に所属するユーザーは許可(許可優先)
                foreach ($group_user_map as $group_id => $group_users) {
                    if (array_key_exists($group_id, $permit_groups)) {
                        foreach ($group_users as $permit_user_id) {
                            $permit_cache_list[$permit_user_id]
                                = $permit_user_id;
                            $permit_users[$permit_user_id] = $permit_user_id;
                        }
                    }
                }

                // 拒否された組織のリストを作る
                $permit_keys = array_keys($permit_groups);
                $group_keys = array_keys($group_user_map);
                $deny_group_keys = array_diff($group_keys, $permit_keys);
            }

            // 各ユーザーの所持ロールの評価
            $role_count = count($role_user_map);
            if ($role_count > 0) {
                $permit_roles = $this->_getAllowMultiObjects($user,
                    $role_user_map, 'role', $authorities, $dynamic_roles,
                    $user_groups, $user_roles,
                    $this->_deny_roles_list[$authorities_type],
                    $this->_permit_roles_list[$authorities_type],
                    $lax_evaluate);

                // 許可されたロールを所持するユーザーは許可(許可優先)
                foreach ($role_user_map as $role_id => $role_users) {
                    if (array_key_exists($role_id, $permit_roles)) {
                        foreach ($role_users as $permit_user_id) {
                            $permit_cache_list[$permit_user_id]
                                = $permit_user_id;
                            $permit_users[$permit_user_id] = $permit_user_id;
                        }
                    }
                }

                // 拒否されたロールのリストを作る
                $permit_keys = array_keys($permit_roles);
                $role_keys = array_keys($role_user_map);
                $deny_role_keys = array_diff($role_keys, $permit_keys);
            }

            // 拒否された組織の評価
            $deny_group_count = count($deny_group_keys);
            if ($deny_group_count > 0) {
                // 拒否された組織に所属するユーザーで、他の許可された組織、ロールに所属していないユーザーは拒否
                foreach ($deny_group_keys as $deny_group_id) {
                    $deny_group_users = $group_user_map[$deny_group_id];
                    foreach ($deny_group_users as $deny_group_user_id) {
                        if ( ! array_key_exists($deny_group_user_id,
                            $permit_users)
                        ) {
                            $deny_cache_list[$deny_group_user_id]
                                = $deny_group_user_id;
                            unset($retval[$deny_group_user_id]);
                        }
                    }
                }
            }

            // 拒否されたロールの評価
            $deny_role_count = count($deny_role_keys);
            if ($deny_role_count > 0) {
                // 拒否されたロールを所持するユーザーで、他の許可された組織、ロールに所属していないユーザーは拒否
                foreach ($deny_role_keys as $deny_role_id) {
                    $deny_role_users = $role_user_map[$deny_role_id];
                    foreach ($deny_role_users as $deny_role_user_id) {
                        if ( ! array_key_exists($deny_role_user_id,
                            $permit_users)
                        ) {
                            $deny_cache_list[$deny_role_user_id]
                                = $deny_role_user_id;
                            unset($retval[$deny_role_user_id]);
                        }
                    }
                }
            }
        }

        $retval = $retval + $alreadys;

        return $retval;
    }

    /**
     * アクセス権が許可されたオブジェクトを返す
     *  $authorities の操作をできるオブジェクトだけを返す
     *
     * @param   CB_User $user          ユーザー
     * @param   mixed   $objects       評価対象
     * @param   array   $authorities   操作
     * @param   array   $dynamic_roles ダイナミックロール
     * @param           $object_type
     * @param   bool    $lax_evaluate
     *
     * @return  array
     */
    function evaluateAccesses(
        $user,
        $objects,
        $authorities,
        $dynamic_roles,
        $object_type,
        $lax_evaluate = false
    ) {
        $evaluated = [];
        // オブジェクトの順番を保持するためにキーを取得
        $objects_order = array_keys($objects);

        $rows = [];
        foreach (array_keys($objects) as $key) {
            $object = $objects[$key];
            $object_id = $object->getOID();
            $rows[$object_id] = $object_id;
        }

        $rows = $this->evaluateAccessesById($user, $rows, $authorities,
            $dynamic_roles, $object_type, false, $lax_evaluate);

        foreach (array_keys($objects) as $key) {
            $object = $objects[$key];
            $object_id = $object->getOID();
            if ( ! array_key_exists($object_id, $rows)) {
                unset($objects[$key]);
            }
        }

        // 施設は施設グループの評価で順番が変わってしまう可能性があるため
        // あらかじめ保持していた順番に戻す
        $evaluated_objects = [];
        if ($object_type == 'facility') {
            $evaluated = $evaluated + $objects;
            foreach ($objects_order as $key) {
                // アクセス権があったものだけ返す
                if (array_key_exists($key, $evaluated)) {
                    $evaluated_objects[$key] = &$evaluated[$key];
                }
            }
        } else {
            $evaluated_objects = $evaluated + $objects;
        }

        return $evaluated_objects;
    }


    /**
     * 評価したアクセス権の結果を取得する
     *  getEvaluateAccessListを複数のオブジェクトに対してできる
     *
     * @param   CB_User $user          ユーザー
     * @param   array   $objects       評価対象
     * @param           $object_type
     * @param   array   $authorities   操作
     * @param   array   $dynamic_roles ダイナミックロール
     *
     * @return  array       評価したリスト
     */
    function getEvaluateAccessesList(
        $user,
        $objects,
        $object_type,
        $authorities,
        $dynamic_roles
    ) {
        if ( ! is_array($objects)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_OBJECT);
        }
        if (0 === count($objects)) {
            return [];
        }
        if ( ! is_object($user) || ! is_a($user, 'CB_User')) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_USER_ID);
        }

        $this->_initilize($user);

        $authority_type = implode('_', $authorities);

        $list = $this->_evaluateEventMembersAccess($user,
            $objects,
            $object_type,
            $authorities,
            $authority_type,
            $dynamic_roles,
            $this->_user_groups,
            $this->_user_roles);

        return $list;
    }

    /**
     * 評価したアクセス権の結果を取得する
     *  $objectに対して $authorities の操作がどうなっているかを返す
     *
     * @param \CB_User $user          ユーザー
     * @param          $object        評価対象
     * @param   array  $authorities   操作
     * @param          $authority_type
     * @param   array  $dynamic_roles ダイナミックロール
     * @param   array  $user_groups   ユーザーのスタティックロール
     * @param          $user_roles
     *
     * @return array       評価したリスト
     */
    function getEvaluateAccessList(
        $user,
        & $object,
        $authorities,
        $authority_type,
        $dynamic_roles,
        $user_groups = null,
        $user_roles = null
    ) {
        if ( ! is_object($object)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_OBJECT);
        }

        if ( ! is_object($user) || ! is_a($user, 'CB_User')) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_USER_ID);
        }
        if (is_null($user_groups)) {
            $this->_initilize($user);

            $user_groups = &$this->_user_groups;
        }

        if (is_null($user_roles)) {
            $this->_initilize($user);

            $user_roles = &$this->_user_roles;
        }

        return $this->_evaluateEventMemberAccess($user, $object, $authorities,
            $authority_type, $dynamic_roles, $user_groups, $user_roles);
    }

    /**
     * メンバーに対する計算
     *
     * @access private
     */
    function _evaluateEventMemberAccess(
        $user,
        & $member,
        $authorities,
        $authority_type,
        $dynamic_roles,
        $user_groups,
        $user_roles
    ) {
        $cache_list = null;
        // ここにパフォーマンス用のデータチェックを埋める
        if (is_a($member, 'CB_User')) {
            if ( ! array_key_exists($authority_type,
                $this->_evaluate_users_list)
            ) {
                $this->_evaluate_users_list[$authority_type] = [];

                // ログインユーザーをデフォルトONにしておく
                if (is_object($user)) {
                    $login_access = [];
                    foreach ($authorities as $authority) {
                        $login_access[$authority] = GRN_SCHD_ACCESS_AFFIRM;
                    }
                    $this->_evaluate_users_list[$authority_type][$user->getOID()]
                        = $login_access;
                }
            }
            $cache_list = &$this->_evaluate_users_list[$authority_type];
        } elseif (is_a($member, 'CB_Group')) {
            if ( ! array_key_exists($authority_type,
                $this->_evaluate_groups_list)
            ) {
                $this->_evaluate_groups_list[$authority_type] = [];
            }
            $cache_list = &$this->_evaluate_groups_list[$authority_type];
        } elseif (is_a($member, 'CB_Role')) {
            if ( ! array_key_exists($authority_type,
                $this->_evaluate_roles_list)
            ) {
                $this->_evaluate_roles_list[$authority_type] = [];
            }
            $cache_list = &$this->_evaluate_roles_list[$authority_type];
        } elseif (is_a($member, 'GRN_Facility_Facility')) {
            if ( ! array_key_exists($authority_type,
                $this->_evaluate_facilities_list)
            ) {
                $this->_evaluate_facilities_list[$authority_type] = [];
            }
            $cache_list = &$this->_evaluate_facilities_list[$authority_type];
        } elseif (is_a($member, 'GRN_Facility_FacilityGroup')) {
            if ( ! array_key_exists($authority_type,
                $this->_evaluate_facility_groups_list)
            ) {
                $this->_evaluate_facility_groups_list[$authority_type] = [];
            }
            $cache_list
                = &$this->_evaluate_facility_groups_list[$authority_type];
        } else {
            return false;
        }

        // 評価済みの場合は既に使用しているものを使用
        $member_id = $member->getOID();
        if (array_key_exists($member_id, $cache_list)) {
            return $cache_list[$member_id];
        }

        // DBからデータの取得
        $_accesses = $this->_evaluateAccess($user, $member, $authorities,
            $dynamic_roles);

        if ($_accesses) {
            switch ($this->_getSecurityModel($member)) {
                // REVOKEは逆となる
                case GRN_SCHD_SECURITY_MODEL_TYPE_REVOKE:
                    foreach ($_accesses as $key => $_access) {
                        $_accesses[$key] = $_access ? GRN_SCHD_ACCESS_DENY
                            : GRN_SCHD_ACCESS_AFFIRM;
                    }
                    break;
            }
        } else {
            $flag = null;
            switch ($this->_getSecurityModel($member)) {
                // REVOKEは逆となる
                case GRN_SCHD_SECURITY_MODEL_TYPE_GRANT:
                    $flag = GRN_SCHD_ACCESS_DENY;
                    break;
                case GRN_SCHD_SECURITY_MODEL_TYPE_REVOKE:
                    $flag = GRN_SCHD_ACCESS_AFFIRM;
                    break;
            }

            $_accesses = [];
            foreach ($authorities as $authority) {
                $_accesses[$authority] = $flag;
            }
        }

        // 組織とロールのチェック
        if (is_a($member, 'CB_User')) {
            // ユーザーに対するアクセス権設定を最優先する
            $members = [$member_id => $member];
            $have_access_user = $this->getHaveAccessSettingList($user, $members,
                'user', $dynamic_roles);
            if (is_array($have_access_user) && count($have_access_user) > 0) {
                return $_accesses;
            }

            $have_access_setting = false;
            $_accesses = [];
            foreach ($authorities as $authority) {
                $_accesses[$authority] = GRN_SCHD_ACCESS_DENY;
            }

            global $G_container_base;
            $uum = $G_container_base->getInstance('uum');

            // 組織に対するアクセス権が設定されていた場合のみORで評価
            // CB_Userからuidを取得しているので、第2引数にTRUEを渡して削除フラグチェックを行わない
            $target_groups = $uum->getUserGroupsInfo($member_id, true);
            $have_access_groups = $this->getHaveAccessSettingList($user,
                $target_groups, 'group', $dynamic_roles);
            if (is_array($have_access_groups)
                && count($have_access_groups) > 0
            ) {
                $have_access_setting = true;
                $retval_groups = $this->getEvaluateAccessesListById($user,
                    $have_access_groups, 'group', $authorities, $dynamic_roles);
                foreach ($retval_groups as $retval_group) {
                    foreach ($retval_group as $key => $value) {
                        $_accesses[$key] |= $value;
                    }
                }
            }

            // ロールに対するアクセス権が設定されていた場合のみORで評価
            // $member_idはCB_Userからuidを取得した値なので、第2引数にTRUEを渡して削除フラグチェックを行わない
            $target_roles = $uum->getUserRolesInfo($member_id, true);
            $have_access_roles = $this->getHaveAccessSettingList($user,
                $target_roles, 'role', $dynamic_roles);
            if (is_array($have_access_roles) && count($have_access_roles) > 0) {
                $have_access_setting = true;
                $retval_roles = $this->getEvaluateAccessesListById($user,
                    $have_access_roles, 'role', $authorities, $dynamic_roles);
                foreach ($retval_roles as $retval_role) {
                    foreach ($retval_role as $key => $value) {
                        $_accesses[$key] |= $value;
                    }
                }
            }

            // Revoke でアクセス権が全く設定されていなかったら全てアクセス可能にする
            if ( ! $have_access_setting) {
                foreach ($authorities as $authority) {
                    $_accesses[$authority] = GRN_SCHD_ACCESS_AFFIRM;
                }
            }
        }

        return $_accesses;
    }

    /**
     * イベントのアクセス権を取得する
     *　イベントに対してどういった $authorities の操作がどうなっているかのリストを返す
     *
     * @param   object CB_User      $user
     * @param   mixed $event
     * @param   array $authorities
     * @param   array $dynamic_roles
     * @param bool    $b_login
     *
     * @return array     イベントに対するアクセス権の配列
     */

    function getEventAccess(
        $user,
        & $event,
        $authorities,
        $dynamic_roles,
        $b_login = true
    ) {
        $access = [];
        foreach ($authorities as $authority) {
            $access[$authority] = GRN_SCHD_ACCESS_AFFIRM;
        }

        $authority_type = implode('_', $authorities);

        $this->_initilize($user);

        // 参加者についてチェック
        if ($event->users) {
            foreach (array_keys($event->users) as $key) {
                $member = $event->users[$key];
                // 自分かチェック
                if (($member->getOID() == $user->getOID())) {
                    if ($b_login) {
                        foreach ($authorities as $authority) {
                            $access[$authority] = GRN_SCHD_ACCESS_AFFIRM;
                        }

                        return $access;
                    }
                }
            }

            // 一括して評価
            $_accesses = $this->_evaluateEventMembersAccess($user,
                $event->users, 'user', $authorities, $authority_type,
                $dynamic_roles, $this->_user_groups, $this->_user_roles);

            foreach ($_accesses as $_access) {
                foreach ($authorities as $authority) {
                    $access[$authority] &= $_access[$authority];

                    // 全部0の場合は操作できないのでそれで終了
                    if (array_sum($access) == 0) {
                        return $access;
                    }
                }
            }
        }

        if ($event->groups) {
            $_accesses = $this->_evaluateEventMembersAccess($user,
                $event->groups, 'group', $authorities, $authority_type,
                $dynamic_roles, $this->_user_groups, $this->_user_roles);

            foreach ($_accesses as $_access) {
                foreach ($authorities as $authority) {
                    $access[$authority] &= $_access[$authority];

                    // 全部0の場合は操作できないのでそれで終了
                    if (array_sum($access) == 0) {
                        return $access;
                    }
                }
            }
        }


        if (is_array($event->facilities) && count($event->facilities) > 0) {
            // 施設のアクセス権を取得する
            $target_facilities = $event->facilities;
            $_accesses = $this->_evaluateEventMembersAccess($user,
                $target_facilities, 'facility', $authorities, $authority_type,
                $dynamic_roles, $this->_user_groups, $this->_user_roles);

            // 施設グループのアクセス権を取得する
            $target_facilities = $event->facilities;
            $tmp_accesses
                = $this->_evaluateEventFacilitiesGroupsAccess($user,
                $target_facilities, $authorities, $authority_type,
                $dynamic_roles, $this->_user_groups, $this->_user_roles);

            // 施設と施設グループのアクセス権で、厳しいほうを評価結果とする
            foreach (array_keys($_accesses) as $key) {
                foreach ($this->_access_type as $auth_name) {
                    if (array_key_exists($key, $tmp_accesses)
                        && array_key_exists($auth_name, $tmp_accesses[$key])
                        && $tmp_accesses[$key][$auth_name]
                           == GRN_SCHD_ACCESS_DENY
                    ) {
                        $_accesses[$key][$auth_name] = GRN_SCHD_ACCESS_DENY;
                    }
                }
            }


            foreach ($_accesses as $_access) {
                foreach ($authorities as $authority) {
                    $access[$authority] &= $_access[$authority];

                    // 全部0の場合は操作できないのでそれで終了
                    if (array_sum($access) == 0) {
                        return $access;
                    }
                }
            }
        }

        // 仮予定の場合
        if (is_a($event, 'GRN_Schedule_TemporaryEvent')
            && $event->isORSearch()
        ) {
            $facilities = [];
            foreach ($event->setdates as $facility_data) {
                $facility = $facility_data['facility'];
                if (is_a($facility, 'GRN_Facility_Facility')) {
                    $facilities[$facility->getOID()] = $facility;
                }
            }

            if (count($facilities) > 0) {
                // 施設のアクセス権を取得する
                $target_facilities = $facilities;
                $_accesses = $this->_evaluateEventMembersAccess($user,
                    $target_facilities, 'facility', $authorities,
                    $authority_type, $dynamic_roles, $this->_user_groups,
                    $this->_user_roles);

                // 施設グループのアクセス権を取得する
                $target_facilities = $facilities;
                $tmp_accesses
                    = $this->_evaluateEventFacilitiesGroupsAccess($user,
                    $target_facilities, $authorities, $authority_type,
                    $dynamic_roles, $this->_user_groups, $this->_user_roles);

                // 施設と施設グループのアクセス権で、厳しいほうを評価結果とする
                foreach (array_keys($_accesses) as $key) {
                    foreach ($this->_access_type as $auth_name) {
                        if (array_key_exists($key, $tmp_accesses)
                            && array_key_exists($auth_name, $tmp_accesses[$key])
                            && $tmp_accesses[$key][$auth_name]
                               == GRN_SCHD_ACCESS_DENY
                        ) {
                            $_accesses[$key][$auth_name] = GRN_SCHD_ACCESS_DENY;
                        }
                    }
                }


                foreach ($_accesses as $_access) {
                    foreach ($authorities as $authority) {
                        $access[$authority] &= $_access[$authority];

                        // 全部0の場合は操作できないのでそれで終了
                        if (array_sum($access) == 0) {
                            return $access;
                        }
                    }
                }
            }
        }

        return $access;
    }

    /**
     * @param      $user
     * @param      $event
     * @param      $authorities
     * @param      $dynamic_roles
     * @param bool $b_login
     *
     * @return array
     */
    function getEventAccessByID(
        $user,
        & $event,
        $authorities,
        $dynamic_roles,
        $b_login = true
    ) {
        $access = [];
        foreach ($authorities as $authority) {
            $access[$authority] = GRN_SCHD_ACCESS_AFFIRM;
        }

        $authority_type = implode('_', $authorities);

        $this->_initilize($user);

        // 参加者についてチェック
        if (is_array($event->users)) {
            foreach ($event->users as $member_id) {
                // 自分かチェック
                if (($member_id == $user->getOID())) {
                    if ($b_login) {
                        foreach ($authorities as $authority) {
                            $access[$authority] = GRN_SCHD_ACCESS_AFFIRM;
                        }

                        return $access;
                    }
                }
            }

            // 一括して評価
            $_accesses = $this->_evaluateEventMembersAccessByID($user,
                $event->users, 'user', $authorities, $authority_type,
                $dynamic_roles, $this->_user_groups, $this->_user_roles);

            foreach ($_accesses as $_access) {
                foreach ($authorities as $authority) {
                    $access[$authority] &= $_access[$authority];

                    // 全部0の場合は操作できないのでそれで終了
                    if (array_sum($access) == 0) {
                        return $access;
                    }
                }
            }
        }

        if (is_array($event->groups)) {
            $_accesses = $this->_evaluateEventMembersAccessByID($user,
                $event->groups, 'group', $authorities, $authority_type,
                $dynamic_roles, $this->_user_groups, $this->_user_roles);

            foreach ($_accesses as $_access) {
                foreach ($authorities as $authority) {
                    $access[$authority] &= $_access[$authority];

                    // 全部0の場合は操作できないのでそれで終了
                    if (array_sum($access) == 0) {
                        return $access;
                    }
                }
            }
        }


        if (is_array($event->facilities) && count($event->facilities) > 0) {
            // 施設のアクセス権を取得する
            $target_facilities = $event->facilities;
            $_accesses = $this->_evaluateEventMembersAccessByID($user,
                $target_facilities, 'facility', $authorities, $authority_type,
                $dynamic_roles, $this->_user_groups, $this->_user_roles);

            // 施設グループのアクセス権を取得する
            $target_facilities = $event->facilities;
            $tmp_accesses
                = $this->_evaluateEventFacilitiesGroupsAccessById($user,
                $target_facilities, $authorities, $authority_type,
                $dynamic_roles, $this->_user_groups, $this->_user_roles);

            // 施設と施設グループのアクセス権で、厳しいほうを評価結果とする
            foreach (array_keys($_accesses) as $key) {
                foreach ($this->_access_type as $auth_name) {
                    if (array_key_exists($key, $tmp_accesses)
                        && array_key_exists($auth_name, $tmp_accesses[$key])
                        && $tmp_accesses[$key][$auth_name]
                           == GRN_SCHD_ACCESS_DENY
                    ) {
                        $_accesses[$key][$auth_name] = GRN_SCHD_ACCESS_DENY;
                    }
                }
            }

            foreach ($_accesses as $_access) {
                foreach ($authorities as $authority) {
                    $access[$authority] &= $_access[$authority];

                    // 全部0の場合は操作できないのでそれで終了
                    if (array_sum($access) == 0) {
                        return $access;
                    }
                }
            }
        }

        // 仮予定の場合
        if (is_a($event, 'GRN_Schedule_TemporaryEvent')
            && $event->isORSearch()
        ) {
            $facilities = [];
            foreach ($event->setdates as $facility_data) {
                $facility = $facility_data['facility'];
                if (is_a($facility, 'GRN_Facility_Facility')) {
                    $facilities[$facility->getOID()] = $facility;
                }
            }

            if (count($facilities) > 0) {
                // 施設のアクセス権を取得する
                $target_facilities = $facilities;
                $_accesses = $this->_evaluateEventMembersAccess($user,
                    $target_facilities, 'facility', $authorities,
                    $authority_type, $dynamic_roles, $this->_user_groups,
                    $this->_user_roles);

                // 施設グループのアクセス権を取得する
                $target_facilities = $facilities;
                $tmp_accesses
                    = $this->_evaluateEventFacilitiesGroupsAccess($user,
                    $target_facilities, $authorities, $authority_type,
                    $dynamic_roles, $this->_user_groups, $this->_user_roles);

                // 施設と施設グループのアクセス権で、厳しいほうを評価結果とする
                foreach (array_keys($_accesses) as $key) {
                    foreach ($this->_access_type as $auth_name) {
                        if (array_key_exists($key, $tmp_accesses)
                            && array_key_exists($auth_name, $tmp_accesses[$key])
                            && $tmp_accesses[$key][$auth_name]
                               == GRN_SCHD_ACCESS_DENY
                        ) {
                            $_accesses[$key][$auth_name] = GRN_SCHD_ACCESS_DENY;
                        }
                    }
                }

                foreach ($_accesses as $_access) {
                    foreach ($authorities as $authority) {
                        $access[$authority] &= $_access[$authority];

                        // 全部0の場合は操作できないのでそれで終了
                        if (array_sum($access) == 0) {
                            return $access;
                        }
                    }
                }
            }
        }

        return $access;
    }


    /**
     * オブジェクトのアクセス権評価値を計算する
     *
     * @access      private
     */
    function _evaluateAccesses(
        $user,
        $objects,
        $object_type,
        $authorities
    ) {

        $dynamic_roles = $this->_user_dynamic_roles;
        $user_groups = $this->_user_groups;
        $user_roles = $this->_user_roles;

        if ( ! is_array($objects) || count($objects) == 0) {
            return false;
        }

        $user_id = $user->getOID();
        $targets_list = [];

        $db = $this->_getDBConnection();

        // ダイナミックロールを取得する
        $targets_list[GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE] = $dynamic_roles;
        if (is_array($dynamic_roles) && count($dynamic_roles) > 0) {
            $target_array = [];
            foreach (array_keys($dynamic_roles) as $key) {
                //$target_array[] = '\''.$key.'\'';
                $target_array[] = cb_queryf($db, "'@S'", $key);
            }
            $targets_list[GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE] = implode(',',
                $target_array);
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE] = null;
        }

        // スタティックロールを取得する
        if (false === $user_roles) {
            return false;
        }
        if (is_array($user_roles) && count($user_roles) > 0) {
            //$targets_list[GRN_SCHD_TARGET_TYPE_STATIC_ROLE] = implode( ',', array_keys( $user_roles ) );
            $target_array = [];
            foreach (array_keys($user_roles) as $key) {
                $target_array[] = cb_queryf($db, "'@S'", $key);
            }
            $targets_list[GRN_SCHD_TARGET_TYPE_STATIC_ROLE] = implode(',',
                $target_array);
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_STATIC_ROLE] = null;
        }

        // 組織を取得する
        if (false === $user_groups) {
            return false;
        }
        if (is_array($user_groups) && count($user_groups) > 0) {
            //$targets_list[GRN_SCHD_TARGET_TYPE_GROUP] = implode( ',', array_keys( $user_groups ) );
            $target_array = [];
            foreach (array_keys($user_groups) as $key) {
                $target_array[] = cb_queryf($db, "'@S'", $key);
            }
            $targets_list[GRN_SCHD_TARGET_TYPE_GROUP] = implode(',',
                $target_array);
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_GROUP] = null;
        }

        // ユーザーを取得する
        $targets_list[GRN_SCHD_TARGET_TYPE_USER] = $user->getOID();

        if ($object_type == 'facilitygroup') {
            assert(false);
        }

        $object_id = 'schedule_access_' . $object_type;

        $target_tables =& $this->_target_tables;

        $values = [];


        foreach (array_keys($objects) as $key) {

            $values[$key] = [];
            foreach ($authorities as $authority) {
                $values[$key][$authority] = 0;
            }
        }

        $str_temp = [];
        foreach ($authorities as $authority) {
            $str_temp[] = "col_authority_" . $authority . " = '1'";
        }
        $authorities_str = implode(' OR ', $str_temp);

        foreach ($target_tables as $target_id => $target_table) {
            if (is_null($targets_list[$target_id])
                || 0 === count($targets_list[$target_id])
            ) {
                continue;
            }

            // Check old values in cache, if existed use it
            $table_name = $this->_getTableName($object_id, $target_id, true);

            $cache_success = true;
            $cache_object_success = [];
            // Try to get value from cache
            foreach (array_keys($objects) as $_object_id) {
                $cache_object_success[$_object_id] = true;
                foreach ($authorities as $authority) {
                    $cache_key = "user!" . $user_id . "_" . $table_name . "!"
                                 . $_object_id . "_" . $authority;
                    $value = (array_key_exists($cache_key, $this->_cache)
                        ? $this->_cache[$cache_key] : null);
                    if (is_null($value)) {
                        $cache_object_success[$_object_id] = false;
                        $cache_success = false;
                        $this->save_to_cache($cache_key, 0);
                    } else {
                        $values[$_object_id][$authority]
                            = max(array_key_exists($authority,
                            $values[$_object_id])
                            ? $values[$_object_id][$authority] : 0, $value);

                    }
                }
            }
            if ($cache_success && $this->_cache_option === true) {
                $foo = 1;
                continue;
            }

            $object_str = cb_queryf($db, "@S",
                implode(",", array_keys($objects)));
            $object_str = "'" . str_replace(",", "','", $object_str) . "'";

            // ユーザー削除フラグを確認
            // $targets_list['user'] にはCB_Userから取得したuidしか入らないので、targetの削除フラグチェックは行わない
            $join = '';
            if (strcmp($object_id, 'schedule_access_user') == 0) {
                $join .= ' INNER JOIN tab_cb_user AS ou ON tab_' . $table_name
                         . '.col_object = ou._id AND ou.col_deleted IS NULL';
            }

            $query = 'SELECT * FROM tab_' . $table_name . $join
                     . ' WHERE ( ( col_object IN (' . $object_str
                     . ') ) AND ( col_target IN (' . $targets_list[$target_id]
                     . ') ) AND (' . $authorities_str . ') )';

            $query = $db->select_format($query);

            $result = $db->query($query);
            if ($result === false) {
                $db->throwError([
                    'query' => 'failed query on SELECT: ' . $query
                ]);
            }

            while ($row = $db->fetch_assoc($result)) {
                $_object_id = $row['col_object'];
                $evalval = 1;
                foreach ($authorities as $authority) {
                    $value = $row['col_authority_' . $authority];
                    $value = is_null($value) ? 0 : intval($value);
                    $values[$_object_id][$authority]
                        = max(array_key_exists($authority,
                        $values[$_object_id]) ? $values[$_object_id][$authority]
                        : 0, $value);
                    $evalval = $evalval & $values[$_object_id][$authority];

                    $cache_key = "user!" . $user_id . "_" . $table_name . "!"
                                 . $_object_id . "_" . $authority;
                    $this->save_to_cache($cache_key,
                        $values[$_object_id][$authority]);
                }
            }

            // 結果の開放
            $db->free_result($result);
        }

        return $values;
    }

    /**
     * メンバーに対する計算
     *
     * @access private
     */
    function _evaluateEventMembersAccess(
        $user,
        & $members,
        $members_type,
        $authorities,
        $authority_type,
        $dynamic_roles,
        $user_groups,
        $user_roles
    ) {

        $member_ids = [];
        $objects = [];
        foreach (array_keys($members) as $key) {
            $member = $members[$key];
            $member_id = $member->getOID();
            $member_ids[$member_id] = $member_id;
        }

        return $this->_evaluateEventMembersAccessByID($user,
            $member_ids,
            $members_type,
            $authorities,
            $authority_type,
            $dynamic_roles,
            $user_groups,
            $user_roles);
    }

    /**
     * メンバーに対する計算
     *
     * @access private
     */
    function _evaluateEventMembersAccessById(
        $user,
        $members,
        $members_type,
        $authorities,
        $authority_type,
        $dynamic_roles,
        $user_groups,
        $user_roles
    ) {
        if ( ! is_array($members) || count($members) === 0) {
            return false;
        }

        $cache_list = null;
        // ここにパフォーマンス用のデータチェックを埋める
        switch ($members_type) {
            case 'user':
                if ( ! array_key_exists($authority_type,
                    $this->_evaluate_users_list)
                ) {
                    $this->_evaluate_users_list[$authority_type] = [];

                    // ログインユーザーをデフォルトONにしておく
                    if (is_object($user)) {
                        $login_access = [];
                        foreach ($authorities as $authority) {
                            $login_access[$authority] = GRN_SCHD_ACCESS_AFFIRM;
                        }
                        $this->_evaluate_users_list[$authority_type][$user->getOID()]
                            = $login_access;
                    }
                }
                $cache_list = &$this->_evaluate_users_list[$authority_type];
                break;
            case 'group':
                if ( ! array_key_exists($authority_type,
                    $this->_evaluate_groups_list)
                ) {
                    $this->_evaluate_groups_list[$authority_type] = [];
                }
                $cache_list = &$this->_evaluate_groups_list[$authority_type];
                break;
            case 'role':
                if ( ! array_key_exists($authority_type,
                    $this->_evaluate_roles_list)
                ) {
                    $this->_evaluate_roles_list[$authority_type] = [];
                }
                $cache_list = &$this->_evaluate_roles_list[$authority_type];
                break;
            case 'facility':
                if ( ! array_key_exists($authority_type,
                    $this->_evaluate_facilities_list)
                ) {
                    $this->_evaluate_facilities_list[$authority_type] = [];
                }
                $cache_list
                    = &$this->_evaluate_facilities_list[$authority_type];
                break;
            case 'facilitygroup':
                if ( ! array_key_exists($authority_type,
                    $this->_evaluate_facility_groups_list)
                ) {
                    $this->_evaluate_facility_groups_list[$authority_type] = [];
                }
                $cache_list
                    = &$this->_evaluate_facility_groups_list[$authority_type];
                break;
            default:
                assert(! $members_type);

                return false;
        }

        $retval = [];
        $objects = [];
        foreach (array_keys($members) as $key) {
            // 評価済みは除く
            if (array_key_exists($key, $cache_list)) {
                $retval[$key] = $cache_list[$key];
                continue;
            }

            $objects[$key] = $key;
        }

        if (count($objects) > 0) {
            if ($members_type == 'facilitygroup') {
                return $this->_evaluateEventMembersAccessByIdFacilityGroup($user,
                    $objects,
                    $authorities,
                    $dynamic_roles,
                    $user_groups,
                    $user_roles,
                    $cache_list);
            }

            // DBからデータの取得
            $_accesses = $this->_evaluateAccesses($user, $objects,
                $members_type, $authorities);

            if ($_accesses === false) {
                return false;
            }

            $secutiry_models = $this->_getSecurityModels($objects,
                $members_type);

            $roles_list = null;
            $groups_list = null;
            if ($members_type == 'user') {
                $member_ids = array_keys($objects);
                global $G_container_base;
                $uum = $G_container_base->getInstance('uum');
                // CB_Userからuidを取得しているので、第2引数にTRUEを渡して削除フラグチェックを行わない
                $groups_list = $uum->getUsersGroupsInfo($member_ids,
                    true);
                $roles_list = $uum->getUsersRolesInfo($member_ids,
                    true);
                $have_access_setting = $this->getHaveAccessSettingList($user,
                    $objects, 'user', $dynamic_roles);
            }

            foreach (array_keys($objects) as $key) {
                $member_securitymodel = $secutiry_models[$key];
                if (array_key_exists($key, $_accesses)) {
                    $_access = $_accesses[$key];
                    if ($member_securitymodel
                        == GRN_SCHD_SECURITY_MODEL_TYPE_REVOKE
                    ) {
                        foreach (array_keys($_access) as $key2) {
                            $_access[$key2] = $_access[$key2]
                                ? GRN_SCHD_ACCESS_DENY : GRN_SCHD_ACCESS_AFFIRM;
                        }
                    }
                } else {
                    $flag = null;
                    switch ($member_securitymodel) {
                        case GRN_SCHD_SECURITY_MODEL_TYPE_GRANT:
                            $flag = GRN_SCHD_ACCESS_DENY;
                            break;
                        case GRN_SCHD_SECURITY_MODEL_TYPE_REVOKE:
                            $flag = GRN_SCHD_ACCESS_AFFIRM;
                            break;
                    }

                    $_access = [];
                    foreach ($authorities as $authority) {
                        $_access[$authority] = $flag;
                    }
                }

                if ($members_type == 'user') {
                    // ユーザーにアクセス権の"設定"があったら最優先
                    if (array_key_exists($key, $have_access_setting)) {
                        $cache_list[$key] = $_access;
                        $retval[$key] = $_access;
                        continue;
                    }
                }

                $b_finish = false;
                $_tmp_access = [];
                // 人の場合は、ロールと組織のチェック
                if ($members_type == 'user' && is_array($groups_list)) {
                    $groups_accesses = false;
                    $target_groups = array_key_exists($key, $groups_list)
                        ? $groups_list[$key] : null;
                    if (is_array($target_groups) && count($target_groups) > 0) {
                        $target_groups = $this->getHaveAccessSettingList($user,
                            $target_groups, 'group', $dynamic_roles);
                        if (is_array($target_groups)
                            && count($target_groups) > 0
                        ) {
                            $groups_accesses
                                = $this->_evaluateEventMembersAccessById($user,
                                $target_groups,
                                'group',
                                $authorities,
                                $authority_type,
                                $dynamic_roles,
                                $user_groups,
                                $user_roles);
                        }
                    }

                    if (is_array($groups_accesses)
                        && count($groups_accesses) > 0
                    ) {
                        if ( ! is_array($_tmp_access)
                             || count($_tmp_access) <= 0
                        ) {
                            $_tmp_access = [];
                            foreach ($authorities as $authority) {
                                $_tmp_access[$authority] = GRN_SCHD_ACCESS_DENY;
                            }
                        }

                        foreach ($groups_accesses as $group_access) {
                            foreach (array_keys($group_access) as $authority) {
                                //$_access[$authority] |= $group_access[$authority];
                                if ($group_access[$authority]
                                    == GRN_SCHD_ACCESS_AFFIRM
                                ) {
                                    $_tmp_access[$authority]
                                        =& $group_access[$authority];
                                }
                            }

                            //if( array_sum ( $_access ) != GRN_SCHD_ACCESS_DENY )
                            // 指定された権限が全て許可だったらアクセス権ありと判断
                            if (array_sum($_tmp_access)
                                == count($authorities)
                            ) {
                                $b_finish = true;
                                break;
                            }
                        }
                        $_access = $_tmp_access;
                    }
                }

                if ($members_type == 'user' && ! $b_finish
                    && is_array($roles_list)
                ) {
                    if ( ! is_array($_tmp_access) || count($_tmp_access) <= 0) {
                        $_tmp_access = [];
                        foreach ($authorities as $authority) {
                            $_tmp_access[$authority] = GRN_SCHD_ACCESS_DENY;
                        }
                    }

                    $target_roles = array_key_exists($key, $roles_list)
                        ? $roles_list[$key] : null;
                    $roles_accesses = false;
                    if (is_array($target_roles) && count($target_roles) > 0) {
                        $target_roles = $this->getHaveAccessSettingList($user,
                            $target_roles, 'role', $dynamic_roles);
                        if (is_array($target_roles)
                            && count($target_roles) > 0
                        ) {
                            $roles_accesses
                                = $this->_evaluateEventMembersAccessById($user,
                                $target_roles,
                                'role',
                                $authorities,
                                $authority_type,
                                $dynamic_roles,
                                $user_groups,
                                $user_roles);
                        }
                    }

                    if (is_array($roles_accesses)
                        && count($roles_accesses) > 0
                    ) {
                        foreach ($roles_accesses as $role_access) {
                            foreach (array_keys($role_access) as $authority) {
                                //$_access[$authority] &= $role_access[$authority];
                                if ($role_access[$authority]
                                    == GRN_SCHD_ACCESS_AFFIRM
                                ) {
                                    $_tmp_access[$authority]
                                        =& $role_access[$authority];
                                }
                            }

                            //if( array_sum ( $_access ) != GRN_SCHD_ACCESS_DENY )
                            // 指定された権限が全て許可だったらアクセス権ありと判断
                            if (array_sum($_tmp_access)
                                == count($authorities)
                            ) {
                                break;
                            }
                        }
                        $_access = $_tmp_access;
                    }

                }

                // キャッシュに記憶
                $cache_list[$key] = $_access;

                $retval[$key] = $_access;
            }
        }

        return $retval;
    }

    /**
     * アクセス権のCSVの書き出し
     *
     * @param CB_CSVWriter $writer
     */
    function exportAccessToCSV(& $writer)
    {
        $access_objects = [
            'user',
            'role',
            'group',
            'facility',
            'facilitygroup'
        ];

        $users_list = [];
        $groups_list = [];
        $roles_list = [];
        $facilites_list = [];
        $facility_groups_list = [];

        // 設定されているオブジェクトの一覧を作成
        foreach ($access_objects as $object_type) {
            switch ($object_type) {
                case 'user':
                    $list = &$users_list;
                    break;
                case 'role':
                    $list = &$roles_list;
                    break;
                case 'group':
                    $list = &$groups_list;
                    break;
                case 'facility':
                    $list = &$facilites_list;
                    break;
                case 'facilitygroup':
                    $list = &$facility_groups_list;
                    break;
            }

            $object_name = 'schedule_access_' . $object_type;
            foreach (array_keys($this->_target_tables) as $target_name) {
                $table_name = $this->_getTableName($object_name,
                    $target_name, true);
                $real_table_name = CB_DATABASE_TABLE_PREFIX . $table_name;
                $table_info =& $this->_getTableInfo($table_name);
                $rowset = new CB_RowSet($table_info);
                $this->_addUserJoin($rowset, $object_name, $target_name);

                $rowset->addOrderColumn('col_object', true);
                $rowset->applyGroupFunctions([
                    'id' => $real_table_name . '._id'
                ],
                    ['object' => 'col_object']);

                while ( ! is_null($row = &$rowset->iterate())) {
                    $object_id = $row['object'];
                    if ( ! array_key_exists($object_id, $list)) {
                        $list[$object_id] = [];
                    }

                    $list[$object_id][] = $table_name;
                }
            }
        }

        // リストにないセキュリティモデルの書き出し
        $this->_exportSecurityModelToCSV($writer, $users_list, $groups_list,
            $roles_list, $facilites_list, $facility_groups_list);

        // アクセス権の書き出し
        if (count($users_list) > 0) {
            $this->_exportAccessToCSV($writer, $users_list);
        }

        if (count($groups_list) > 0) {
            $this->_exportAccessToCSV($writer, $groups_list);
        }

        if (count($roles_list) > 0) {
            $this->_exportAccessToCSV($writer, $roles_list);
        }

        if (count($facilites_list) > 0) {
            $this->_exportAccessToCSV($writer, $facilites_list);
        }

        if (count($facility_groups_list) > 0) {
            $this->_exportAccessToCSV($writer, $facility_groups_list);
        }
    }


    /**
     * @param CB_CSVWriter $writer
     * @param array        $users_list
     * @param array        $groups_list
     * @param array        $roles_list
     * @param array        $facilites_list
     * @param array        $facility_groups_list
     */
    function _exportSecurityModelToCSV(
        & $writer,
        &$users_list,
        &$groups_list,
        &$roles_list,
        &$facilites_list,
        &$facility_groups_list
    ) {
        $table = $this->_getSecurityModelTable();
        $rowset = new CB_RowSet($table);

        $query = [];
        if (is_array($users_list) && count($users_list) > 0) {
            $query[]
                = $rowset->queryf('( col_user IS NULL OR col_user NOT IN (@A) )',
                array_keys($users_list));

            // ユーザー削除フラグを確認
            $user_table =& $this->_getTableInfo('CB_User');
            $real_table_name = CB_DATABASE_TABLE_PREFIX
                               . $table->getTableName();
            $on = '(' . $real_table_name
                  . '.col_user = u._id AND u.col_deleted IS NULL) OR '
                  . $real_table_name . '.col_user IS NULL';
            $rowset->addJoin($user_table, $on, CB_DATABASE_INNER_JOIN, 'u');
        }
        if (is_array($groups_list) && count($groups_list) > 0) {
            $query[]
                = $rowset->queryf('( col_group IS NULL OR col_group NOT IN (@A) )',
                array_keys($groups_list));
        }
        if (is_array($roles_list) && count($roles_list) > 0) {
            $query[]
                = $rowset->queryf('( col_role IS NULL OR col_role NOT IN (@A) )',
                array_keys($roles_list));
        }
        if (is_array($facilites_list) && count($facilites_list) > 0) {
            $query[] = $rowset->queryf(
                '( col_facility IS NULL OR col_facility NOT IN (@A) )',
                array_keys($facilites_list)
            );
        }
        if (is_array($facility_groups_list)
            && count($facility_groups_list) > 0
        ) {
            $query[] = $rowset->queryf(
                '( col_facilitygroup IS NULL OR col_facilitygroup NOT IN (@A) )',
                array_keys($facility_groups_list)
            );
        }


        if (count($query) > 0) {
            $query = implode(' AND ', $query);
            $rowset->addCondition($query);
        }

        while ( ! is_null($row = $rowset->iterate())) {
            $line = [];
            $object_type = '';
            if (($object = $row->get('user'))) {
                $object_type = 'user';
                $foreign_key = $object->get('foreign_key');
            } elseif (($object = $row->get('group'))) {
                $object_type = 'group';
                $foreign_key = $object->get('foreign_key');
            } elseif (($object = $row->get('role'))) {
                $object_type = 'role';
                $foreign_key = $object->get('foreign_key');
            } elseif (($object = $row->get('facility'))) {
                $object_type = 'facility';
                $foreign_key = $object->get('foreign_key');
            } elseif (($object = $row->get('facilitygroup'))) {
                $object_type = 'facilitygroup';
                $foreign_key = $object->get('foreign_key');
            } else {
                continue;
            }

            $security_model = $this->getSecurityModel($object);

            $line[] = $object_type;
            $line[] = $foreign_key;
            $line[] = 'security_model';
            $line[] = $security_model;
            $line[] = '';

            // 書き出し
            $writer->writeLine($line);
        }
        $rowset->destroy();
    }

    /**
     * @access private
     */
    function _exportAccessToCSV(& $writer, & $list)
    {
        foreach ($list as $id => $table_names) {
            $object_id = '';
            $name = '';
            $foreign_key = '';
            foreach ($table_names as $table_name) {
                $table_info =& $this->_getTableInfo($table_name);
                $rowset = new CB_RowSet($table_info);

                // grn_schedule_access_OBJECT_TARGETという形式でくるので、
                // 文字列操作でobjectとtargetに分割
                // ただしobjectはschedule_access_OBJECTという形で渡す必要がある
                $object_target = substr($table_name,
                    strlen('grn_schedule_access_'));
                $object_index = strpos($object_target, '_');
                $object = substr($object_target, 0, $object_index);
                $target = substr($object_target, strlen($object) + 1);
                $object = 'schedule_access_' . $object;
                $this->_addUserJoin($rowset, $object, $target);

                $rowset->addCondition($rowset->queryf("col_object = '@S'",
                    $id));
                $rowset->addOrderColumn('col_target');

                while ( ! is_null($row = $rowset->iterate())) {
                    $line = [];
                    $object = $row->get('object');
                    $target = $row->get('target');

                    // 最初だけセキュリティモデルの出力
                    if ($object_id != $id) {
                        $object_id = $id;
                        $security_model = $this->getSecurityModel($object);

                        $foreign_key = $object->get('foreign_key');
                        if (is_a($object, 'CB_User')) {
                            $object_type = 'user';
                        } elseif (is_a($object, 'CB_Role')) {
                            $object_type = 'role';
                        } elseif (is_a($object, 'CB_Group')) {
                            $object_type = 'group';
                        } elseif (is_a($object, 'GRN_Facility_Facility')) {
                            $object_type = 'facility';
                        } elseif (is_a($object, 'GRN_Facility_FacilityGroup')) {
                            $object_type = 'facilitygroup';
                        } else {
                            continue;
                        }

                        $line[] = $object_type;
                        $line[] = $foreign_key;
                        $line[] = 'security_model';
                        $line[] = $security_model;
                        $line[] = '';

                        $writer->writeLine($line);
                        $line = [];
                    }
                    $line[] = $object_type;
                    $line[] = $foreign_key;

                    $target_type = '';
                    // 設定項目
                    if (is_a($target, 'CB_User')) {
                        $target_name = $target->get('foreign_key');
                        $target_type = 'user';
                    } elseif (is_a($target, 'CB_Role')) {
                        $target_name = $target->get('foreign_key');
                        $target_type = 'role';
                    } elseif (is_a($target, 'CB_Group')) {
                        $target_name = $target->get('foreign_key');
                        $target_type = 'group';
                    } else {
                        $target_name = $target;
                        $target_type = 'dynamic_role';
                    }
                    $line[] = $target_type;

                    $access = '';
                    // 設定値
                    $autority = $row->get('authority_read');
                    if ($security_model == 'grant' && $autority) {
                        $access .= 'R';
                    } elseif ($security_model == 'revoke' && $autority == 0) {
                        $access .= 'R';
                    }

                    $autority = $row->get('authority_add');
                    if ($security_model == 'grant' && $autority) {
                        $access .= 'A';
                    } elseif ($security_model == 'revoke' && $autority == 0) {
                        $access .= 'A';
                    }

                    $autority = $row->get('authority_modify');
                    if ($security_model == 'grant' && $autority) {
                        $access .= 'M';
                    } elseif ($security_model == 'revoke' && $autority == 0) {
                        $access .= 'M';
                    }

                    $autority = $row->get('authority_delete');
                    if ($security_model == 'grant' && $autority) {
                        $access .= 'D';
                    } elseif ($security_model == 'revoke' && $autority == 0) {
                        $access .= 'D';
                    }

                    $line[] = $access;

                    // 設定対象
                    $line[] = $target_name;
                    $writer->writeLine($line);
                }
            }
        }
    }


    /**
     * @access private
     */
    function _getSecurityModelById($object_id, $object_type)
    {
        $db = $this->_getDBConnection();

        $query
            = 'SELECT col_security_model FROM tab_grn_schedule_securitymodel';
        if (strcmp($object_type, 'user') == 0) {
            $query .= ' INNER JOIN tab_cb_user AS u ON tab_grn_schedule_securitymodel.col_user = u._id';
            $query .= ' AND u.col_deleted IS NULL';
        }
        $query .= ' WHERE ';

        $list = null;
        // 一度評価してあればそれを利用する
        switch ($object_type) {
            case 'user':
                if (is_array($this->_user_securitymodels)
                    && array_key_exists($object_id, $this->_user_securitymodels)
                ) {
                    return $this->_user_securitymodels[$object_id];
                } elseif ( ! is_array($this->_user_securitymodels)) {
                    $this->_user_securitymodels = [];
                }
                $list = &$this->_user_securitymodels;

                $query .= cb_queryf($db, "col_user = '@S'", $object_id);

                break;
            case 'group':
                if (is_array($this->_group_securitymodels)
                    && array_key_exists($object_id,
                        $this->_group_securitymodels)
                ) {
                    return $this->_group_securitymodels[$object_id];
                } elseif ( ! is_array($this->_group_securitymodels)) {
                    $this->_group_securitymodels = [];
                }
                $list = &$this->_group_securitymodels;

                $query .= cb_queryf($db, "col_group = '@S'", $object_id);
                break;
            case 'role':
                if (is_array($this->_role_securitymodels)
                    && array_key_exists($object_id, $this->_role_securitymodels)
                ) {
                    return $this->_role_securitymodels[$object_id];
                } elseif ( ! is_array($this->_role_securitymodels)) {
                    $this->_role_securitymodels = [];
                }
                $list = &$this->_role_securitymodels;

                $query .= cb_queryf($db, "col_role = '@S'", $object_id);
                break;
            case 'facility':
                if (is_array($this->_facility_securitymodels)
                    && array_key_exists($object_id,
                        $this->_facility_securitymodels)
                ) {
                    return $this->_facility_securitymodels[$object_id];
                } elseif ( ! is_array($this->_facility_securitymodels)) {
                    $this->_facility_securitymodels = [];
                }
                $list = &$this->_facility_securitymodels;

                $query .= cb_queryf($db, "col_facility = '@S'", $object_id);
                break;
            case 'facilitygroup':
                if (is_array($this->_facilitygroup_securitymodels)
                    && array_key_exists($object_id,
                        $this->_facilitygroup_securitymodels)
                ) {
                    return $this->_facilitygroup_securitymodels[$object_id];
                } elseif ( ! is_array($this->_facilitygroup_securitymodels)) {
                    $this->_facilitygroup_securitymodels = [];
                }
                $list = &$this->_facilitygroup_securitymodels;

                $query .= cb_queryf($db, "col_facilitygroup = '@S'",
                    $object_id);
                break;
            default:
                return false;
        }

        // セキュリティモデルのテーブルから持ってくる
        $query = $db->select_format($query, 0, -1, CB_DATABASE_NO_LOCK);
        $result = $db->query($query);
        if ($result === false) {
            $db->throwError(['query' => 'failed query on SELECT: ' . $query]);
        }

        $security_model = null;
        while ($row = $db->fetch_assoc($result)) {
            $security_model = $row['col_security_model'];
        }
        // 結果の開放
        $db->free_result($result);

        if (is_null($security_model)) {
            $list[$object_id] = $this->_getDefaultSecurityModel();
        } else {
            $list[$object_id] = $security_model;
        }

        return $list[$object_id];
    }

    /**
     * アクセス権が許可されたオブジェクトを返す
     *  $authorities の操作をできるオブジェクトだけを返す
     *
     * @param   CB_User $user          ユーザー
     * @param   mixed   $objects       評価対象
     * @param   array   $authorities   操作
     * @param   array   $dynamic_roles ダイナミックロール
     * @param   string  $object_type   評価対象の種類
     * @param   bool    $lax_evaluate
     *
     * @return  array
     */
    function evaluateAccessesById(
        $user,
        $objects,
        $authorities,
        $dynamic_roles,
        $object_type,
        $id_only = false,
        $lax_evaluate = false
    ) {
        if ( ! is_array($objects)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_OBJECT);
        }
        if (0 === count($objects)) {
            return [];
        }
        if ( ! is_object($user) || ! is_a($user, 'cb_user')) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_USER_ID);
        }

        // 利用するキャッシュの準備
        $authorities_type = implode('_', $authorities);
        if ($lax_evaluate) {
            $authorities_type .= self::SUFFIX_FOR_LAX_AUTHORITY_TYPE;
        }

        $deny_cache_list = null;
        $permit_cache_list = null;
        switch ($object_type) {
            case 'user':
                if ( ! array_key_exists($authorities_type,
                    $this->_deny_users_list)
                ) {
                    $this->_deny_users_list[$authorities_type] = [];
                    $this->_permit_users_list[$authorities_type] = [];
                    // ログインユーザーをデフォルトONにしておく
                    if (is_object($user)) {
                        $this->_permit_users_list[$authorities_type][$user->getOID()]
                            = &$user;
                    }
                }
                $deny_cache_list = &$this->_deny_users_list[$authorities_type];
                $permit_cache_list
                    = &$this->_permit_users_list[$authorities_type];
                break;
            case 'group':
                if ( ! array_key_exists($authorities_type,
                    $this->_deny_groups_list)
                ) {
                    $this->_deny_groups_list[$authorities_type] = [];
                    $this->_permit_groups_list[$authorities_type] = [];
                }
                $deny_cache_list = &$this->_deny_groups_list[$authorities_type];
                $permit_cache_list
                    = &$this->_permit_groups_list[$authorities_type];
                break;
            case 'role':
                if ( ! array_key_exists($authorities_type,
                    $this->_deny_roles_list)
                ) {
                    $this->_deny_roles_list[$authorities_type] = [];
                    $this->_permit_roles_list[$authorities_type] = [];
                }
                $deny_cache_list = &$this->_deny_roles_list[$authorities_type];
                $permit_cache_list
                    = &$this->_permit_roles_list[$authorities_type];
                break;
            case 'facility':
                if ( ! array_key_exists($authorities_type,
                    $this->_deny_facilities_list)
                ) {
                    $this->_deny_facilities_list[$authorities_type] = [];
                    $this->_permit_facilities_list[$authorities_type] = [];
                }
                $deny_cache_list
                    = &$this->_deny_facilities_list[$authorities_type];
                $permit_cache_list
                    = &$this->_permit_facilities_list[$authorities_type];
                break;
            case 'facilitygroup':
                if ( ! array_key_exists($authorities_type,
                    $this->_deny_facility_groups_list)
                ) {
                    $this->_deny_facility_groups_list[$authorities_type] = [];
                    $this->_permit_facility_groups_list[$authorities_type] = [];
                }
                $deny_cache_list
                    = &$this->_deny_facility_groups_list[$authorities_type];
                $permit_cache_list
                    = &$this->_permit_facility_groups_list[$authorities_type];
                break;
        }

        $this->_initilize($user);

        $rows = [];
        if ($id_only) {
            foreach ($objects as $object_id) {
                // 既に評価しているアクセス権のチェックリストからアクセスできないものを除く
                if (array_key_exists($object_id, $deny_cache_list)) {
                    continue;
                }

                $rows[$object_id] = $object_id;
            }
        } else {
            foreach (array_keys($objects) as $key) {
                $object_id = $key;

                // 既に評価しているアクセス権のチェックリストからアクセスできないものを除く
                if (array_key_exists($object_id, $deny_cache_list)) {
                    continue;
                }

                $rows[$object_id] = $object_id;
            }
        }

        $rows = $this->_getAllowMultiObjects($user, $rows, $object_type,
            $authorities, $dynamic_roles, $this->_user_groups,
            $this->_user_roles, $deny_cache_list, $permit_cache_list,
            $lax_evaluate);

        if ($id_only) {
            foreach ($objects as $key => $object_id) {
                if ( ! array_key_exists($object_id, $rows)) {
                    unset($objects[$key]);
                }
            }
        } else {
            foreach (array_keys($objects) as $key) {
                if ( ! array_key_exists($key, $rows)) {
                    unset($objects[$key]);
                }
            }
        }

        return $objects;
    }


    /**
     * 一括してセキュリティモデルの取得を行う関数
     *
     * @access private
     */
    function _getSecurityModels($members, $member_type)
    {
        if ( ! is_array($members) || count($members) === 0) {
            return false;
        }

        $member_target = '';
        switch ($member_type) {
            case 'user':
                $member_target = 'col_user';
                if ( ! is_array($this->_user_securitymodels)) {
                    $this->_user_securitymodels = [];
                }
                $list = &$this->_user_securitymodels;
                break;
            case 'group':
                $member_target = 'col_group';
                if ( ! is_array($this->_group_securitymodels)) {
                    $this->_group_securitymodels = [];
                }
                $list = &$this->_group_securitymodels;
                break;
            case 'role':
                $member_target = 'col_Role';
                if ( ! is_array($this->_role_securitymodels)) {
                    $this->_role_securitymodels = [];
                }
                $list = &$this->_role_securitymodels;
                break;
            case 'facility':
                $member_target = 'col_facility';
                if ( ! is_array($this->_facility_securitymodels)) {
                    $this->_facility_securitymodels = [];
                }
                $list = &$this->_facility_securitymodels;
                break;
            case 'facilitygroup':
                $member_target = 'col_facilitygroup';
                if ( ! is_array($this->_facilitygroup_securitymodels)) {
                    $this->_facilitygroup_securitymodels = [];
                }
                $list = &$this->_facilitygroup_securitymodels;
                break;
            default:
                return false;
        }

        $db = $this->_getDBConnection();

        $retval = [];
        $object_array = [];
        foreach (array_keys($members) as $key) {
            // 評価済みは取得しない
            if (array_key_exists($key, $list)) {
                $retval[$key] = $list[$key];
                continue;
            }
            $object_array[] = cb_queryf($db, "'@S'", $key);
        }

        // 取得するものがない場合は、既にあるリストを返す
        if (count($object_array) === 0) {
            return $retval;
        }

        $objects_str = implode(',', $object_array);

        $join = '';
        if (strcmp($member_type, 'user') == 0) {
            $join .= 'INNER JOIN tab_cb_user AS u ON tab_grn_schedule_securitymodel.col_user = u._id';
            $join .= ' AND u.col_deleted IS NULL';
        }

        if (count($object_array) === 1) {
            $query = 'SELECT col_security_model, ' . $member_target
                     . ' FROM tab_grn_schedule_securitymodel ' . $join
                     . ' WHERE ( ' . $member_target . ' = ' . $objects_str
                     . ' )';
        } else {
            $query = 'SELECT col_security_model, ' . $member_target
                     . ' FROM tab_grn_schedule_securitymodel ' . $join
                     . ' WHERE ( ' . $member_target . ' IN (' . $objects_str
                     . ') )';
        }

        $query = $db->select_format($query, 0, -1, CB_DATABASE_NO_LOCK);

        $result = $db->query($query);
        if ($result === false) {
            $db->throwError(['query' => 'failed query on SELECT: ' . $query]);
        }

        $default_model = $this->_getDefaultSecurityModel();
        while ($row = $db->fetch_assoc($result)) {
            $retval[$row[$member_target]] = $row['col_security_model'];
            $list[$row[$member_target]] = $row['col_security_model'];
        }
        $db->free_result($result);

        // DBに設定されていないデータの設定
        foreach (array_keys($members) as $key) {
            if (array_key_exists($key, $retval)) {
                continue;
            }

            $retval[$key] = $default_model;
            $list[$key] = $default_model;
        }

        return $retval;
    }

    /**
     * 評価したアクセス権の結果を取得する
     *  getEvaluateAccessListを複数のオブジェクトに対してできる
     *
     * @param   CB_User $user          ユーザー
     * @param   array   $objects       評価対象
     * @param           $object_type
     * @param   array   $authorities   操作
     * @param   array   $dynamic_roles ダイナミックロール
     *
     * @return  array       評価したリスト
     */
    function getEvaluateAccessesListById(
        $user,
        $objects,
        $object_type,
        $authorities,
        $dynamic_roles
    ) {
        if ( ! is_array($objects)) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_OBJECT);
        }
        if (0 === count($objects)) {
            return [];
        }
        if ( ! is_object($user) || ! is_a($user, 'CB_User')) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_USER_ID);
        }

        $this->_initilize($user);

        $authority_type = implode('_', $authorities);

        $list = $this->_evaluateEventMembersAccessById($user,
            $objects,
            $object_type,
            $authorities,
            $authority_type,
            $dynamic_roles,
            $this->_user_groups,
            $this->_user_roles);

        return $list;
    }

    /**
     * 指定されたObjectsの中でアクセス権が設定されているものだけ返す
     * アクセス権が設定されているというのは以下のどちらかの状態を指す
     *
     * 1. セキュリティモデルがデフォルトのREVOKEでない(GRANT)
     * 2. 1つ以上のアクセス権設定レコードが存在する
     *
     * @param CB_User $user        評価対象ユーザー
     * @param array   $objects     対象のオブジェクトリスト
     * @param string  $object_type 対象オブジェクトタイプ
     * @param         $dynamic_roles
     *
     * @return array アクセス権設定のあるオブジェクトリスト
     */
    function getHaveAccessSettingList(
        $user,
        & $objects,
        $object_type,
        $dynamic_roles
    ) {
        if ( ! is_object($user) || ! is_a($user, 'CB_User')) {
            cb_throw_error(E_GRN_SCHD_ACCESS_INVALID_USER_ID);
        }

        if ( ! is_array($objects) || count($objects) == 0) {
            return [];
        }

        $user_id = $user->getOID();

        // キャッシュを取得
        $cache_list = [];
        switch ($object_type) {
            case 'user':
                if (array_key_exists($user_id, $this->_have_setting_user_list)
                    === false
                ) {
                    $this->_have_setting_user_list[$user_id] = [];
                }
                $cache_list = &$this->_have_setting_user_list[$user_id];
                break;
            case 'group':
                if (array_key_exists($user_id, $this->_have_setting_group_list)
                    === false
                ) {
                    $this->_have_setting_group_list[$user_id] = [];
                }
                $cache_list = &$this->_have_setting_group_list[$user_id];
                break;
            case 'role':
                if (array_key_exists($user_id, $this->_have_setting_role_list)
                    === false
                ) {
                    $this->_have_setting_role_list[$user_id] = [];
                }
                $cache_list = &$this->_have_setting_role_list[$user_id];
                break;
            case 'facility':
                if (array_key_exists($user_id,
                        $this->_have_setting_facility_list) === false
                ) {
                    $this->_have_setting_facility_list[$user_id] = [];
                }
                $cache_list = &$this->_have_setting_facility_list[$user_id];
                break;
            case 'facilitygroup':
                if (array_key_exists($user_id,
                        $this->_have_setting_facilitygroup_list) === false
                ) {
                    $this->_have_setting_facilitygroup_list[$user_id] = [];
                }
                $cache_list
                    = &$this->_have_setting_facilitygroup_list[$user_id];
                break;
        }

        $have_setting_objects = [];

        // キャッシュから検索済みのオブジェクトを取得
        $nocache_objects = [];
        foreach (array_keys($objects) as $key) {
            if (array_key_exists($key, $cache_list)) {
                if ($cache_list[$key] !== false) {
                    $have_setting_objects[$key] = &$cache_list[$key];
                }
                continue;
            }
            $nocache_objects[$key] = &$objects[$key];
        }

        // 全てキャッシュされていたらそのまま返す
        if (count($nocache_objects) <= 0) {
            return $have_setting_objects;
        }

        // 1. セキュリティモデルがGRANTならアクセス権設定されている

        if ($object_type === 'facility') // 評価するオブジェクトが施設
        {
            require_once('schedule/facility_system_logic.csp');
            $fsl = GRN_Facility_SystemLogic::getInstance();

            // まず、施設についてアクセス権をチェック
            $security_models = $this->_getSecurityModels($nocache_objects,
                $object_type);
            foreach ($security_models as $key => $security_model) {
                if ($security_model == GRN_SCHD_SECURITY_MODEL_TYPE_GRANT) {
                    $cache_list[$key] = $nocache_objects[$key];
                    $have_setting_objects[$key] = &$cache_list[$key];
                    unset($nocache_objects[$key]);
                }
            }

            // 全てアクセス権を持っていることになったら、その時点で返す
            if (count($nocache_objects) <= 0) {
                return $have_setting_objects;
            }

            // 次に、属する施設グループをたどってアクセス権をチェック
            $fg_map = $fsl->getFacilityGroupRelation($nocache_objects);
            foreach (array_keys($nocache_objects) as $key) {
                if (is_null($fg_map[$key])) {
                    unset($fg_map[$key]);
                }
            }
            $fg_ids = array_unique(array_values($fg_map));

            $tmp_array = [];
            foreach ($fg_ids as $id) {
                $tmp_array[$id] = $id;
            }
            $tree =& $this->makeFacilityGroupTree($tmp_array);

            $not_all_revoke_facility_groups
                = $this->_getNotAllRevokeFacilityGroups($fg_ids);

            foreach (array_keys($nocache_objects) as $key) {
                if (array_key_exists($key, $fg_map)) {
                    $fagid = $fg_map[$key];
                    if (array_search($fagid, $not_all_revoke_facility_groups)
                        != false
                    ) {
                        $cache_list[$key] = $nocache_objects[$key];
                        $have_setting_objects[$key] = &$cache_list[$key];
                        unset($nocache_objects[$key]);
                    }
                }
            }
        } elseif ($object_type === 'facilitygroup') // 評価するオブジェクトが施設グループ
        {
            require_once('schedule/facility_system_logic.csp');
            $fsl = GRN_Facility_SystemLogic::getInstance();
            $tree =& $this->makeFacilityGroupTree($nocache_objects);

            $not_all_revoke_facility_groups
                = $this->_getNotAllRevokeFacilityGroups(array_keys($nocache_objects));

            foreach ($not_all_revoke_facility_groups as $id) {
                $cache_list[$id] = $nocache_objects[$id];
                $have_setting_objects[$id] = &$cache_list[$id];
                unset($nocache_objects[$id]);
            }

        } else  // その他
        {
            $security_models = $this->_getSecurityModels($nocache_objects,
                $object_type);
            foreach ($security_models as $key => $security_model) {
                if ($security_model == GRN_SCHD_SECURITY_MODEL_TYPE_GRANT) {
                    $cache_list[$key] = $nocache_objects[$key];
                    $have_setting_objects[$key] = &$cache_list[$key];
                    unset($nocache_objects[$key]);
                }
            }
        }

        // キャッシュされていないオブジェクトが全てGRANTならそのまま返す
        if (count($nocache_objects) <= 0) {
            return $have_setting_objects;
        }

        // 2. アクセス権レコードが存在したらアクセス権が設定されている
        $targets_list = [];
        $db = $this->_getDBConnection();

        global $G_container_base;
        $uum = $G_container_base->getInstance('uum');

        // CB_Userからuidを取得しているので、第2引数にTRUEを渡して削除フラグチェックを行わない
        $user_groups = $uum->getUserGroupsInfo($user_id, true);
        $user_roles = $uum->getUserRolesInfo($user_id, true);

        // ダイナミックロールを取得する
        if (is_array($dynamic_roles) && count($dynamic_roles) > 0) {
            $target_array = [];
            foreach (array_keys($dynamic_roles) as $key) {
                $target_array[] = cb_queryf($db, "'@S'", $key);
            }
            $targets_list[GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE] = implode(',',
                $target_array);
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE] = null;
        }

        // スタティックロールを取得する
        if (false === $user_roles) {
            return false;
        }
        if (is_array($user_roles) && count($user_roles) > 0) {
            $target_array = [];
            foreach (array_keys($user_roles) as $key) {
                $target_array[] = cb_queryf($db, "'@S'", $key);
            }
            $targets_list[GRN_SCHD_TARGET_TYPE_STATIC_ROLE] = implode(',',
                $target_array);
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_STATIC_ROLE] = null;
        }

        // 組織を取得する
        if (false === $user_groups) {
            return false;
        }
        if (is_array($user_groups) && count($user_groups) > 0) {
            $target_array = [];
            foreach (array_keys($user_groups) as $key) {
                $target_array[] = cb_queryf($db, "'@S'", $key);
            }
            $targets_list[GRN_SCHD_TARGET_TYPE_GROUP] = implode(',',
                $target_array);
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_GROUP] = null;
        }

        // ユーザーを取得する
        $targets_list[GRN_SCHD_TARGET_TYPE_USER] = (string)$user_id;

        $object_id = 'schedule_access_' . $object_type;
        $target_tables =& $this->_target_tables;


        if ($object_id === 'schedule_access_facilitygroup') // 施設グループの場合
        {
            $access_facility_groups
                = $this->getAccessSetFacilityGroups(array_keys($nocache_objects),
                $targets_list);

            foreach ($access_facility_groups as $id) {
                $cache_list[$id] = $nocache_objects[$id];
                $have_setting_objects[$id] = &$cache_list[$id];
                unset($nocache_objects[$id]);
            }
        } else {
            $object_str = "";
            foreach (array_keys($nocache_objects) as $key) {
                $object_str .= cb_queryf($db, "'@S',", $key);
            }
            $object_str = substr($object_str, 0, strlen($object_str) - 1);

            // アクセス権レコードを探す
            foreach ($target_tables as $target_id => $target_table) {
                if (is_null($targets_list[$target_id])
                    || 0 === count($targets_list[$target_id])
                ) {
                    continue;
                }

                $targets = &$targets_list[$target_id];

                $table_name = $this->_getTableName($object_id, $target_id,
                    true);

                // $targets_list['user'] には、CB_Userから取得した値しか入らないので、削除フラグチェックを
                // 行う必要はない。
                // なので、objectの削除フラグチェックだけを行う。
                $join = '';
                if (strcmp($object_type, 'user') == 0) {
                    $join .= ' INNER JOIN tab_cb_user AS ou ON tab_'
                             . $table_name
                             . '.col_object = ou._id AND ou.col_deleted IS NULL';
                }
                $query = 'SELECT col_object FROM tab_' . $table_name . $join
                         . ' WHERE ( ' .
                         '( col_object IN (' . $object_str . ') )' .
                         ' AND ' .
                         '( col_target IN ( ' . $targets_list[$target_id]
                         . ' ) ) )';

                $query = $db->select_format($query);

                $result = $db->query($query);
                if ($result === false) {
                    $db->throwError([
                        'query' => 'failed query on SELECT: ' . $query
                    ]);
                }

                // 設定が見つかったオブジェクトを取得する
                while ($row = $db->fetch_assoc($result)) {
                    $_object_id = $row['col_object'];
                    if (array_key_exists($_object_id, $have_setting_objects)
                        === true
                    ) {
                        continue;
                    }

                    $cache_list[$_object_id] = $nocache_objects[$_object_id];
                    $have_setting_objects[$_object_id]
                        = &$cache_list[$_object_id];
                    unset($nocache_objects[$_object_id]);

                    // 途中で全てのオブジェクトに設定があるとわかったら返す
                    if (count($nocache_objects) <= 0) {
                        return $have_setting_objects;
                    }

                    // 設定があることがわかったオブジェクトを除いて条件文を再構築する
                    $object_str = "";
                    foreach (array_keys($nocache_objects) as $key) {
                        $object_str .= cb_queryf($db, "'@S',", $key);
                    }
                    $object_str = substr($object_str, 0,
                        strlen($object_str) - 1);
                }
                // 結果の開放
                $db->free_result($result);

                if ($object_id === 'schedule_access_facility') {
                    foreach (array_keys($nocache_objects) as $key) {
                        $tmp = $fsl->getFacilityAffiliationGroup($key);
                        if ($tmp) {
                            $fg_map[$key] = $tmp->getOID();
                        }
                    }
                    $fg_ids = array_unique(array_values($fg_map));
                    $group_access = $this->getAccessSetFacilityGroups($fg_ids,
                        $targets_list);

                    foreach (array_keys($nocache_objects) as $key) {
                        if (array_key_exists($key, $fg_map)) {
                            if (array_search($fg_map[$key], $group_access)
                                != false
                            ) {
                                $cache_list[$key] = $nocache_objects[$key];
                                $have_setting_objects[$key]
                                    = &$cache_list[$key];
                                unset($nocache_objects[$key]);
                            }
                        }
                    }
                }
            }
        }

        // 設定が見つからなかったオブジェクトはFALSEでキャッシュする
        foreach (array_keys($nocache_objects) as $key) {
            $cache_list[$key] = false;
        }

        return $have_setting_objects;
    }

    /**
     * 指定された施設が所属する施設グループのアクセス権を評価して施設のアクセス権として返す
     *
     * @param CB_User $user          評価対象ユーザー
     * @param CB_User $facilities    アクセス対象施設リスト
     * @param array   $authorities   評価アクション
     * @param array   $dynamic_roles ダイナミックロール
     * @param string  $type
     *
     * @return array
     */
    function getFacilityGroupAccessList(
        $user,
        & $facilities,
        $authorities,
        $dynamic_roles,
        $type = 'facility'
    ) {
        if ( ! is_array($facilities) || count($facilities) <= 0) {
            return [];
        }
        assert('$type == "facility"');

        require_once('schedule/facility_system_logic.csp');
        $facility_logic = GRN_Facility_SystemLogic::getInstance();

        $fgroups = [];
        $fgroup_map = [];

        $db = $this->_getDBConnection();

        $target_array = [];
        foreach (array_keys($facilities) as $key) {
            $target_array[] = $key;
        }

        // 施設が属する施設グループを取得
        $query = cb_queryf($db,
            "SELECT col_facility, col_group FROM tab_grn_facility_facilitygrouprelation WHERE col_facility IN (@A);",
            $target_array);
        $result = $db->query($query);
        while ($row = $db->fetch_assoc($result)) {
            if ( ! array_key_exists($row['col_group'], $fgroups)) {
                $fgroups[$row['col_group']]
                    = $facility_logic->getFacilityGroup($row['col_group']);
            }
            $fgroup_map[$row['col_facility']]
                = $fgroups[$row['col_group']]->getOID();
        }

        $tree =& $this->makeFacilityGroupTree($fgroups);

        $db->free_result($result);

        $all_facility_groups = [];
        foreach (array_keys($fgroups) as $key) {
            $tmp_fagid = $key;
            while ( ! is_null($tmp_fagid)) {
                $all_facility_groups[intval($tmp_fagid)] = intval($tmp_fagid);
                $tmp_fagid = $tree[$tmp_fagid];
            }
        }

        // 施設グループに所属していない施設
        foreach (array_keys($facilities) as $faid) {
            if ( ! array_key_exists($faid, $fgroup_map)) {
                $fgroup_map[$faid] = 0;
            }
        }

        $acc_lists = [];
        if (count($all_facility_groups) > 0) {
            // アクセス権の設定がある施設グループのみ評価する
            $have_settings = $this->getHaveAccessSettingList($user,
                $all_facility_groups, 'facilitygroup', $dynamic_roles);
            if (count($have_settings) > 0) {
                $_accesses = $this->getEvaluateAccessesListById($user,
                    $have_settings,
                    'facilitygroup',
                    $authorities,
                    $dynamic_roles);

                if (is_array($_accesses) && count($_accesses) > 0) {
                    foreach (array_keys($facilities) as $faid) {
                        $array_lists[$faid] = [];
                        if ($fgroup_map[$faid] == 0) {
                            continue;
                        }

                        $tmp_id = $fgroup_map[$faid];
                        $parent_groups = [];
                        while ( ! is_null($tmp_id)) {
                            $parent_groups[] = $tmp_id;
                            $tmp_id = $tree[$tmp_id];
                        }

                        $tmp_access_list = [];
                        foreach ($parent_groups as $key) {
                            if (array_key_exists($key, $_accesses)
                                === true
                            ) // アクセス権の設定がある
                            {
                                foreach ($authorities as $authority) {
                                    if (array_key_exists($authority,
                                        $tmp_access_list)
                                    ) {
                                        $tmp_access_list[$authority]
                                            = min($tmp_access_list[$authority],
                                            $_accesses[$key][$authority]);
                                    } else {
                                        $tmp_access_list[$authority]
                                            = $_accesses[$key][$authority];
                                    }
                                }
                            } else // アクセス権が設定がない == Revoke で個別の設定なし == 全部 OK
                            {
                                foreach ($authorities as $authority) {
                                    if ( ! array_key_exists($authority,
                                        $tmp_access_list)
                                    ) {
                                        $tmp_access_list[$authority]
                                            = GRN_SCHD_ACCESS_AFFIRM;
                                    }
                                }
                            }
                        }
                        if (count($tmp_access_list) > 0) {
                            $acc_lists[$faid] = $tmp_access_list;
                            unset($facilities[$faid]);
                        }
                    }
                }
            }
        }
        unset($fgroup, $fgroup_map);

        return $acc_lists;
    }

    /**
     * 指定された施設が所属する施設グループのアクセス権を評価して許可されている施設グループの所属組織のみを返す
     *
     * @param CB_User $user          評価対象ユーザー
     * @param CB_User $facilities    アクセス対象施設リスト
     * @param array   $authorities   評価アクション
     * @param array   $dynamic_roles ダイナミックロール
     *
     * @return array
     */
    function evaluateAccessesFacilityGroup(
        $user,
        & $facilities,
        $authorities,
        $dynamic_roles
    ) {
        if ( ! is_array($facilities) || count($facilities) <= 0) {
            return [];
        }

        require_once('schedule/facility_system_logic.csp');
        $facility_logic = GRN_Facility_SystemLogic::getInstance();

        $fgroups = [];
        $fgroup_map = [];

        $db = $this->_getDBConnection();

        $target_array = [];
        foreach (array_keys($facilities) as $faid) {
            $target_array[] = cb_queryf($db, "'@S'", $faid);
        }

        $query
            = 'SELECT col_facility, col_group FROM tab_grn_facility_facilitygrouprelation '
              .
              'WHERE col_facility IN (' . implode(',', $target_array)
              . ');';
        $result = $db->query($query);
        while ($row = $db->fetch_assoc($result)) {
            if ( ! array_key_exists($row['col_group'], $fgroups)) {
                $fgroups[$row['col_group']]
                    = &$facility_logic->getFacilityGroup($row['col_group']);
            }
            $fgroup_map[$row['col_facility']]
                = $fgroups[$row['col_group']]->getOID();
        }

        $db->free_result($result);


        // 施設グループの階層をリストで表現する
        $facility_group_hierarychy = [];
        $facility_groups_array = [];
        foreach (array_keys($fgroups) as $fgroup_id) {
            $facility_groups_array[] = cb_queryf($db, "'@S'", $fgroup_id);
        }
        while (sizeof($facility_groups_array) !== 0) {
            $query
                = 'SELECT col_parent, _id FROM tab_grn_facility_facilitygroup WHERE _id IN ('
                  .
                  implode(',', $facility_groups_array)
                  . ');';
            $result = $db->query($query);
            $flag_reach_root = true;
            $facility_groups_array = [];

            while ($row = $db->fetch_assoc($result)) {
                $facility_group_hierarchy[$row['_id']] = $row['col_parent'];
                $fgroups[$row['_id']]
                    = &$facility_logic->getFacilityGroup($row['_id']);

                if ( ! is_null($row['col_parent'])) {
                    $facility_groups_array[] = cb_queryf($db, "'@S'",
                        $row['col_parent']);
                }
            }
            $db->free_result($result);
        }

        // 施設グループに所属していない施設
        foreach (array_keys($facilities) as $faid) {
            if ( ! array_key_exists($faid, $fgroup_map)) {
                $fgroup_map[$faid] = 0;
            }
        }

        $evaluated = [];
        if (count($fgroups) > 0) {
            // アクセス権の設定がある施設グループのみ評価する
            $have_settings = $this->getHaveAccessSettingList($user, $fgroups,
                'facilitygroup', $dynamic_roles);
            if (count($have_settings) > 0) {
                $allows = $this->evaluateAccesses($user,
                    $have_settings,
                    $authorities,
                    $dynamic_roles,
                    'facilitygroup');

                // 評価済みの施設と評価していない(施設グループにアクセス権が設定されていない)施設を分ける
                foreach (array_keys($facilities) as $faid) {
                    $fgid = $fgroup_map[$faid];
                    if (array_key_exists($fgid, $have_settings) === true) {
                        if (array_key_exists($fgid, $allows) === true) {
                            $evaluated[$faid] = $facilities[$faid];
                        }
                        unset($facilities[$faid]);
                    }
                }
            }
        }
        unset($fgroup, $fgroup_map);

        return $evaluated;
    }

    /**
     * 指定された施設が所属する施設グループのアクセス権を評価して施設のアクセス権として返す
     *
     * @acccess private
     *
     * @param CB_User $user           評価対象ユーザー
     * @param array   $facilities     アクセス対象施設リスト
     * @param array   $authorities    評価アクション
     * @param array   $authority_type 評価タイプ
     * @param array   $dynamic_roles  ダイナミックロール
     * @param array   $user_groups    対象ユーザーグループ
     * @param array   $user_roles     対象ユーザーロール
     *
     * @return array
     */
    function _evaluateEventFacilitiesGroupsAccess(
        $user,
        & $facilities,
        $authorities,
        $authority_type,
        $dynamic_roles,
        $user_groups,
        $user_roles
    ) {
        if ( ! is_array($facilities) || count($facilities) <= 0) {
            return [];
        }

        require_once('schedule/facility_system_logic.csp');
        $facility_logic = GRN_Facility_SystemLogic::getInstance();

        $fgroups = [];
        $fgroup_map = [];

        $db = $this->_getDBConnection();

        $target_array = [];
        foreach (array_keys($facilities) as $key) {
            $facility = $facilities[$key];
            $target_array[] = cb_queryf($db, "'@S'", $facility->getOID());
        }

        $query
            = 'SELECT col_facility, col_group FROM tab_grn_facility_facilitygrouprelation '
              .
              'WHERE col_facility IN (' . implode(',', $target_array)
              . ');';
        $result = $db->query($query);
        while ($row = $db->fetch_assoc($result)) {
            if ( ! array_key_exists($row['col_group'], $fgroups)) {
                $fgroups[$row['col_group']]
                    = $facility_logic->getFacilityGroup($row['col_group']);
            }
            $fgroup_map[$row['col_facility']]
                = $fgroups[$row['col_group']]->getOID();
        }

        $db->free_result($result);
        unset($db);

        // 施設グループに所属していない施設
        foreach (array_keys($facilities) as $key) {
            $facility = $facilities[$key];
            // 2007/11/02:この関数はfacilities配列のキーに施設IDが入っていない
            $faid = $facility->getOID();
            if ( ! array_key_exists($faid, $fgroup_map)) {
                $fgroup_map[$faid] = 0;
            }
        }

        $acc_lists = [];
        if (count($fgroups) > 0) {
            // アクセス権の設定がある施設グループのみ評価する
            $have_settings = $this->getHaveAccessSettingList($user, $fgroups,
                'facilitygroup', $dynamic_roles);
            if (count($have_settings) > 0) {
                $_accesses = $this->_evaluateEventMembersAccessByID($user,
                    $have_settings,
                    'facilitygroup',
                    $authorities,
                    $authority_type,
                    $dynamic_roles,
                    $user_groups,
                    $user_roles);

                if (is_array($_accesses) && count($_accesses) > 0) {
                    foreach (array_keys($facilities) as $faid) {
                        $facility = $facilities[$faid];
                        $f_oid = $facility->getOID();
                        if (array_key_exists($fgroup_map[$f_oid], $_accesses)
                            === true
                        ) {
                            $fgid = $fgroup_map[$f_oid];
                            $acc_lists[$f_oid] = $_accesses[$fgid];
                            unset($facilities[$faid]);
                        }
                    }
                }
            }
        }
        unset($fgroup, $fgroup_map);

        return $acc_lists;
    }

    /**
     * 指定された施設が所属する施設グループのアクセス権を評価して施設のアクセス権として返す
     *
     * @acccess private
     *
     * @param CB_User $user             評価対象ユーザー
     * @param array   $facility_id_list アクセス対象施設IDリスト
     * @param array   $authorities      評価アクション
     * @param array   $authority_type   評価タイプ
     * @param array   $dynamic_roles    ダイナミックロール
     * @param array   $user_groups      対象ユーザーグループ
     * @param array   $user_roles       対象ユーザーロール
     *
     * @return array
     */
    function _evaluateEventFacilitiesGroupsAccessById(
        $user,
        & $facility_id_list,
        $authorities,
        $authority_type,
        $dynamic_roles,
        $user_groups,
        $user_roles
    ) {
        if ( ! is_array($facility_id_list) || count($facility_id_list) <= 0) {
            return [];
        }

        require_once('schedule/facility_system_logic.csp');
        $facility_logic = GRN_Facility_SystemLogic::getInstance();

        $fgroups = [];
        $fgroup_map = [];

        $db = $this->_getDBConnection();

        $target_array = [];
        foreach ($facility_id_list as $faid) {
            $target_array[] = cb_queryf($db, "'@S'", $faid);
        }

        $query
            = 'SELECT col_facility, col_group FROM tab_grn_facility_facilitygrouprelation '
              .
              'WHERE col_facility IN (' . implode(',', $target_array)
              . ');';
        $result = $db->query($query);
        while ($row = $db->fetch_assoc($result)) {
            if ( ! array_key_exists($row['col_group'], $fgroups)) {
                $fgroups[$row['col_group']]
                    = &$facility_logic->getFacilityGroup($row['col_group']);
            }
            $fgroup_map[$row['col_facility']]
                = $fgroups[$row['col_group']]->getOID();
        }

        $db->free_result($result);
        unset($db);

        // 施設グループに所属していない施設
        foreach ($facility_id_list as $faid) {
            if ( ! array_key_exists($faid, $fgroup_map)) {
                $fgroup_map[$faid] = 0;
            }
        }

        $acc_lists = [];
        if (count($fgroups) > 0) {
            // アクセス権の設定がある施設グループのみ評価する
            $have_settings = $this->getHaveAccessSettingList($user, $fgroups,
                'facilitygroup', $dynamic_roles);
            if (count($have_settings) > 0) {
                $_accesses = $this->_evaluateEventMembersAccessByID($user,
                    $have_settings,
                    'facilitygroup',
                    $authorities,
                    $authority_type,
                    $dynamic_roles,
                    $user_groups,
                    $user_roles);

                if (is_array($_accesses) && count($_accesses) > 0) {
                    foreach ($facility_id_list as $faid) {
                        if (array_key_exists($fgroup_map[$faid], $_accesses)
                            === true
                        ) {
                            $fgid = $fgroup_map[$faid];
                            $acc_lists[$faid] = $_accesses[$fgid];
                            unset($facility_id_list[$faid]);
                        }
                    }
                }
            }
        }
        unset($fgroup, $fgroup_map);

        return $acc_lists;
    }

    function _addUserJoin($rowset, & $object, & $target, $alias = '')
    {
        $user_table =& $this->_getTableInfo('CB_User');
        $is_force = false;
        if (is_string($target)
            && array_key_exists($target, $this->_target_tables)
        ) {
            $is_force = true;
        }

        // 対象のテーブル名にエイリアスを貼っていたらそれを使えるようにする
        if (is_string($alias) && strlen($alias) > 0) {
            $real_table_name = $alias;
        } else {
            $real_table_name = CB_DATABASE_TABLE_PREFIX .
                               $this->_getTableName($object, $target,
                                   $is_force);
        }

        if (is_object($object) && is_a($object, 'CB_User')) {
            $on = $real_table_name
                  . '.col_object = ou._id AND ou.col_deleted IS NULL';
            $rowset->addJoin($user_table, $on, CB_DATABASE_INNER_JOIN, 'ou');
        } elseif (is_string($object)
                  && strcasecmp('schedule_access_user', $object) == 0
        ) {
            $on = $real_table_name
                  . '.col_object = ou._id AND ou.col_deleted IS NULL';
            $rowset->addJoin($user_table, $on, CB_DATABASE_INNER_JOIN, 'ou');
        }

        if (is_object($target) && is_a($target, 'CB_User')) {
            $on = $real_table_name
                  . '.col_target = tu._id AND tu.col_deleted IS NULL';
            $rowset->addJoin($user_table, $on, CB_DATABASE_INNER_JOIN, 'tu');
        } elseif (is_string($target) && strcasecmp('user', $target) == 0) {
            $on = $real_table_name
                  . '.col_target = tu._id AND tu.col_deleted IS NULL';
            $rowset->addJoin($user_table, $on, CB_DATABASE_INNER_JOIN, 'tu');
        }
    }

    /**
     * 指定された施設グループのアクセス権を、親の施設グループまでだとって評価し、許可されている施設グループのみを返す
     *
     * @param CB_User $user          評価対象ユーザー
     * @param CB_User $facilities    アクセス対象施設リスト(キーを ID として使い、値は使わない)
     * @param array   $authorities   評価アクション
     * @param array   $dynamic_roles ダイナミックロール
     *
     * @return array
     */
    function _evaluateAccessesFacilityGroupGroup(
        $user,
        $facility_groups,
        $authorities,
        $dynamic_roles
    ) {
        if ( ! is_array($facility_groups) || count($facility_groups) <= 0) {
            return [];
        }

        require_once('schedule/facility_system_logic.csp');
        $facility_logic = GRN_Facility_SystemLogic::getInstance();

        $db = $this->_getDBConnection();

        $tree =& $this->makeFacilityGroupTree($facility_groups);

        $facility_groups_array = [];
        foreach (array_keys($facility_groups) as $key) {
            $tmp_key = $key;
            $counter = 0;
            while ( ! is_null($tmp_key)
                    && $counter <= GRN_SCHD_MAX_FACILITY_GROUP_TREE) {
                $facilitygroup = $facility_logic->getFacilityGroup($tmp_key);
                $facility_groups_array[$tmp_key] = ($facilitygroup === false)
                    ? null : $facilitygroup;
                $tmp_key = $tree[$tmp_key];
                $counter += 1;
            }
        }
        $evaluated = [];
        if (count($facility_groups_array) > 0) {
            // アクセス権の設定がある施設グループのみ評価する
            $have_settings = $this->getHaveAccessSettingList($user,
                $facility_groups_array, 'facilitygroup', $dynamic_roles);

            if (count($have_settings) > 0) {
                $allows = $this->evaluateAccesses($user,
                    $have_settings,
                    $authorities,
                    $dynamic_roles,
                    'facilitygroup');

                foreach (array_keys($facility_groups) as $fgid) {
                    $parent_groups = [];
                    $tmp_key = $key;
                    $counter = 0;
                    while ( ! is_null($tmp_key)
                            && $counter <= GRN_SCHD_MAX_FACILITY_GROUP_TREE) {
                        $parent_groups[] = $tmp_key;
                        $tmp_key = $tree[$tmp_key];
                        $counter += 1;
                    }

                    $allow_flag = true;
                    foreach ($parent_groups as $pg) {
                        if (array_key_exists($pg, $have_settings)
                            && ! array_key_exists($pg, $allows)
                        )// アクセス権がない
                        {
                            $allow_flag = false;
                            break;
                        }
                    }
                    if ($allow_flag) {
                        $evaluated[$fgid] = $facility_groups[$fgid];
                    }
                }
            }
        }

        return $evaluated;
    }

    /**
     * 施設グループのツリー情報のバッファを作る
     *
     * @param array $group_ids 施設グループ ID
     *
     * @return array|null
     */
    function& makeFacilityGroupTree($group_ids)
    {
        $db = $this->_getDBConnection();
        $tree =& $this->_facility_group_hierarchy;

        $rest = [];
        foreach (array_keys($group_ids) as $key) {
            if ( ! array_key_exists($key, $tree)) {
                $rest[$key] = 1; // 値は使わない
            }
        }

        while (count($rest) > 0) {
            $query_array = [];
            foreach (array_keys($rest) as $key) {
                $query_array[] = cb_queryf($db, '@S', $key);
            }
            $query
                = "SELECT _id, col_parent FROM tab_grn_facility_facilitygroup WHERE _id IN ("
                  . implode(',', $query_array) . ')';

            $result = $db->query($query);

            while ($row = $db->fetch_assoc($result)) {
                $tree[$row['_id']] = $row['col_parent'];
                unset($rest[$row['_id']]);
                if ( ! (is_null($row['col_parent'])
                        || array_key_exists($row['col_parent'], $tree))
                ) {
                    $rest[$row['col_parent']] = 1; // 値は使わない
                }
            }
            $db->free_result($result);
        }

        return $this->_facility_group_hierarchy;
    }

    /**
     * 施設グループのツリーをたどって、途中に GRANT なものを含む施設グループの ID のみを返す
     *
     * @param array $group_ids 施設グループ ID
     *
     * @return array 全て REVOKE な施設グループの ID
     */
    function _getNotAllRevokeFacilityGroups($group_ids)
    {
        $retval = [];
        $tree =& $this->_facility_group_hierarchy;

        // DB に問い合わせる必要がある施設グループをまとめる
        $all_facility_groups = [];
        foreach ($group_ids as $key) {
            $tmp_fagid = $key;
            while ( ! is_null($tmp_fagid)) {
                $all_facility_groups[intval($tmp_fagid)] = intval($tmp_fagid);
                $tmp_fagid = $tree[$tmp_fagid];
            }
        }

        $security_models = $this->_getSecurityModels($all_facility_groups,
            'facilitygroup');

        foreach ($group_ids as $fagid) {
            $parent_groups = [];
            $tmp_fagid = $fagid;
            while ( ! is_null($tmp_fagid)) {
                $parent_groups[] = $tmp_fagid;
                $tmp_fagid = $tree[$tmp_fagid];
            }


            // 1 つでも GRANT のものがあれば、そのオブジェクトは GRANT で、アクセス権があると見なす
            $grant_flag = false;
            foreach ($parent_groups as $id) {
                if ($security_models[$id]
                    == GRN_SCHD_SECURITY_MODEL_TYPE_GRANT
                ) {
                    $grant_flag = true;
                    break;
                }
            }
            if ($grant_flag) {
                $retval[] = $fagid;
            }
        }

        return $retval;
    }

    /**
     * 施設グループのツリーをたどって、どこかでアクセス権が設定されている施設グループの ID を返す
     *
     * @param array $group_ids グループのID
     * @param array $targets_list
     *
     * @return array
     */
    function getAccessSetFacilityGroups($group_ids, $targets_list)
    {
        $db = $this->_getDBConnection();
        $target_tables =& $this->_target_tables;
        $tree =& $this->_facility_group_hierarchy;
        $object_type = 'schedule_access_facilitygroup';

        $retval = [];
        $group_ids_key = [];

        // DB に問い合わせ
        foreach ($target_tables as $target_id => $target_table) {
            if (is_null($targets_list[$target_id])
                || 0 === count($targets_list[$target_id])
            ) {
                continue;
            }

            // DB に問い合わせる必要がある施設グループをまとめる
            $all_facility_groups = [];
            foreach ($group_ids as $key) {
                $tmp_fagid = $key;
                while ( ! is_null($tmp_fagid)) {
                    $all_facility_groups[$tmp_fagid] = $tmp_fagid;
                    $tmp_fagid = $tree[$tmp_fagid];
                }
            }

            $object_str = "";
            foreach (array_keys($all_facility_groups) as $key) {
                $object_str .= cb_queryf($db, "'@S',", $key);
            }
            $object_str = substr($object_str, 0, strlen($object_str) - 1);

            $targets = &$targets_list[$target_id];

            $table_name = $this->_getTableName($object_type, $target_id, true);

            // $targets_list['user'] には、CB_Userから取得した値しか入らないので、削除フラグチェックを
            // 行う必要はない。
            // なので、objectの削除フラグチェックだけを行う。
            $join = '';
            $query = 'SELECT col_object FROM tab_' . $table_name . $join
                     . ' WHERE ( ' .
                     '( col_object IN (' . $object_str . ') )' .
                     ' AND ' .
                     '( col_target IN ( ' . $targets_list[$target_id]
                     . ' ) ) )';

            $query = $db->select_format($query);

            $result = $db->query($query);
            if ($result === false) {
                $db->throwError([
                    'query' => 'failed query on SELECT: ' . $query
                ]);
            }
            // 設定が見つかったオブジェクトをキャッシュする
            $have_access_list = [];
            while ($row = $db->fetch_assoc($result)) {
                $have_access_list[] = $row['col_object'];
            }
            $db->free_result($result);

            foreach ($group_ids as $key) {
                $tmp_fagid = $key;
                while ( ! is_null($tmp_fagid)) {
                    if (array_search($tmp_fagid, $have_access_list)
                        !== false
                    ) // 設定があった
                    {
                        if (array_search($key, $retval) === false) {
                            $retval[] = $key;
                        }
                        break;
                    }
                    $tmp_fagid = $tree[$tmp_fagid];
                }
            }
            if (count($group_ids) == count($retval)) {
                return $retval;
            }
        }

        return $retval;
    }

    /**
     * 施設グループの階層をたどって、アクセスが許可されたオブジェクトを調べる(施設グループ専用)
     *
     * @param               $objects
     * @param               $targets_list
     * @param               $object_table
     * @param               $authorities
     * @param               $deny_cache_list
     * @param               $permit_cache_list
     * @param   bool        $lax_evaluate
     *
     * @return array
     */
    function _getAllowSingleObjectsFacilityGroup(
        $objects,
        $targets_list,
        $object_table,
        $authorities,
        &$deny_cache_list,
        &$permit_cache_list,
        $lax_evaluate = false
    ) {
        if (0 === count($objects)) {
            return [];
        }
        $tree =& $this->makeFacilityGroupTree($objects);
        $db = $this->_getDBConnection();
        $target_tables =& $this->_target_tables;

        $authority_count = count($authorities);
        $values_list = [];

        // DB に問い合わせる必要がある施設グループをまとめる
        $all_facility_groups = [];
        foreach (array_keys($objects) as $key) {
            $tmp_fagid = $key;
            while ( ! is_null($tmp_fagid)) {
                $all_facility_groups[intval($tmp_fagid)] = intval($tmp_fagid);
                $tmp_fagid = $tree[$tmp_fagid];
            }
        }

        // 問い合わせる必要がある施設グループのセキュリティモデルをキャッシュしておく
        $security_models = $this->_getSecurityModels($all_facility_groups,
            'facilitygroup');

        // 問い合わせ
        $objects_str = "";
        foreach (array_keys($all_facility_groups) as $object_id) {
            $objects_str .= cb_queryf($db, "'@S',", $object_id);
        }
        $objects_str = substr($objects_str, 0, strlen($objects_str) - 1);

        $temp_str = [];
        $read_authority_exist = false;
        foreach ($authorities as $authority) {
            $temp_str[] = 'col_authority_' . $authority;
            if ($authority == 'read') {
                $read_authority_exist = true;
            }
        }
        $authorities_str = implode(' OR ', $temp_str);

        foreach ($target_tables as $target_id => $target_table) {
            if (is_null($targets_list[$target_id])
                || 0 === count($targets_list[$target_id])
            ) {
                continue;
            }
            $targets =& $targets_list[$target_id];

            $table_name = $this->_getTableName($object_table, $target_id, true);

            // ユーザー削除フラグを確認
            $join = '';

            $query = 'SELECT * FROM tab_' . $table_name . $join
                     . ' WHERE ( ( col_object IN (' . $objects_str
                     . ') ) AND ( col_target IN (' . $targets_list[$target_id]
                     . ') ) AND ( ' . $authorities_str . ' ) )';

            $query = $db->select_format($query);

            $result = $db->query($query);
            if ($result === false) {
                $db->throwError([
                    'query' => 'failed query on SELECT: ' . $query
                ]);
            }

            $result_cache = [];

            while ($row = $db->fetch_assoc($result)) {
                $result_cache[$row['col_object']] = [];
                foreach ($authorities as $authority) {
                    $result_cache[$row['col_object']][$authority]
                        = $row['col_authority_' . $authority];
                }

                $object_id = $row['col_object'];

                // アクセス権の権限値の一覧を取得する
                if (array_key_exists($object_id, $values_list)) {
                    $values =& $values_list[$object_id];
                } else {
                    $values_list[$object_id] = [];
                    $values =& $values_list[$object_id];
                    foreach ($authorities as $authority) {
                        $values[$authority] = 0;
                    }
                }
                // アクセス権を評価する
                foreach ($authorities as $authority) {
                    $value = $row['col_authority_' . $authority];
                    $value = is_null($value) ? 0 : intval($value);
                    $value = max($values[$authority], $value);
                    $values[$authority] = $value;
                }
            }
            // 結果の開放
            $db->free_result($result);
        }

        $retval = [];

        foreach (array_keys($objects) as $object_id) {
            $parent_groups = [];
            $tmp_id = $object_id;
            while ( ! is_null($tmp_id)) {
                $parent_groups[] = $tmp_id;
                $tmp_id = $tree[$tmp_id];
            }

            foreach ($parent_groups as $gid) {
                $security_model = $security_models[$gid];

                $sum_authorities = 0;
                if (array_key_exists($gid, $values_list)) {
                    $sum_authorities = array_sum($values_list[$gid]);
                }

                if (array_key_exists($gid, $values_list)
                    && $authority_count == $sum_authorities
                ) // アクセス権の設定がある
                {
                    if ($security_model == GRN_SCHD_SECURITY_MODEL_TYPE_GRANT) {
                        $retval[$object_id] = &$objects[$object_id];
                    } else {
                        if (array_key_exists($object_id, $retval)) {
                            unset($retval[$object_id]);
                        }
                        break;
                    }
                } else // アクセス権の設定がない
                {
                    if ($security_model == GRN_SCHD_SECURITY_MODEL_TYPE_GRANT) {
                        $lax_grant_permit_condition = (($read_authority_exist
                                                        && $sum_authorities > 1)
                                                       || ( ! $read_authority_exist
                                                            && $sum_authorities
                                                               > 0));

                        if ($authority_count > 1 && $lax_evaluate
                            && $lax_grant_permit_condition
                        ) {
                            $retval[$object_id] = &$objects[$object_id];
                            continue;
                        }

                        if (array_key_exists($object_id, $retval)) {
                            unset($retval[$object_id]);
                        }
                        break;
                    } else {
                        $lax_revoke_deny_condition = ($read_authority_exist
                                                      && ($sum_authorities
                                                          == ($authority_count
                                                              - 1)));

                        if ($authority_count > 1 && $lax_evaluate
                            && $lax_revoke_deny_condition
                        ) {
                            break;
                        }

                        $retval[$object_id] = &$objects[$object_id];
                    }
                }
            }
        }

        foreach (array_keys($objects) as $key) {
            if (array_key_exists($key, $retval)) {
                $permit_cache_list[$key] = $key;
            } else // 拒否
            {
                $deny_cache_list[$key] = $key;
            }
        }

        return $retval;
    }

    /**
     * 施設グループの階層をたどって、アクセスが許可されたオブジェクトを調べる(施設専用)
     *
     * @param           $objects
     * @param           $targets_list
     * @param           $object_table
     * @param           $authorities
     * @param           $deny_cache_list
     * @param           $permit_cache_list
     * @param bool      $lax_evaluate
     *
     * @return array
     */
    function _getAllowSingleObjectsFacility(
        $objects,
        $targets_list,
        $object_table,
        $authorities,
        &$deny_cache_list,
        &$permit_cache_list,
        $lax_evaluate = false
    ) {
        if (0 === count($objects)) {
            return [];
        }
        require_once('schedule/facility_system_logic.csp');
        $fsl = GRN_Facility_SystemLogic::getInstance();

        $db = $this->_getDBConnection();
        $target_tables =& $this->_target_tables;

        $authority_count = count($authorities);
        $values_list = [];
        $security_models = $this->_getSecurityModels($objects, 'facility');

        $objects_str = "";
        foreach (array_keys($objects) as $object) {
            $objects_str .= cb_queryf($db, "'@S',", $object);
        }
        $objects_str = substr($objects_str, 0, strlen($objects_str) - 1);

        $temp_str = [];
        $read_authority_exist = false;
        foreach ($authorities as $authority) {
            $temp_str[] = 'col_authority_' . $authority;
            if ($authority == 'read') {
                $read_authority_exist = true;
            }
        }
        $authorities_str = implode(' OR ', $temp_str);

        foreach ($target_tables as $target_id => $target_table) {
            if (is_null($targets_list[$target_id])
                || 0 === count($targets_list[$target_id])
            ) {
                continue;
            }
            $targets =& $targets_list[$target_id];

            $table_name = $this->_getTableName($object_table, $target_id, true);

            // ユーザー削除フラグを確認
            $join = '';
            if (strcmp($target_id, 'user') == 0) {
                $join .= ' INNER JOIN tab_cb_user AS tu ON tab_' . $table_name
                         . '.col_target = tu._id AND tu.col_deleted IS NULL';
            }

            $query = 'SELECT * FROM tab_' . $table_name . $join
                     . ' WHERE ( ( col_object IN (' . $objects_str
                     . ') ) AND ( col_target IN (' . $targets_list[$target_id]
                     . ') ) AND ( ' . $authorities_str . ' ) )';

            $query = $db->select_format($query);

            $result = $db->query($query);
            if ($result === false) {
                $db->throwError([
                    'query' => 'failed query on SELECT: ' . $query
                ]);
            }

            while ($row = $db->fetch_assoc($result)) {
                $object_id = $row['col_object'];

                // アクセス権の権限値の一覧を取得する
                if (array_key_exists($object_id, $values_list)) {
                    $values =& $values_list[$object_id];
                } else {
                    $values_list[$object_id] = [];
                    $values =& $values_list[$object_id];
                    foreach ($authorities as $authority) {
                        $values[$authority] = 0;
                    }
                }
                // アクセス権を評価する
                foreach ($authorities as $authority) {
                    $value = $row['col_authority_' . $authority];
                    $value = is_null($value) ? 0 : intval($value);
                    $value = max($values[$authority], $value);
                    $values[$authority] = $value;
                }
            }
            // 結果の開放
            $db->free_result($result);
        }
        // 施設だけを見て、アクセス権があるものだけを $retval に残す

        $retval = [];
        foreach (array_keys($objects) as $object_id) {
            $security_model = $security_models[$object_id];

            $sum_authorities = 0;
            if (array_key_exists($object_id, $values_list)) {
                $sum_authorities = array_sum($values_list[$object_id]);
            }

            if (array_key_exists($object_id, $values_list)
                && $authority_count == $sum_authorities
            ) // アクセス権の設定がある
            {
                if ($security_model == GRN_SCHD_SECURITY_MODEL_TYPE_GRANT) {
                    $retval[$object_id] = &$objects[$object_id];
                } else {
                    if (array_key_exists($object_id, $retval)) {
                        unset($retval[$object_id]);
                    }
                }
            } else // アクセス権の設定がない
            {
                if ($security_model == GRN_SCHD_SECURITY_MODEL_TYPE_GRANT) {
                    $lax_grant_permit_condition = (($read_authority_exist
                                                    && $sum_authorities > 1)
                                                   || ( ! $read_authority_exist
                                                        && $sum_authorities
                                                           > 0));

                    if ($authority_count > 1 && $lax_evaluate
                        && $lax_grant_permit_condition
                    ) {
                        $retval[$object_id] = &$objects[$object_id];
                        continue;
                    }

                    if (array_key_exists($object_id, $retval)) {
                        unset($retval[$object_id]);
                    }

                } else {
                    $lax_revoke_deny_condition = ($read_authority_exist
                                                  && $sum_authorities > 0
                                                  && ($values_list[$object_id]['read']
                                                      == 1
                                                      || ($sum_authorities
                                                          == ($authority_count
                                                              - 1))));
                    if ($authority_count > 1 && $lax_evaluate
                        && $lax_revoke_deny_condition
                    ) {

                        continue;
                    }
                    $retval[$object_id] = &$objects[$object_id];
                }
            }
        }

        // 施設が属するグループを取得
        $fg_map = [];
        $fgroups = [];
        $isolated_facilities = [];

        $fg_map = $fsl->getFacilityGroupRelation($retval);
        foreach (array_keys($retval) as $fid) {
            if (is_null($fg_map[$fid])) {
                $isolated_facilities[$fid] =& $retval[$fid];
                unset($retval[$fid]);
                unset($fg_map[$fid]);
                continue;
            }
            $fgroups[$fg_map[$fid]] = $fg_map[$fid];
        }

        $authorities_type = implode('_', $authorities);
        if ($lax_evaluate) {
            $authorities_type .= self::SUFFIX_FOR_LAX_AUTHORITY_TYPE;
        }

        if ( ! array_key_exists($authorities_type,
            $this->_deny_facility_groups_list)
        ) {
            $this->_deny_facility_groups_list[$authorities_type] = [];
            $this->_permit_facility_groups_list[$authorities_type] = [];
        }
        $deny_facility_groups_cache_list
            = &$this->_deny_facility_groups_list[$authorities_type];
        $permit_facility_groups_cache_list
            = &$this->_permit_facility_groups_list[$authorities_type];

        $evaluated_groups = $this->_getAllowSingleObjectsFacilityGroup($fgroups,
            $targets_list,
            'schedule_access_facilitygroup',
            $authorities,
            $deny_facility_groups_cache_list,
            $permit_facility_groups_cache_list,
            $lax_evaluate);

        $evaluated_group_keys = array_keys($evaluated_groups);

        foreach (array_keys($retval) as $fid) {
            if (array_search($fg_map[$fid], $evaluated_group_keys) === false) {
                unset($retval[$fid]);
            }
        }

        return $retval + $isolated_facilities;
    }


    /**
     * 施設グループのアクセス権を、階層をたどって調べる
     *
     *
     */
    function _evaluateAccessesFacilityGroupEx(
        $objects,
        $targets_list,
        $object_table,
        $authorities
    ) {
        $tree =& $this->makeFacilityGroupTree($objects);
        $db = $this->_getDBConnection();
        $target_tables =& $this->_target_tables;

        $authority_count = count($authorities);
        $values_list = [];

        // DB に問い合わせる必要がある施設グループをまとめる
        $all_facility_groups = [];
        foreach (array_keys($objects) as $key) {
            $tmp_fagid = $key;
            while ( ! is_null($tmp_fagid)) {
                $all_facility_groups[intval($tmp_fagid)] = intval($tmp_fagid);
                $tmp_fagid = $tree[$tmp_fagid];
            }
        }

        // 問い合わせる必要がある施設グループのセキュリティモデルをキャッシュしておく
        $security_models = $this->_getSecurityModels($all_facility_groups,
            'facilitygroup');

        // 問い合わせ
        $objects_str = "";
        foreach (array_keys($all_facility_groups) as $object_id) {
            $objects_str .= cb_queryf($db, "'@S',", $object_id);
        }
        $objects_str = substr($objects_str, 0, strlen($objects_str) - 1);

        $temp_str = [];
        foreach ($authorities as $authority) {
            $temp_str[] = 'col_authority_' . $authority;
        }
        $authorities_str = implode(' OR ', $temp_str);

        foreach ($target_tables as $target_id => $target_table) {
            if (is_null($targets_list[$target_id])
                || 0 === count($targets_list[$target_id])
            ) {
                continue;
            }
            $targets =& $targets_list[$target_id];

            $table_name = $this->_getTableName($object_table, $target_id, true);

            // ユーザー削除フラグを確認
            $join = '';
            if (strcmp($target_id, 'user') == 0) {
                $join .= ' INNER JOIN tab_cb_user AS tu ON tab_' . $table_name
                         . '.col_target = tu._id AND tu.col_deleted IS NULL';
            }

            $query = 'SELECT * FROM tab_' . $table_name . $join
                     . ' WHERE ( ( col_object IN (' . $objects_str
                     . ') ) AND ( col_target IN (' . $targets_list[$target_id]
                     . ') ) AND ( ' . $authorities_str . ' ) )';

            $query = $db->select_format($query);

            $result = $db->query($query);
            if ($result === false) {
                $db->throwError([
                    'query' => 'failed query on SELECT: ' . $query
                ]);
            }

            $result_cache = [];

            while ($row = $db->fetch_assoc($result)) {
                $result_cache[$row['col_object']] = [];
                foreach ($authorities as $authority) {
                    $result_cache[$row['col_object']][$authority]
                        = $row['col_authority_' . $authority];
                }

                $object_id = $row['col_object'];

                // アクセス権の権限値の一覧を取得する
                if (array_key_exists($object_id, $values_list)) {
                    $values =& $values_list[$object_id];
                } else {
                    $values_list[$object_id] = [];
                    $values =& $values_list[$object_id];
                    foreach ($authorities as $authority) {
                        $values[$authority] = 0;
                    }
                }
                // アクセス権を評価する
                foreach ($authorities as $authority) {
                    $value = $row['col_authority_' . $authority];
                    $value = is_null($value) ? 0 : intval($value);
                    $value = max($values[$authority], $value);
                    $values[$authority] = $value;
                }
            }
            // 結果の開放
            $db->free_result($result);
        }
        $retval = [];

        foreach (array_keys($objects) as $object_id) {
            $parent_groups = [];
            $tmp_id = $object_id;
            while ( ! is_null($tmp_id)) {
                $parent_groups[] = $tmp_id;
                $tmp_id = $tree[$tmp_id];
            }
            $retval[$object_id] = [];
            foreach ($authorities as $authority) {
                $retval[$object_id][$authority] = 1;
            }

            foreach ($parent_groups as $gid) {
                $security_model = $security_models[$gid];

                foreach ($authorities as $authority) {
                    if (array_key_exists($gid, $values_list)
                        && array_key_exists($authority, $values_list[$gid])
                        && $values_list[$gid][$authority] == 1
                    ) {
                        if ($security_model
                            == GRN_SCHD_SECURITY_MODEL_TYPE_REVOKE
                        ) // 権限がない
                        {
                            $retval[$object_id][$authority] = 0;
                        }
                    } else {
                        if ($security_model
                            == GRN_SCHD_SECURITY_MODEL_TYPE_GRANT
                        ) {
                            $retval[$object_id][$authority] = 0;
                        }
                    }
                }
            }
        }

        return $retval;
    }

    /**
     * @param $user
     * @param $objects
     * @param $authorities
     * @param $dynamic_roles
     * @param $user_groups
     * @param $user_roles
     * @param $cache_list
     *
     * @return array|bool
     */
    function _evaluateEventMembersAccessByIdFacilityGroup(
        $user,
        $objects,
        $authorities,
        $dynamic_roles,
        $user_groups,
        $user_roles,
        & $cache_list
    ) {
        $targets_list = [];

        $db = $this->_getDBConnection();

        // ダイナミックロールを取得する
        $targets_list[GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE] = $dynamic_roles;
        if (is_array($dynamic_roles) && count($dynamic_roles) > 0) {
            $target_array = [];
            foreach (array_keys($dynamic_roles) as $key) {
                //$target_array[] = '\''.$key.'\'';
                $target_array[] = cb_queryf($db, "'@S'", $key);
            }
            $targets_list[GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE] = implode(',',
                $target_array);
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_DYNAMIC_ROLE] = null;
        }

        // スタティックロールを取得する
        if (false === $user_roles) {
            return false;
        }
        if (is_array($user_roles) && count($user_roles) > 0) {
            //$targets_list[GRN_SCHD_TARGET_TYPE_STATIC_ROLE] = implode( ',', array_keys( $user_roles ) );
            $target_array = [];
            foreach (array_keys($user_roles) as $key) {
                $target_array[] = cb_queryf($db, "'@S'", $key);
            }
            $targets_list[GRN_SCHD_TARGET_TYPE_STATIC_ROLE] = implode(',',
                $target_array);
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_STATIC_ROLE] = null;
        }

        // 組織を取得する
        if (false === $user_groups) {
            return false;
        }
        if (is_array($user_groups) && count($user_groups) > 0) {
            //$targets_list[GRN_SCHD_TARGET_TYPE_GROUP] = implode( ',', array_keys( $user_groups ) );
            $target_array = [];
            foreach (array_keys($user_groups) as $key) {
                $target_array[] = cb_queryf($db, "'@S'", $key);
            }
            $targets_list[GRN_SCHD_TARGET_TYPE_GROUP] = implode(',',
                $target_array);
        } else {
            $targets_list[GRN_SCHD_TARGET_TYPE_GROUP] = null;
        }

        // ユーザーを取得する
        $targets_list[GRN_SCHD_TARGET_TYPE_USER] = $user->getOID();

        $tree =& $this->makeFacilityGroupTree($objects);

        $db = $this->_getDBConnection();
        $target_tables =& $this->_target_tables;

        $authority_count = count($authorities);
        $values_list = [];
        $accesses = $this->_evaluateAccessesFacilityGroupEx($objects,
            $targets_list, 'schedule_access_facilitygroup', $authorities);

        return $accesses;
    }
}

class GRN_Schedule_Access_Facility_Base extends CB_PersistentBase
{
    var $col_authority_add = ['type' => 'int'];
    var $col_authority_delete = ['type' => 'int'];
    var $col_authority_modify = ['type' => 'int'];
    var $col_authority_read = ['type' => 'int'];
    var $col_object = ['type' => 'relation', 'to' => 'grn_facility_facility'];
}

class GRN_Schedule_Access_Facility_User
    extends GRN_Schedule_Access_Facility_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_user'];
}

class GRN_Schedule_Access_Facility_Group
    extends GRN_Schedule_Access_Facility_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_group'];
}

class GRN_Schedule_Access_Facility_Dynamic_Role
    extends GRN_Schedule_Access_Facility_Base
{
    var $col_target = ['type' => 'char', 'length' => 100];
}

class GRN_Schedule_Access_Facility_Static_Role
    extends GRN_Schedule_Access_Facility_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_role'];
}

class GRN_Schedule_Access_FacilityGroup_Base extends CB_PersistentBase
{
    var $col_authority_add = ['type' => 'int'];
    var $col_authority_delete = ['type' => 'int'];
    var $col_authority_modify = ['type' => 'int'];
    var $col_authority_read = ['type' => 'int'];
    var $col_object
        = [
            'type' => 'relation',
            'to'   => 'grn_facility_facilitygroup'
        ];
}

class GRN_Schedule_Access_FacilityGroup_User
    extends GRN_Schedule_Access_FacilityGroup_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_user'];
}

class GRN_Schedule_Access_FacilityGroup_Group
    extends GRN_Schedule_Access_FacilityGroup_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_group'];
}

class GRN_Schedule_Access_FacilityGroup_Dynamic_Role
    extends GRN_Schedule_Access_FacilityGroup_Base
{
    var $col_target = ['type' => 'char', 'length' => 100];
}

class GRN_Schedule_Access_FacilityGroup_Static_Role
    extends GRN_Schedule_Access_FacilityGroup_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_role'];
}

class GRN_Schedule_Access_Group_Base extends CB_PersistentBase
{
    var $col_authority_add = ['type' => 'int'];
    var $col_authority_delete = ['type' => 'int'];
    var $col_authority_modify = ['type' => 'int'];
    var $col_authority_read = ['type' => 'int'];
    var $col_object = ['type' => 'relation', 'to' => 'cb_group'];
}

class GRN_Schedule_Access_Group_User extends GRN_Schedule_Access_Group_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_user'];
}

class GRN_Schedule_Access_Group_Group extends GRN_Schedule_Access_Group_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_group'];
}

class GRN_Schedule_Access_Group_Dynamic_Role
    extends GRN_Schedule_Access_Group_Base
{
    var $col_target = ['type' => 'char', 'length' => 100];
}

class GRN_Schedule_Access_Group_Static_Role
    extends GRN_Schedule_Access_Group_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_role'];
}

class GRN_Schedule_Access_Role_Base extends CB_PersistentBase
{
    var $col_authority_add = ['type' => 'int'];
    var $col_authority_delete = ['type' => 'int'];
    var $col_authority_modify = ['type' => 'int'];
    var $col_authority_read = ['type' => 'int'];
    var $col_object = ['type' => 'relation', 'to' => 'cb_role'];
}

class GRN_Schedule_Access_Role_User extends GRN_Schedule_Access_Role_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_user'];
}

class GRN_Schedule_Access_Role_Group extends GRN_Schedule_Access_Role_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_group'];
}

class GRN_Schedule_Access_Role_Dynamic_Role
    extends GRN_Schedule_Access_Role_Base
{
    var $col_target = ['type' => 'char', 'length' => 100];
}

class GRN_Schedule_Access_Role_Static_Role extends GRN_Schedule_Access_Role_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_role'];
}

class GRN_Schedule_Access_User_Base extends CB_PersistentBase
{
    var $col_authority_add = ['type' => 'int'];
    var $col_authority_delete = ['type' => 'int'];
    var $col_authority_modify = ['type' => 'int'];
    var $col_authority_read = ['type' => 'int'];
    var $col_object = ['type' => 'relation', 'to' => 'cb_user'];
}

class GRN_Schedule_Access_User_User extends GRN_Schedule_Access_User_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_user'];
}

class GRN_Schedule_Access_User_Group extends GRN_Schedule_Access_User_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_group'];
}

class GRN_Schedule_Access_User_Dynamic_Role
    extends GRN_Schedule_Access_User_Base
{
    var $col_target = ['type' => 'char', 'length' => 100];
}

class GRN_Schedule_Access_User_Static_Role extends GRN_Schedule_Access_User_Base
{
    var $col_target = ['type' => 'relation', 'to' => 'cb_role'];
}
