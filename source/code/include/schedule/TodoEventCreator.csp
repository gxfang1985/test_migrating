<?php

namespace grn\schedule;

use grn\space\service\SpaceService;
use \grn\todo\UncompletedTodoLogic;
use grn\grn\access\service\AppAccess;

/**
 * TodoEventCreator
 * call Uncompleted Todo Logic and
 * capsule constructor & many variation of getUncompletedTodoMethod.
 * This class called By CrateMethods.
 */
class TodoEventCreator
{
    /* prameter from global G_INPUT */
    const USER_ID_KEY = 'uid';
    const DATE_KEY = 'bdate';
    const MOVE_KEY = 'move';

    const PAGE_MONTH = 'month';
    const PAGE_WEEK = 'week';
    const PAGE_DAY = 'day';
    const SECONDS_OF_DAY = 86400;
    const BUFFER_WEEKS = 5;

    /** @var UncompletedTodoLogic */
    private $uncompleteTodoLogic;
    private $accessPage;
    private $target;
    private $input;
    private $target_date = '';
    private $isAjax;
    private $personal_logic;
    private $view_util;

    /**
     * @param array $input
     */
    protected function __construct($input)
    {
        $this->target = [];
        if (array_key_exists(self::USER_ID_KEY, $input)
            && is_numeric($input[self::USER_ID_KEY])
        ) {
            $this->target[self::USER_ID_KEY] = $input[self::USER_ID_KEY];
        } else {
            $this->target[self::USER_ID_KEY] = $this->getLoginUserId();
        }

        if (array_key_exists(self::DATE_KEY, $input)) {
            $this->target[self::DATE_KEY] = $input[self::DATE_KEY];
        } else {
            $this->target[self::DATE_KEY] = '';
        }
        $this->input = $input;
    }

    /**
     * @param array   $input  $G_INPUT
     * @param string  $page   name which user access.
     * @param boolean $isAjax Access Page is Ajax or not.
     *
     * @return \grn\schedule\TodoEventCreator
     **/
    protected static function createEvent($input, $page, $isAjax)
    {
        require_once('schedule/view_util.csp');
        require_once('schedule/personal_logic.csp');
        $myself = new TodoEventCreator($input);
        $myself->uncompleteTodoLogic = new UncompletedTodoLogic();
        $myself->view_util = \GRN_Schedule_View_Util::getInstance();
        $myself->personal_logic
            = \GRN_Schedule_PersonalLogic::getInstance();
        $myself->accessPage = $page;
        $myself->isAjax = $isAjax;

        return $myself;
    }

    /**
     * This Method should called in Scheduler Month View page.
     *
     * @param  array $input $G_INPUT
     *
     * @return \grn\schedule\TodoEventCreator
     */
    public static function createMonthEvent($input)
    {
        return self::createEvent($input, self::PAGE_MONTH, false);
    }

    /**
     * This Method should called in Scheduler Ajax Month View page.
     *
     * @param  array $input $G_INPUT
     *
     * @return \grn\schedule\TodoEventCreator
     */
    public static function createAjaxMonthEvent($input)
    {
        return self::createEvent($input, self::PAGE_MONTH, true);
    }

    /**
     * This Method should called in Scheduler Ajax Week View page.
     *
     * @param  array $input $G_INPUT
     *
     * @return \grn\schedule\TodoEventCreator
     */
    public static function createAjaxWeekEvent($input)
    {
        return self::createEvent($input, self::PAGE_WEEK, true);
    }

    /**
     * This Method should called in Scheduler Week View page.
     *
     * @param  array $input $G_INPUT
     *
     * @return \grn\schedule\TodoEventCreator
     */
    public static function createWeekEvent($input)
    {
        return self::createEvent($input, self::PAGE_WEEK, false);
    }

    /**
     * This Method should called in Scheduler Day View page.
     *
     * @param  array $input $G_INPUT
     *
     * @return \grn\schedule\TodoEventCreator
     */
    public static function createDayEvent($input)
    {
        return self::createEvent($input, self::PAGE_DAY, false);
    }

    /**
     * @return boolean target_date("bdate") is avaliable or not.
     *         if This class called in Ajax Page and fail parse,
     *         Throw_error
     **/
    protected function validateDate()
    {
        $this->target_date = new \CB_Date();
        $result
            = $this->target_date->parse($this->target[self::DATE_KEY]);

        if ($result === false) {
            ($this->isAjax)
            && cb_throw_error(E_GRN_SCHEDULE_INVALID_AJAX_REQUEST);
        }

        return $result;
    }

    /**
     * @return \CB_TimestampEx
     * crate CB_TimestampEx depended on user timezone,target date
     **/
    protected function createStartTimestamp()
    {
        $timestamp = new \CB_TimestampEx();
        $timestamp->setTimezone($this->getLoginUserTimezone());
        $datetime = $timestamp->getDatetime()->roundByDay();

        if ($this->validateDate() === true && $this->target_date !== '') {
            $datetime->year = $this->target_date->year;
            $datetime->month = $this->target_date->month;
            $datetime->day = $this->target_date->day;
        } else {
            $this->target_date->year = $datetime->year;
            $this->target_date->month = $datetime->month;
            $this->target_date->day = $datetime->day;
        }
        $timestamp->setDateTime($datetime);

        return $timestamp;
    }

    /**
     * call uncompletedTodo Logic to get UncompletedTodo.
     *
     * @return array.
     **/
    public function getMyUncompletedSharedTodoWhenAjaxAccess()
    {
        $move = 0;
        if (array_key_exists(self::MOVE_KEY, $this->input)
            && is_numeric($this->input[self::MOVE_KEY])
        ) {
            $move = (int)$this->input[self::MOVE_KEY];
        }


        $todos = [];

        $start_timestamp = $this->createStartTimestamp();
        $start_datetime = $start_timestamp->getDatetime();

        if ($this->accessPage === self::PAGE_MONTH) {
            $start_datetime->moveWeeks($move);
            $start_timestamp->setDateTime($start_datetime);

            //$start_timestampの一日を加えた105日間
            $todos = $this->uncompleteTodoLogic
                ->getUncompletedSharedTodoByDays($this->getLoginUserId(),
                    $start_timestamp->unix_ts,
                    $start_timestamp->unix_ts +
                    self::SECONDS_OF_DAY * 105);
        } elseif ($this->accessPage === self::PAGE_WEEK) {
            $start_datetime->moveDays($move);
            $start_timestamp->setDateTime($start_datetime);
            $todos = $this->uncompleteTodoLogic
                ->getUncompletedSharedTodoByDays($this->getLoginUserId(),
                    $start_timestamp->unix_ts,
                    $start_timestamp->unix_ts +
                    self::SECONDS_OF_DAY * 26);
        }

        return $todos;

    }

    /**
     * call uncompletedTodo Logic to get UncompletedTodo.
     *
     * @return array.
     **/
    public function getMyUncompletedSharedTodoWhenNormalAccess()
    {
        $start_timestamp = $this->createStartTimestamp();
        $start_datetime = $start_timestamp->getDatetime();
        if ($this->accessPage === self::PAGE_MONTH) {
            $end_timestamp = $this->createStartTimestamp();
            $end_datetime = $end_timestamp->getDatetime();
            $startwday
                = $this->personal_logic->getCalendarWeekStart($this->getLoginUser());
            $start_date
                = $this->view_util->getCalendarStartDate($this->target_date,
                $startwday);
            $end_date
                = $this->view_util->getCalendarEndDate($this->target_date,
                $startwday);

            $start_date->moveWeeks(-self::BUFFER_WEEKS);
            $end_date->moveWeeks(self::BUFFER_WEEKS);

            $start_datetime->setDate($start_date);
            $end_datetime->setDate($end_date);
            $start_timestamp->setDateTime($start_datetime);
            $end_timestamp->setDateTime($end_datetime);
            //何月何日の0時0分のタイムスタンプを発行した場合、doc_rootのループで、
            //配列が足りなくなるので、検索の終了時間を+1する
            $todos = $this->uncompleteTodoLogic
                ->getUncompletedSharedTodoByDays($this->getLoginUserId(),
                    $start_timestamp->unix_ts,
                    $end_timestamp->unix_ts + 1);
        } elseif ($this->accessPage === self::PAGE_WEEK) {
            $todos = $this->uncompleteTodoLogic
                ->getUncompletedSharedTodoByDays($this->getLoginUserId(),
                    $start_timestamp->unix_ts,
                    $start_timestamp->unix_ts +
                    self::SECONDS_OF_DAY * 7);
        } elseif ($this->accessPage === self::PAGE_DAY) {
            $todos = $this->uncompleteTodoLogic
                ->getUncompletedSharedTodoByDays($this->getLoginUserId(),
                    $start_timestamp->unix_ts,
                    $start_timestamp->unix_ts +
                    self::SECONDS_OF_DAY * 2);
        } else {
            $todos = [];
        }

        return $todos;

    }

    /**
     * if target user is different from login user,
     * This method don't call to UncompletedTodoLogic.
     *
     * @return array.
     **/
    public function getMyUncompletedSharedTodo()
    {
        if ($this->target[self::USER_ID_KEY] !== $this->getLoginUserId()) {
            return [];
        }
        if ($this->spaceIsAvailable() === false) {
            return [];
        }

        if ($this->isAjax) {
            $all_todo = $this->getMyUncompletedSharedTodoWhenAjaxAccess();
        } else {
            $all_todo = $this->getMyUncompletedSharedTodoWhenNormalAccess();
        }

        $spaceService = SpaceService::getInstance();
        $relation_space = $spaceService->getAvailabilityRelationSpaceIDS();
        foreach ($all_todo as $all_todo_index => $todos) {
            foreach ($todos as $key => $todo) {
                if (isset($todo['space_id'])) {
                    if ( ! isset($relation_space[$todo['space_id']])) {
                        unset($all_todo[$all_todo_index][$key]);
                    }
                }
            }
            //Reset the index of the array before returning to client for rendering
            $all_todo[$all_todo_index]
                = array_values($all_todo[$all_todo_index]);
        }

        return $all_todo;
    }

    /*
     * Input todos argument $events
     * @param  array $events
     * @return boolean
     */
    public function inputSharedTodoInEvents(array &$events)
    {

        $todos = $this->getMyUncompletedSharedTodo();

        //should not called by Day Page.
        if (empty($todos) or $this->accessPage === self::PAGE_DAY) {
            return false;
        }
        $todo_limit = count($todos);
        $event_limit = count($events);
        for ($i = 0; $i < $event_limit and $i < $todo_limit; $i++) {
            $events[$i]["shared_todos"] = $todos[$i];
        }

        return true;
    }

    /**
     * @return int login user_id
     */
    protected function getLoginUserId()
    {
        return $this->getLoginUser()->getOID();
    }

    /**
     * @return \CB_User
     */
    protected function getLoginUser()
    {
        global $G_container_base;
        $uum = $G_container_base->getInstance('uum');

        return $uum->getLoginUser();
    }

    /**
     * @return integer of timestamp
     **/
    protected function getNow()
    {
        return time();
    }

    /**
     * @return integer of timestamp
     **/
    public function getExpiredSharedTodo()
    {
        if ($this->spaceIsAvailable() === false) {
            return [];
        }
        $todos = [];
        if ($this->isExpiredTodoQueryNeeded()) {
            $todos = $this->uncompleteTodoLogic
                ->getExpiredSharedTodo($this->getLoginUserId(),
                    $this->getNow());
        }

        $spaceService = SpaceService::getInstance();
        $relation_space = $spaceService->getAvailabilityRelationSpaceIDS();
        foreach ($todos as $key => $todo) {
            if (isset($todo['space_id'])) {
                if ( ! isset($relation_space[$todo['space_id']])) {
                    unset($todos[$key]);
                }
            }
        }

        return $todos;
    }

    /**
     * @return array
     **/
    public function getExpiredPersonalTodo()
    {
        if ($this->todoIsAvailable() === false) {
            return [];
        }
        $todos = [];
        if ($this->isExpiredTodoQueryNeeded()) {
            $todos = $this->uncompleteTodoLogic
                ->getExpiredPersonalTodo($this->getLoginUserId(),
                    $this->getTimestampOfTodayDependedOnUserTimezone());

        }

        return $todos;
    }

    /**
     * @return string Timezone of Login User
     **/
    public function getLoginUserTimezone()
    {
        return \CB_I18N::getInstance()->getUserTimezone($this->getLoginUser());
    }

    /**
     * define necessary to call UncompletedTodo ExpiredTodoMethods.
     *
     * @return boolean
     **/

    public function isExpiredTodoQueryNeeded()
    {
        if ($this->target[self::USER_ID_KEY] !== $this->getLoginUserId()) {
            return false;
        }

        $now = $this->getNow();
        $diff = ($this->accessPage === self::PAGE_WEEK ? 7 : 1)
                * self::SECONDS_OF_DAY;
        $target_timestamp = $this->createStartTimestamp()->unix_ts;

        if ($target_timestamp < $now - $diff or $now + $diff
                                                < $target_timestamp
        ) {
            return false;
        }

        return true;
    }

    /**
     * @return integer return today's timestamp 0:00 of depended Usertimezone.
     **/
    public function getTimestampOfTodayDependedOnUserTimezone()
    {
        $timestamp = new \CB_TimeStampEx();
        $timestamp->setTimezone($this->getLoginUserTimezone());
        $datetime = $timestamp->getDateTime()->roundByDay();

        $timestamp->setDateTime($datetime);

        return $timestamp->unix_ts;
    }

    /**
     * @return boolean spaceApplication is available
     **/
    protected function spaceIsAvailable()
    {
        return $this->someAppIsAvailable("space");
    }

    /**
     * @param  $app_name Application name "space" or "todo"
     *
     * @return boolean Application
     */
    private function someAppIsAvailable($app_name)
    {
        return AppAccess::isAppAvailable($app_name);
    }

    /**
     * @return boolean todoApplication is available
     **/
    protected function todoIsAvailable()
    {
        return $this->someAppIsAvailable("todo");
    }

    /**
     * @return \GRN_ApplicationLocator
     **/
    protected function createApplicationLocator()
    {
        return \GRN_ApplicationLocator::instance();
    }

    /**
     * @param array $todos
     * @param int   $index
     *
     * @return array of todo or empty array.
     **/
    public function getTodoByIndex(array $todos, $index)
    {
        return isset($todos[$index]) ? $todos[$index] : [];
    }
}
