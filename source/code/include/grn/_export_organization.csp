<?php
require_once('grn/org_privilege.csp');
$logic = GRN_OrganizationPrivilegeLogic::getInstance();
$is_admin = $logic->isAdmin();

require_once('grn/nested_set_model.csp');
$nested_group = GRN_NestedGroup::getInstance();

// 万が一ツリーが壊れた場合の救済
$nested_group->rebuildTree();
// 万が一ツリーが壊れた場合の救済の処理の時点で組織情報がgroupTableInfoにキャッシュされる。
// この影響でCSV出力処理ではデフォルトの組織名が取得したいのにキャッシュが優先的に使われる仕様のせいで
// 取得することが出来ない。下記の4行はその応急対応として追加しているが他の方法を考えるべき。
// 例えばCSV出力処理に永続化オブジェクトを一切使わないように作り変えるなど
// そもそも「万が一ツリーが壊れた場合」とはどのような状況なのが不明
global $G_container_base;
$tm = $G_container_base->getInstance('table_manager');
$groupTableInfo = $tm->getTableInfo('CB_Group');
$groupTableInfo->_commit();


require_once('fw/i18n.csp');
$charset = @$G_INPUT['charset'];
if ( ! $charset) {
    global $G_config_common;
    $charset = $G_config_common->get('I18N', 'default_external_encoding');
}
$put_title = @$G_INPUT['title'];

// エラーフックの登録
require_once('fw/csv.csp');
$csv = new CB_CSVWriter($charset);
$uum =& $G_container_base->getInstance('uum');

if ($put_title) {
    $line = [];
    $line[] = cb_msg('grn.common', 'organization_key');
    $line[] = cb_msg('grn.common', 'organization_name');
    $line[] = cb_msg('grn.common', 'organization_foreign_key');
    $line[] = cb_msg('grn.common', 'organization_parent_key');
    $line[] = cb_msg('grn.common', 'organization_description');
    $csv->writeLine($line);
}

function write_group_recursive(& $csv, & $group, & $uum, $inIsUseLocal)
{
    $line = [];
    $line[] = $group->get('foreign_key');
    $line[] = $group->get('name');
    $line[] = $group->get('foreign_key');
    $parent =& $group->getParent();
    $parent_key = $parent ? $parent->get('foreign_key') : '';
    $line[] = $parent_key;
    $line[] = $group->get('description');
    $csv->writeLine($line);

    $uum->execInspection('group', 'export', [
        'gid'         => $group->getOID(),
        'name'        => $group->get('name'),
        'foreign_key' => $group->get('foreign_key'),
        'parent'      => $parent_key
    ]);

    $children = $uum->getChildGroups($group->getOID(), $inIsUseLocal);
    if ($children !== false) {
        foreach (array_keys($children) as $cgid) {
            $child =& $children[$cgid];
            write_group_recursive($csv, $child, $uum, $inIsUseLocal);
        }
    }
}


$isUseLocal = false;
if ($is_admin) {
    $root_groups = $uum->getRootGroups($isUseLocal);
} else {
    $root_groups = $logic->getRootGroupsWithAuthority($uum->getLoginUser(),
        $isUseLocal);
}
foreach (array_keys($root_groups) as $root_id) {
    $root =& $root_groups[$root_id];
    write_group_recursive($csv, $root, $uum, $isUseLocal);
}

$csv->close();


