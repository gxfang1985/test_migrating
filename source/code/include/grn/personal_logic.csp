<?php

/**
 * The common personal configuration logics.
 *
 * The purposes of this are:
 *  1) to structure the base system management,
 *  2) to provide the unit of privileges over the system management,
 *  3) and to structure the system help.
 *
 * @package grn.common
 */

require_once('fw/module.csp');

/**
 * Abstract base class for common personal configuration objects.
 *
 * @abstract
 * @package grn.common
 */
class GRN_PersonalLogicBase extends CB_ModuleBase
{
    /**
     * @access private
     */
    private $_id;

    function __construct($id)
    {
        parent::__construct('grn.common.personal.' . $id);
        $this->_id = $id;
    }

    function getId()
    {
        return $this->_id;
    }

    function getName()
    {
        return $this->getMessage('name');
    }

    /**
     * Return array of personal configuration categories, and
     * contents of each category.  If the logic does not provide
     * any system configuration, this will return FALSE.
     *
     * "icon" may be omitted; in such case the system will use
     * "general32" icon.
     *
     * For each category key, you need to provide an I18N message
     * resource (for "grn.common.personal.$id" module).
     * WARNING: You cannot use "name" as a category key, because
     *          "name" is reserved for the logic name string.
     *
     * The return value will look like:
     *   array( 'general' => array(  // array of pages
     *                               array('page'=>'personal/$id/general1',
     *                                     'icon'=>'general32'),
     *                               array('page'=>'personal/$id/general2',
     *                                     'icon'=>'general32'),
     *                                 ... ),
     *          'foobar'  => array(  array('page'=>'personal/$id/foobar1',
     *                                     'icon'=>'general32'),
     *                               array('page'=>'personal/$id/foobar2',
     *                                     'icon'=>'general32'),
     *                               ... ),
     *          ...);
     *
     * @return mixed   array, or FALSE if no personal configuration.
     */
    function getConfigArray()
    {
        return false;
    }
}

/**
 *
 * @package grn.common
 */
class GRN_Personal extends CB_ModuleBase
{
    private static $_instance = null;

    /**
     * @return GRN_Personal
     */
    public static function getInstance()
    {
        if ( ! isset(self::$_instance)) {
            $c = __CLASS__;
            self::$_instance = new $c;
        }

        return self::$_instance;
    }

    /**
     * @access private
     */
    function __construct()
    {
        parent::__construct('grn.common.personal');
    }

    /**
     * @access private
     */
    private $_ids = null;

    /**
     * @access private
     */
    private $_id_map = null;

    /**
     * @access private
     */
    function _constructIdMap()
    {
        $this->_ids = [];
        $this->_id_map = [];

        $path = cb_basedir() . '/code/plugin/grn/common/personal';
        $dir = @opendir($path);
        if ($dir === false) {
            require_once('grn/error_code.csp');
            cb_throw_error(E_GRN_PERSONAL_NO_LOGIC_DIR, null,
                ['dir' => $path]);
        }
        while (($file = readdir($dir)) !== false) {
            if (preg_match('#^([0-9][0-9])(.*)\\.csp$#', $file, $regs)) {
                $this->_id_map[$regs[2]] = $regs[1] . $regs[2];
                $this->_ids[$regs[1] . $regs[2]] = $regs[2];
            }
        }

        // GRN35-316
        if (defined('ON_FOREST')) {
            $unset_ids = [
                'sso' => '02sso',
            ];
            foreach ($unset_ids as $key => $value) {
                if (array_key_exists($key, $this->_id_map)) {
                    unset($this->_id_map[$key]);
                }
                if (array_key_exists($value, $this->_ids)) {
                    unset($this->_ids[$value]);
                }
            }
        }

        // GRN35-316
        closedir($dir);
        ksort($this->_ids);
    }

    /**
     * @return array
     */
    function getLogicIds()
    {
        if (is_null($this->_ids)) {
            $this->_constructIdMap();
        }

        return $this->_ids;
    }

    /**
     * @return array
     */
    function getAvailableLogicIds()
    {
        // tentative implementation
        return $this->getLogicIds();
    }

    /**
     * Return a personal logic object.
     *
     * @return mixed {@link GRN_PersonalLogicBase}, or FALSE if $id is not valid.
     */
    function getLogic($id)
    {
        if (is_null($this->_id_map)) {
            $this->_constructIdMap();
        }

        if ( ! array_key_exists($id, $this->_id_map)) {
            $___ret = false;

            return $___ret;
        }

        $real_id = $this->_id_map[$id];
        $loader = $this->getPluginLoader();
        $logic = $loader->loadDriver($real_id);
        assert('(!is_object($logic)) || is_a($logic, "GRN_PersonalLogicBase")');

        return $logic;
    }
}


