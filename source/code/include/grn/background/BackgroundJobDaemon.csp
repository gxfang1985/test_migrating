<?php

namespace grn\grn\background;

class BackgroundJobDaemon
{
    public function run()
    {
        global $G_config_common;
        $backgroundJobDAO = new BackgroundJobDAO(cb_get_app_db("job"));

        $logger = BackgroundJobLogger::create();

        $basedir = cb_basedir();
        $php = cb_get_cli_path();
        $ln = PHP_EOL;

        // check background job life time
        $lifetime = $G_config_common->get("BackgroundJob", "lifetime");
        if ( ! $lifetime || ! is_numeric($lifetime)) {
            die("lifetime of BackgroundJob::lifetime section in common.ini should be numeric");
        }
        $lifetime_range = $G_config_common->get("BackgroundJob",
            "lifetime_range");
        if ($lifetime_range) {
            if ( ! is_numeric($lifetime_range)) {
                die("lifetime of BackgroundJob::lifetime_range section in common.ini should be numeric");
            }

            $lifetime_range = (int)$lifetime_range;
            $lifetime = $lifetime + rand(-$lifetime_range,
                    $lifetime_range);
            $logger->log(BackgroundJobLogger::LOG_NOTICE,
                "randomized lifetime is ${lifetime}");
        }

        // check interval
        $interval = $G_config_common->get("BackgroundJob", "interval");
        if ( ! $interval || ! is_numeric($interval)) {
            die("interval of BackgroundJob::interval section in common.ini should be numeric");
        }

        $filePath = [$basedir, "code", "command", "run_background_job.csp"];
        $command = cb_get_fopen_execute_path($php,
            implode($filePath, DIRECTORY_SEPARATOR));
        for ($i = 0; $i < $lifetime; $i++) {
            if (cb_get_backupmode() !== false) {
                $logger->log(BackgroundJobLogger::LOG_WARNING,
                    "stop background_job_daemon because of backup mode");
                break;
            }

            $check = $i + 1;
            $logger->log(BackgroundJobLogger::LOG_NOTICE, "{$check} check.");
            $numOfJob = $backgroundJobDAO->numOfJobs();

            if ($numOfJob > 0) {
                $logger->log(BackgroundJobLogger::LOG_NOTICE,
                    "launch {$numOfJob} processes");
                $is_finished = true;
                for ($job = 0; $job < $numOfJob; $job++) {
                    $numOfProcess = $job + 1;
                    $logger->log(BackgroundJobLogger::LOG_INFO,
                        "[{$numOfProcess}]start child process.");
                    chdir($basedir);
                    $handle = popen($command, "r");

                    if ($handle === false) {
                        $logger->log(BackgroundJobLogger::LOG_ERROR,
                            "Failed open process :{$command}.");
                        $is_finished = false;
                        break;
                    }

                    $output = "";
                    while ( ! feof($handle)) {
                        $output .= fread($handle, 2048);
                    }

                    $result = pclose($handle);
                    if ($result !== 0) {
                        $logger->log(BackgroundJobLogger::LOG_ERROR,
                            "Failed execute process.{$ln}{$output}");

                    }
                    $logger->log(BackgroundJobLogger::LOG_INFO,
                        "[{$numOfProcess}]end child process.{$ln}{$output}");
                }
                if ($is_finished) {
                    $logger->log(BackgroundJobLogger::LOG_NOTICE,
                        "finished {$numOfJob} processes");
                }

            }
            $logger->log(BackgroundJobLogger::LOG_NOTICE, "start sleep.");
            sleep($interval);
            $logger->log(BackgroundJobLogger::LOG_NOTICE, "end sleep.");
        }
        $logger->log(BackgroundJobLogger::LOG_NOTICE, "end daemon process.");
    }
}
