<?php

require_once('fw/http.csp');

/**
 * HTTPプロキシの設定管理クラス
 *
 * @version     1.0
 * @package     grn.common
 */
class GRN_HttpProxyConfigManager extends CB_ModuleBase
{
    /**
     * @access private
     */
    var $_profile = null;

    /**
     * @access private
     */
    var $_cache = [];

    /**
     * シングルトンインスタンスを取得する
     *
     * @return GRN_HttpProxyConfigManager
     */
    public static function getInstance()
    {
        static $_instance = null;
        if (is_null($_instance)) {
            $_instance = new GRN_HttpProxyConfigManager();
        }

        return $_instance;
    }

    /**
     * @access private
     */
    function __construct()
    {
        parent::__construct('grn.common.httpproxy');
        $this->_profile = $this->getSystemProfile();
    }

    /**
     * Webプロキシが利用可能かどうか？
     *
     * @return bool
     */
    function isAvaliable()
    {
        if ($this->getProperty('available', $value)) {
            return (bool)$value;
        }

        return false;
    }

    /**
     * Webプロキシのプロパティを削除する
     *
     * @param string $key プロパティ名
     *
     * @return bool
     */
    function removeProperty($key)
    {
        unset($this->_cache[$key]);

        return $this->_profile->removeAttribute($key);
    }

    /**
     * Webプロキシのプロパティを取得する
     *
     * @param string $key   プロパティ名
     * @param string $value プロパティ値
     *
     * @return bool
     */
    function getProperty($key, &$value)
    {
        if (array_key_exists($key, $this->_cache)) {
            $value = $this->_cache[$key];

            return true;
        }

        return $this->_profile->getAttribute($key, $value);
    }

    /**
     * Webプロキシのプロパティを設定する
     *
     * @param string $key   プロパティ名
     * @param string $value プロパティ値
     *
     * @return bool
     */
    function setProperty($key, $value)
    {
        if ($this->_profile->getAttribute($key, $dummy)) {
            $this->_profile->updateAttribute($key, $value);
        } else {
            $this->_profile->createAttribute($key, $value);
        }
        $this->_cache[$key] = $value;
    }

    /**
     * HTTPプロキシクライアントを取得する
     *
     * @return GRN_ProxyHttpClient
     */
    function getProxyHttpClient()
    {
        $ret = new GRN_ProxyHttpClient;

        return $ret;
    }

    /**
     * 接続確認を行う
     *
     * @return bool
     */
    function testConnect($timeout = 30)
    {
        require_once('Net/Socket.php');

        $this->getProperty('server', $server);
        $this->getProperty('port', $port);

        $socket = new Net_Socket();
        $options = [
            "ssl" => [
                "verify_peer"      => false,
                "verify_peer_name" => false
            ]
        ];
        if (PEAR::isError(
            $err = ($socket->connect($server, $port, null, $timeout, $options)))
        ) {
            cb_throw_error(E_GRN_EXTSERVE_FAILED_TO_CONNECT_PROXY_SERVER);
        }
        $socket->disconnect();

        return true;
    }
}

/**
 * HTTPクライアントクラス
 * Proxyの設定を利用して通信する
 *
 * @version     1.0
 * @package     grn.common
 */
class GRN_ProxyHttpClient
{
    /**
     * @access private
     */
    var $_config = null;

    /**
     * @access private
     */
    var $_http = null;

    /**
     * コンストラクタ
     */
    function __construct()
    {
        global $G_container_base;
        $this->_config = GRN_HttpProxyConfigManager::getInstance();
        $this->_http = $G_container_base->getInstance('http_client');
    }

    /**
     * HTTPリクエストの実行
     *
     * @param mixed $uri the URI as {@link CB_URI} or string.
     *
     * @return bool TRUE if it successds in execute the
     * operations, FALSE otherwise.
     */
    function execute($uri)
    {
        global $G_config_grn;
        if ($G_config_grn->get('WebProxy', 'force')) {
            $server = $G_config_grn->get('WebProxy', 'server');
            $port = $G_config_grn->get('WebProxy', 'port');
            $exception = $G_config_grn->get('WebProxy', 'exception');

            $addresses = explode('|', $exception);

            // exception check
            $search = ($uri instanceof CB_URI) ? $uri->toString(false)
                : $uri;
            $use_proxy = true;
            foreach ($addresses as $address) {
                if (strlen($address) == 0) {
                    continue;
                }

                if (stristr($search, $address) !== false) {
                    $use_proxy = false;
                    break;
                }
            }

            if ($use_proxy) {
                $proxy = "{$server}:{$port}";
                $this->_http->setCurlOption(CURLOPT_PROXY, $proxy);
            }
        } elseif ( ! defined('ON_FOREST') && $this->_config->isAvaliable()) {
            // HTTPプロキシを利用可能
            if (is_string($uri)) {
                $uri = new CB_URI($uri);
            }

            $exception_address = '';
            $this->_config->getProperty('exception_address',
                $exception_address);
            $addresses = explode(';', $exception_address);
            if ( ! is_array($addresses)) {
                $addresses = [];
            }

            $use_proxy = true;
            $search = $uri->toString(false);

            // 例外アドレスのチェック
            foreach ($addresses as $address) {
                if (strlen($address) == 0) {
                    continue;
                }

                if (stristr($search, $address) !== false) {
                    $use_proxy = false;
                    break;
                }
            }

            // プロキシを利用する場合
            if ($use_proxy) {
                $this->_config->getProperty('server', $server);
                $this->_config->getProperty('port', $port);
                $proxy = "$server:$port";
                $this->_http->setCurlOption(CURLOPT_PROXY, $proxy);
            }
        }

        return $this->_http->execute($uri);
    }

    /**
     * HTTPリクエストオブジェクトの取得
     *
     * @return object CB_HttpClient
     */
    function getHttp()
    {
        return $this->_http;
    }
}


