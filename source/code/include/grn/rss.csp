<?php

/**
 * RSS Logic Classes
 *
 * @author  Eiji TAEN    2005/06
 * @version 1.0
 * @package grn.common.rss
 */

require_once('fw/persistent.csp');

define('GRN_RSS_MODULEID', 'grn.common.rss');
define('GRN_RSS_USERAGENT', 'Cybozu(R) Garoon RSS Reader 2.0.1');
define('GRN_RSS_CHANNEL_TYPE_GENERAL', 0);
define('GRN_RSS_CHANNEL_TYPE_CYBOZU', 1);
define('GRN_RSS_CYBOZU_ID', 'Cybozu Information');
define('GRN_RSS_CYBOZU_MODULE_ID', 'grn.common.cybozu_info');
define('GRN_RSS_LICENSE_TYPE_VALID', 0);
define('GRN_RSS_LICENSE_TYPE_EXPIRED', 1);
define('GRN_RSS_LICENSE_TYPE_TRIAL', 2);
define('GRN_RSS_CYBOZU_CONFIG_OID', 1);
define('GRN_RSS_CYBOZU_ICON', 'notify_cybozu20');
define('GRN_RSS_CYBOZU_URL', 'http://www.cybozu.co.jp/');
define('GRN_RSS_CYBOZU_CACHE_LIFTTIME', 14);
define('GRN_RSS_CYBOZU_TIMEOUT', 30);
define('GRN_RSS_MAX_UPDATE_ITEM_NUM', 100);

/**
 * get RSS cache file path
 *
 * @param    string $cache_id cache id (channel id)
 *
 * @return   string   cache file path
 */
function grn_rss_cache_path($cache_id)
{
    return _grn_rss_get_cache_dir() . '/' . md5($cache_id);
}

/**
 * make RSS cache file directory
 */
function grn_rss_make_cache_dir()
{
    $dir = _grn_rss_get_cache_dir();
    cb_mkdir($dir, 0700) || die("failed to make directory: ${dir}");
}

/**
 * @access   private
 */
function _grn_rss_get_cache_dir()
{
    return cb_tmpdir() . '/rss';
}

/**
 * get max update item number
 *
 * @return   int
 */
function grn_rss_get_max_update_item_num()
{
    global $G_config_grn;
    $ret = intval($G_config_grn->get('RSS', 'max_update_item_num'));
    if ( ! $ret) {
        $ret = GRN_RSS_MAX_UPDATE_ITEM_NUM;
    }

    return $ret;
}

/**
 * parse W3C Date and Time Format (include ISO8601, RFC3339)
 * see http://www.w3.org/TR/NOTE-datetime
 *
 * @param    string $datetime W3CDTF/ISO8601/RFC3339
 *
 * @return   CB_TimeStamp
 */
function grn_rss_w3cdtf2unix_ts($datetime)
{
    $YYYY = '([0-9]{4})';
    $MM = '(0[1-9]|1[0-2])';
    $DD = '(0[1-9]|[1-2][0-9]|3[0-1])';
    $hh = '([0-1][0-9]|2[0-3])';
    $mm = '([0-5][0-9])';
    $ss = $mm;
    $s = '([1-9][0-9]*)';
    $TZD = '(Z|([\+|-])' . $hh . ':' . $mm . ')';

    $format_list = [
        $YYYY,
        // 0
        $YYYY . '-' . $MM,
        // 1
        $YYYY . '-' . $MM . '-' . $DD,
        // 2
        $YYYY . '-' . $MM . '-' . $DD . 'T' . $hh . ':' . $mm . $TZD,
        // 3
        $YYYY . '-' . $MM . '-' . $DD . 'T' . $hh . ':' . $mm . ':' . $ss
        . $TZD,
        // 4
        $YYYY . '-' . $MM . '-' . $DD . 'T' . $hh . ':' . $mm . ':' . $ss . '\.'
        . $s . $TZD,
        // 5
    ];

    $fdate = [];
    $type = -1;
    foreach ($format_list as $key => $format) {
        if (preg_match('/^' . $format . '$/', $datetime, $val)) {
            $year = intval($val[1]);
            $month = 1;
            $day = 1;
            $hour = 0;
            $minute = 0;
            $second = 0;
            $offset_sign = '+';
            $offset_hour = '0';
            $offset_minute = '0';

            if ($year < 1970) {
                $year = 1970;
                $day = 2;
                $key = -1;
            }

            switch ($key) {
                case 0:
                    if ($year === 1970) {
                        $day = 2;
                    }
                    break;
                case 1:
                    $month = intval($val[2]);
                    if ($year === 1970 && $month === 1) {
                        $day = 2;
                    }
                    break;
                case 2:
                    $month = intval($val[2]);
                    $day = intval($val[3]);
                    if ($year === 1970 && $month === 1 && $day === 1) {
                        $day = 2;
                    }
                    break;
                case 3:
                    $month = intval($val[2]);
                    $day = intval($val[3]);
                    $hour = intval($val[4]);
                    $minute = intval($val[5]);
                    if ($year === 1970 && $month === 1 && $day === 1) {
                        $day = 2;
                    }
                    if (strcmp('Z', $val[6]) !== 0) {
                        $offset_sign = $val[7];
                        $offset_hour = $val[8];
                        $offset_minute = $val[9];
                    }
                    break;
                case 4:
                    $month = intval($val[2]);
                    $day = intval($val[3]);
                    $hour = intval($val[4]);
                    $minute = intval($val[5]);
                    $second = intval($val[6]);
                    if ($year === 1970 && $month === 1 && $day === 1) {
                        $day = 2;
                    }
                    if (strcmp('Z', $val[7]) !== 0) {
                        $offset_sign = $val[8];
                        $offset_hour = $val[9];
                        $offset_minute = $val[10];
                    }
                    break;
                case 5:
                    $month = intval($val[2]);
                    $day = intval($val[3]);
                    $hour = intval($val[4]);
                    $minute = intval($val[5]);
                    $second = intval($val[6]);
                    if ($year === 1970 && $month === 1 && $day === 1) {
                        $day = 2;
                    }
                    if (strcmp('Z', $val[8]) !== 0) {
                        $offset_sign = $val[9];
                        $offset_hour = $val[10];
                        $offset_minute = $val[11];
                    }
                    break;
            }

            $ts = new CB_TimeStamp();
            $ts->unix_ts = gmmktime($hour - intval($offset_sign . $offset_hour),
                $minute - intval($offset_sign . $offset_minute),
                $second, $month, $day, $year);

            return $ts;
        }
    }

    {
        $___ret = false;

        return $___ret;
    }
}

/**
 * RSS Channel table class
 *
 * @author  Eiji TAEN    2005/05
 * @version 1.0
 * @package grn.common
 */
class GRN_RSS_Channel extends CB_PersistentBase
{
    // channel id (xml url)
    var $col_id
        = [
            'type'    => 'char',
            'length'  => 0xFFFF,
            'notnull' => true
        ];
    // sha-1 hash of channel id
    var $col_hash
        = [
            'type'    => 'char',
            'length'  => 40,
            'notnull' => true
        ];

    // channel title
    var $col_title = ['type' => 'char', 'length' => 0xFFFF];
    // channel url
    var $col_channel_url
        = [
            'type'   => 'char',
            'length' => CB_DATABASE_MAX_STRINDEX
        ];
    // channel description
    var $col_description
        = [
            'type'   => 'char',
            'length' => 0xFFFF,
            'lazy'   => true
        ];
    // channel type (0: general channel, 1: cybozu information)
    var $col_type = ['type' => 'int'];
    // channel publication date
    var $col_ptime = ['type' => 'timestamp'];
    // updated time
    var $col_utime = ['type' => 'timestamp'];
    // HTTP header Last-Modified field
    var $col_last_modified = ['type' => 'char'];
    // joint user number
    var $col_user_num = ['type' => 'int'];
    // fetch/parse error code
    var $col_error_code = ['type' => 'char'];

    // reserved columns 
    var $col_reserve_text1 = ['type' => 'char', 'lazy' => true];
    var $col_reserve_text2 = ['type' => 'char', 'lazy' => true];
    var $col_reserve_text3 = ['type' => 'char', 'lazy' => true];
    var $col_reserve_int1 = ['type' => 'int', 'lazy' => true];
    var $col_reserve_int2 = ['type' => 'int', 'lazy' => true];
    var $col_reserve_int3 = ['type' => 'int', 'lazy' => true];
    var $col_reserve_blob1 = ['type' => 'blob', 'lazy' => true];
    var $col_reserve_blob2 = ['type' => 'blob', 'lazy' => true];
    var $col_reserve_blob3 = ['type' => 'blob', 'lazy' => true];

    // indexes
    var $idx_hash = ['cols' => 'hash', 'unique' => true];
    var $idx_id_type = ['cols' => ['id', 'type']];
    var $idx__id_user_num_utime = ['cols' => [null, 'user_num', 'utime']];
    var $idx_id__id = ['cols' => ['id', null]];
    var $idx_id_type__id = ['cols' => ['type', null]];
    var $idx_utime_user_num = ['cols' => ['utime', 'user_num']];
    var $idx_utime_user_num__id = ['cols' => ['utime', 'user_num', null]];

    function __construct(& $row)
    {
        parent::__construct($row);
    }

}

/**
 * RSS Item table class
 *
 * @author  Eiji TAEN    2005/05
 * @version 1.0
 * @package grn.common.rss
 */
class GRN_RSS_Item extends CB_PersistentBase
{
    // relation to channel
    var $col_channel = ['type' => 'relation', 'to' => 'GRN_RSS_Channel'];
    // item ID
    var $col_id = ['type' => 'char', 'length' => CB_DATABASE_MAX_STRINDEX];
    // item title
    var $col_title = ['type' => 'char', 'length' => 0xFFFF];
    // item url
    var $col_url = ['type' => 'char', 'length' => CB_DATABASE_MAX_STRINDEX];
    // item description
    var $col_description
        = [
            'type'   => 'char',
            'length' => '65535',
            'lazy'   => true
        ];
    // item category
    var $col_category = ['type' => 'char'];
    // item publication time
    var $col_ptime = ['type' => 'timestamp'];
    // item update time
    var $col_utime = ['type' => 'timestamp'];
    // item author
    var $col_author = ['type' => 'char'];

    // reserved columns 
    var $col_reserve_text1 = ['type' => 'char', 'lazy' => true];
    var $col_reserve_text2 = ['type' => 'char', 'lazy' => true];
    var $col_reserve_text3 = ['type' => 'char', 'lazy' => true];
    var $col_reserve_int1 = ['type' => 'int', 'lazy' => true];
    var $col_reserve_int2 = ['type' => 'int', 'lazy' => true];
    var $col_reserve_int3 = ['type' => 'int', 'lazy' => true];
    var $col_reserve_blob1 = ['type' => 'blob', 'lazy' => true];
    var $col_reserve_blob2 = ['type' => 'blob', 'lazy' => true];
    var $col_reserve_blob3 = ['type' => 'blob', 'lazy' => true];

    // indexes
    var $idx_channel_id_ptime = ['cols' => ['channel', 'id', 'ptime']];
    var $idx_utime = ['cols' => ['utime']];
    var $idx_channel_ptime = ['cols' => ['channel', 'ptime']];
    var $idx_channel_utime = ['cols' => ['channel', 'utime']];
    var $idx_channel__id_ptime = ['cols' => ['channel', null, 'ptime']];
    var $idx_channel__id_utime = ['cols' => ['channel', null, 'utime']];
    var $idx_channel__id_ptime_utime
        = [
            'cols' => [
                'channel',
                null,
                'ptime',
                'utime'
            ]
        ];
    var $idx_channel_ptime_utime = ['cols' => ['channel', 'ptime', 'utime']];
    var $idx_channel_ptime_utime__id
        = [
            'cols' => [
                'channel',
                'ptime',
                'utime',
                null
            ]
        ];

    function __construct(& $row)
    {
        parent::__construct($row);
    }
}

/**
 * RSS Parser Base class
 *
 * @author  Eiji TAEN    2005/04
 * @version 1.0
 * @package grn.common.rss
 * @abstract
 */
class GRN_RSS_ParserBase
{
    /**
     * parser type
     *
     * @access   private
     */
    var $_type;

    var $_parent;
    var $_startCondtionFunc = null;
    var $_endConditionFunc = null;
    var $_parseFunc = null;

    /**
     * @access   protected
     */
    var $_reader;

    /**
     * @access   protected
     */
    var $_elementInfo = [];

    /**
     * @access   protected
     */
    var $_openResource = false;

    /**
     * @access   protected
     */
    var $_parsing;

    /**
     * constructor
     *
     * @param   string $parser_type parser type
     */
    function __construct($parser_type = null)
    {
        $this->_reader = new XMLReader();
        $this->_type = $parser_type;
    }

    /**
     * get parser type
     *
     * @return   string   parser type
     */
    function getType()
    {
        return $this->_type;
    }

    function open($file_path)
    {
        if ( ! $this->_openResource) {
            $this->_openResource = $this->_reader->open($file_path);
            $this->_parseInit();
        }
    }

    function close()
    {
        if ($this->_openResource) {
            $this->_reader->close();
            $this->_openResource = false;
        }
    }

    /**
     * @access   protected
     */
    function _parseInit()
    {
        $this->_node_stack = [['tag' => '', 'localtag' => '', 'ns' => '']];
    }

    /**
     * check rss/rdf data format
     * you must override this function in the inherited class.
     *
     * @param    object $cache GRN_RSS_Cache
     * @param    array  $error error information
     * @param   string  $tag   identification tag (e.g. 'rss')
     *
     * @return   bool
     */
    function checkFormat(& $cache, & $error, $tag = null)
    {
        $matched = false;

        $this->_reader->open($cache->getFilePath());

        $counter = 0;
        while (@$this->_reader->read()) {
            if ($this->_reader->depth > 0) {
                break;
            }

            if (strcmp(strtoupper($this->_reader->name), $tag) === 0) {
                $matched = true;
            }
        }

        $error = libxml_get_errors();
        $this->_reader->close();
        $this->_openResource = false;

        return $matched;
    }

    /**
     * you must override this function in the inherited class.
     */
    function setStartConditionFunc($func)
    {
        $this->_startConditionFunc = $func;
    }

    /**
     * you must override this function in the inherited class.
     */
    function setEndConditionFunc($func)
    {
        $this->_endConditionFunc = $func;
    }

    /**
     * you must override this function in the inherited class.
     */
    function setParseFunc($func)
    {
        $this->_parseFunc = $func;
    }

    /**
     * parse rss/rdf data
     *
     * @access   protected
     *
     * @param string $tag
     * @param string $map
     *
     * @return   bool
     */
    function _parse($tag = null, $map = null)
    {
        $this->_parsing = false;

        while (@$this->_reader->read()) {
            switch ($this->_reader->nodeType) {
                case XMLReader::ELEMENT:
                    $ret = $this->_parseElement();
                    if (is_bool($ret)) {
                        return $ret;
                    }

                    break;

                case XMLReader::END_ELEMENT:
                    $ret = $this->_parseEndElement();
                    if (is_bool($ret)) {
                        return $ret;
                    }

                    break;
            }
        }

        // check parse error
        //$error_list = $this->_reader->getErrors();

        return $this->_parsing;
    }

    /**
     * @access   protected
     */
    function _parseElement()
    {
        $tag = strtoupper($this->_reader->name);
        $localtag = strtoupper($this->_reader->localName);
        $ns = strtoupper($this->_reader->prefix);
        $parent = end($this->_node_stack);

        // empty element is like a '<image ... />'
        if ($this->_reader->isEmptyElement == 0) {
            array_push($this->_node_stack, [
                'tag'      => $tag,
                'localtag' => $localtag,
                'ns'       => $ns
            ]);
        }

        $tag_properties = @ $this->{'_' . $parent['localtag'] . '_Tag'};

        if (is_array($tag_properties)
            && array_key_exists($parent['ns'], $tag_properties)
            && array_key_exists($ns, $tag_properties[$parent['ns']]['children'])
            && in_array($localtag,
                $tag_properties[$parent['ns']]['children'][$ns])
        ) {
            // accepted tag
            if ( ! $this->_parsing) {
                $this->_parsing = call_user_func([
                    & $this,
                    $this->_startConditionFunc
                ]);
                if ($this->_parsing) {
                    $ret = call_user_func([& $this, $this->_parseFunc]);
                    if ( ! $ret) {
                        return $this->_parsing;
                    }
                }
            } else {
                $ret = call_user_func([& $this, $this->_parseFunc]);
                if ( ! $ret) {
                    return $this->_parsing;
                }
            }
        }
        /*
        else
        {
            // skip は動作が怪しい
            $this->_reader->skip();
        }
         */
    }

    /**
     * @access   protected
     */
    function _parseEndElement()
    {
        if ($this->_parsing) {
            if (call_user_func([& $this, $this->_endConditionFunc])) {
                array_pop($this->_node_stack);

                return $this->_parsing;
            }
        }

        array_pop($this->_node_stack);
    }

    /**
     * get channel information
     * you must override this function in the inherited class.
     *
     * @param    resource $fh    file handler
     * @param    array    $error error information
     *
     * @return   mixed      channel info array
     *                      return FALSE if the channel info doesn't exist in the RSS data
     *
     * return['title']       => string   channel title
     *       ['channel_url'] => string   channel URL
     *       ['description'] => string   channel description
     *       ['ptime']       => string   channel published time
     */
    function getChannelInfo($fh, & $error)
    {
        return false;
    }

    /**
     * get channel information
     * you must override this function in the inherited class.
     *
     * @param    resource $fh    file handler
     * @param    array    $error error information
     *
     * @return   mixed      channel info array
     *                      return FALSE if the channel info doesn't exist in the RSS data
     *
     * return['id']          => string   item id
     *       ['title']       => string   item title
     *       ['url']         => string   item URL
     *       ['description'] => string   item description
     *       ['category']    => string   item category
     *       ['ptime']       => string   item published time
     *       ['author']      => string   item author
     */
    function getItemInfo($fh, & $error)
    {
        return false;
    }

}

/**
 * RSS Service class
 *
 * @author  Eiji TAEN    2005/06
 * @version 1.0
 * @package grn.common.rss
 */
class GRN_RSS_Service extends CB_ModuleBase
{
    /**
     * rss parsers
     *
     * @access   private
     */
    var $_parsers = [];

    /**
     * plugin loader
     *
     * @access   private
     */
    var $_loader = null;

    /**
     * rss parser list
     *
     * @access   private
     */
    var $_parser_list = null;

    /**
     * constructor
     */
    function __construct()
    {
        parent::__construct(GRN_RSS_MODULEID);
    }

    /**
     * get instance
     *
     * @return   GRN_RSS_Service
     */
    public static function getInstance()
    {
        static $_instance = null;

        if (is_null($_instance)) {
            $_instance = new GRN_RSS_Service();
        }

        return $_instance;
    }

    /**
     * load RSS parser which is the most suitable for $file
     *
     * @param    object $cache GRN_RSS_Cache
     * @param    string $error parse error information
     *
     * @return   mixed      GRN_RSS_ParserBase
     *                      if parser plugins don't fit $file, return FALSE.
     */
    function loadParser(& $cache, & $error)
    {
        if (is_null($this->_parser_list)) {
            $this->_loader = $this->getPluginLoader();
            $this->_parser_list = $this->_loader->listFiles();
        }

        foreach ($this->_parser_list as $path) {
            if ( ! array_key_exists($path, $this->_parsers)) {
                $this->_parsers[$path]
                    = $this->_loader->loadDriver(basename($path, '.csp'));
            }

            if ($this->_parsers[$path]->checkFormat($cache, $error)) {
                return $this->_parsers[$path];
            }

            if (count($error) > 0) {
                $___ret = false;

                return $___ret;
            }
        }

        {
            $___ret = false;

            return $___ret;
        }
    }

    /**
     * sync RSS data
     *
     * @param    string $url channel feed url
     *
     * @option   int      $timeout       timeout second (default: 30)
     * @option   string   $customer_no   customer number (default: '')
     * @option   int      $max_update_item_num
     * @return   object   GRN_RSS_Channel
     */
    function syncData(
        $url,
        $timeout = 30,
        $customer_no = '',
        $max_update_item_num = -1,
        $throw_conn_err = false,
        $shared_site = false
    ) {
        $update_list = [];
        $ret = $this->getSyncDataList($url, $update_list, $timeout,
            $customer_no,
            $max_update_item_num,
            GRN_RSS_CHANNEL_TYPE_GENERAL, true, $throw_conn_err, $shared_site);

        return $ret;
    }

    function getSyncDataList(
        $url,
        & $update_list,
        $timeout = 30,
        $customer_no = '',
        $max_update_item_num = -1,
        $channel_type = GRN_RSS_CHANNEL_TYPE_GENERAL,
        $future = true,
        $throw_conn_err = false,
        $shared_site = false
    ) {
        $error = [];

        $manager = GRN_RSS_Manager::getInstance();
        $row = $manager->getChannel($url);
        $last_modified = '';
        if ($row) {
            $last_modified = $row->get('last_modified');
        } else {
            $row = $manager->updateChannel($url, ['id' => $url]);
            $row->updateNow();
        }

        // update utime and type --------------------------------------------------------
        $utime = new CB_TimeStamp();
        $utime->unix_ts = time();
        $row = $manager->updateChannel($url, [
            'utime' => $utime,
            'type'  => $channel_type
        ]);
        $row->updateNow();

        // get cache file
        $cache = new GRN_RSS_Cache($url);

        // fetch data -------------------------------------------------------------------
        $error_code = null;
        $fetch = GRN_RSS_Fetch::getInstance();
        $channel_status = $fetch->execute($url, $error_code, $last_modified,
            $timeout,
            $customer_no);
        if ($channel_status === false) // error or not modified
        {
            if (is_null($error_code)) // not modified
            {
                // clear error code
                $row = $manager->updateChannel($url, ['error_code' => '']);
            } else {
                require_once('grn/logger.csp');
                $cid = '';
                global $G_container_base;
                $uum = $G_container_base->getInstance('uum');
                $user = $uum->getLoginUser();
                if ( ! $user) {
                    // scheduling servise is Administrator
                    $user_id = 1;
                } else {
                    $user_id = $user->getOID();
                }
                if ('connection_error' == substr($error_code, 0, 16)) {
                    // warning log connection_error
                    if ($row) {
                        $cid = $row->getOID();
                    }
                    $error_code_array = explode(':', $error_code);
                    require_once('rss/inspection.csp');
                    $inspection = GRN_Rss_Inspection::getInstance();
                    $inspection->writeInspectionLogWarning('rss_http_error',
                        [
                            'cid'    => $cid,
                            'status' => $error_code_array[1],
                            'url'    => $url,
                            'cache'  => grn_rss_cache_path($url),
                            'uid'    => $user_id
                        ]);
                    if ($throw_conn_err) {
                        require_once('rss/error_code.csp');
                        switch ($error_code_array[1]) {
                            case '1':
                                cb_throw_error(E_GRN_RSS_CURL_ERROR_1);
                                break;
                            case '28':
                                //When the reason of timeout is address resolving or data retrieving,
                                //the return code is 28.
                                //So we have to distinguish it by the error message string.
                                if ('Resolving host'
                                    == substr($error_code_array[2], 0, 14)
                                ) {
                                    cb_throw_error(E_GRN_RSS_CURL_ERROR_RESOLVTIMEOUT);
                                } else {
                                    cb_throw_error(E_GRN_RSS_CURL_ERROR_TIMEOUT);
                                }
                                break;
                            default:
                                cb_throw_error(E_GRN_RSS_CURL_ERROR_DEFAULT);
                                break;
                        }
                    }
                }
                $row = $manager->updateChannel($url,
                    ['error_code' => $error_code]);
                // error log
                if ($row) {
                    $cid = $row->getOID();
                }
                $error_code_array = explode(':', $error_code);
                require_once('rss/inspection.csp');
                $inspection = GRN_Rss_Inspection::getInstance();
                $inspection->writeInspectionLogWarning('rss_http_error',
                    [
                        'cid'    => $cid,
                        'status' => $error_code_array[1],
                        'url'    => $url,
                        'cache'  => grn_rss_cache_path($url),
                        'uid'    => $user_id
                    ]);
            }
            $row->updateNow();

            return $row;
        } elseif ($channel_status !== true) // update last_modified value
        {
            $row = $manager->updateChannel($url,
                ['last_modified' => $channel_status]);
            $row->updateNow();
        }

        // load parser ------------------------------------------------------------------
        $parser = $this->loadParser($cache, $error);
        if ( ! $parser) // error
        {
            if (count($error) > 0) {
                $error_code = 'parse_error';
            } else {
                $error_code = 'no_parser';
            }
            $row = $manager->updateChannel($url, ['error_code' => $error_code]);
            $row->updateNow();

            // error log parser
            $cid = '';
            if ($row) {
                $cid = $row->getOID();
            }
            require_once('grn/logger.csp');
            require_once('rss/inspection.csp');
            $inspection = GRN_Rss_Inspection::getInstance();
            global $G_container_base;
            $uum = $G_container_base->getInstance('uum');
            $user = $uum->getLoginUser();
            if ( ! $user) {
                // scheduling servise is Administrator
                $user_id = 1;
            } else {
                $user_id = $user->getOID();
            }
            $inspection->writeInspectionLogWarning('rss_parse_error',
                [
                    'cid'   => $cid,
                    'error' => $error_code,
                    'url'   => $url,
                    'cache' => grn_rss_cache_path($url),
                    'uid'   => $user_id
                ]);

            return $row;
        }

        // open cache file
        $ch = $cache->getFilePath();

        // parse channel data ---------------------------------------------------------
        $channel = $parser->getChannelInfo($ch, $error);
        $row = $this->_insertErrorCode($url, $channel, $error);
        if ($row) {
            return $row;
        }

        // update channel data -------------------------------------------------------
        if ( ! array_key_exists('ptime', $channel)) {
            $channel['ptime'] = new CB_TimeStamp();
        }
        $channel_row = $manager->updateChannel($url, $channel);

        // close cache file
        $parser->close();

        // open cache file
        $ch = $cache->getFilePath();

        // parse item data -----------------------------------------------------------
        if ($max_update_item_num == -1) {
            $max_update_item_num = grn_rss_get_max_update_item_num();
        }
        $update_counter = 0;
        while (($item = $parser->getNextItemInfo($ch, $error)) !== false) {
            $row = $this->_insertErrorCode($url, $item, $error);
            if ($row) {
                return $row;
            }

            // update item data ------------------------------------------------------
            // if $item['id'] doesn't exist, $item will be ignored.
            if (array_key_exists('id', $item)) {
                $updated = false;
                $rewrite = true; // permit rewriting an item
                $item['utime'] =& $utime;
                if ( ! array_key_exists('ptime', $item)) {
                    // item の発行日時が存在しない場合には channel の発行日時を採用し、
                    // 新規の item の場合のみ登録
                    $item['ptime'] =& $channel['ptime'];
                    $rewrite = false;
                }
                $item_row = $manager->updateItem($url, $item['id'], $item,
                    $updated,
                    $rewrite, $future);
                if ( ! $item_row || ! is_object($item_row)) {
                    continue;
                }

                $target = '';
                $target = $shared_site ? 'personal_rss' : 'system_rss';
                //write log notice get article 
                $cid = $channel_row->getOID();//channel ID
                $aid = $item_row->getOID();//article ID
                $url = $channel_row->get('id');// URL
                require_once('rss/inspection.csp');
                $inspection = GRN_Rss_Inspection::getInstance();
                if ($inspection->isInfoEnabled()) {
                    $inspection->writeInspectionLogInfo('create', $target,
                        ['cid' => $cid, 'aid' => $aid, 'url' => $url]);
                }
                if ($updated && $item_row) {
                    $item_row->updateNow();
                    $update_counter++;
                    $update_list[] = $item['id'];
                    if ($update_counter >= $max_update_item_num) {
                        break;
                    }
                }
            }
        }

        // clear error code
        $row = $manager->updateChannel($url, ['error_code' => '']);
        $row->updateNow();

        // close cache file
        $parser->close();

        // delete cache file
        $cache->delete();

        return $channel_row;
    }

    /**
     * @access   private
     */
    function _insertErrorCode($url, $data, $error)
    {
        if ( ! $data) {
            if (count($error) > 0) {
                $error_code = 'parse_error';

                $manager = GRN_RSS_Manager::getInstance();
                $row = $manager->updateChannel($url,
                    ['error_code' => $error_code]);
                $row->updateNow();

                // error log
                $cid = '';
                if ($row) {
                    $cid = $row->getOID();
                }
                require_once('rss/inspection.csp');
                $inspection = GRN_Rss_Inspection::getInstance();
                $inspection->writeInspectionLog(CB_LOGGER_ERROR,
                    '[rss.error] error=' . $error_code . ', url=' . $url
                    . ', cache=' . grn_rss_cache_path($url) . ' (cid:' . $cid
                    . ')');
            }

            return $row;
        }

        {
            $___ret = false;

            return $___ret;
        }
    }

}

/**
 * RSS Data Manager class
 *
 * @author  Eiji TAEN    2005/05
 * @version 1.0
 * @package grn.common.rss
 */
class GRN_RSS_Manager
{
    /**
     * channel table
     *
     * @access   private
     */
    var $_tab_channel;

    /**
     * item table
     *
     * @access   private
     */
    var $_tab_item;

    /**
     * data cache
     *
     * @access   private
     */
    var $_caches;

    /**
     * constructor
     */
    function __construct()
    {
        global $G_container_base;
        $manager = $G_container_base->getInstance('table_manager');
        $this->_tab_channel = $manager->getTableInfo('GRN_RSS_Channel');
        $this->_tab_item = $manager->getTableInfo('GRN_RSS_Item');

        $this->_caches = ['channel' => []];
    }

    /**
     * get instance
     *
     * @return   GRN_RSS_Manager
     */
    public static function getInstance()
    {
        static $_instance = null;

        if (is_null($_instance)) {
            $_instance = new GRN_RSS_Manager();
        }

        return $_instance;
    }

    /**
     * @access   private
     */
    function &_getCache($category, $key)
    {
        if (array_key_exists($key, $this->_caches[$category])) {
            return $this->_caches[$category][$key];
        }

        {
            $___ret = false;

            return $___ret;
        }
    }

    /**
     * @access   private
     */
    function _setCache($category, $id, & $cache)
    {
        $this->_caches[$category][$id] =& $cache;
    }

    /**
     * get specified channel CB_Row
     *
     * @param    string $id channel ID
     *
     * @return   mixed    GRN_RSS_Channel
     *                    if specified channel doesn't exist, return FALSE.
     */
    function getChannel($id)
    {
        if ($id === '') {
            $___ret = false;

            return $___ret;
        }

        if ($cache =& $this->_getCache('channel', $id)) {
            return $cache;
        }

        $db = $this->_tab_channel->getDBConnection();

        $rowset = new CB_RowSet($this->_tab_channel);
        $rowset->addCondition(cb_queryf($db, 'col_id = \'@S\'', $id));
        $rowset->limit(0, 1);
        $rowset->setLock(CB_DATABASE_NO_LOCK);

        $row = $rowset->iterate();
        $rowset->destroy();

        if (is_null($row)) {
            $___ret = false;

            return $___ret;
        }

        $this->_setCache('channel', $id, $row);

        return $row;
    }

    /**
     * add channel (fast version)
     *
     * @param    string $id    channel ID (channel feed URL)
     * @param    string $title channel title
     * @param    int    $type  0: general, 1: cybozu info (default: 0)
     *
     * @return   object   GRN_RSS_Channel
     */
    function addChannelFast($id, $title, $type = 0)
    {
        require_once('fw/string_util.csp');
        $row = $this->_tab_channel->newRow();
        $row->set('id', $id);
        $row->set('type', $type);
        $row->set('title', cb_trim($title));

        return $row;
    }

    /**
     * update specified channel data
     *
     * @param    string $id      channel ID
     * @param    array  $channel channel data
     *
     * @option   int      $type      0: general, 1: cybozu info (default: 0)
     * @option   boolean  $rewrite   forced rewrite (default: TRUE)
     * @return   object   GRN_RSS_Channel
     *
     * $channel['title']         => string   channel title
     *         ['channel_url']   => string   channel URL
     *         ['description']   => string   channel description
     *         ['ptime']         => object   CB_TimeStamp   channel published time
     *         ['utime']         => object   CB_TimeStamp   channel updated time
     *         ['last_modified'] => string   HTTP Last-Modified field value
     *         ['user_num']      => string   how many user subscribe this channel
     *         ['error_code']    => string   fetch/parse error code
     *         ['type']          => string   channel type
     */
    function updateChannel($id, $channel, $type = 0, $rewrite = true)
    {
        $col_list = [
            'title',
            'channel_url',
            'description',
            'ptime',
            'utime',
            'last_modified',
            'user_num',
            'error_code',
            'type'
        ];
        $text_col_list = ['title', 'channel_url', 'description'];

        $row = $this->getChannel($id);
        if ($row === false) {
            $row = $this->_tab_channel->newRow();
            $row->set('id', $id);
            $row->set('hash', sha1($id));
            $row->set('type', $type);
        } elseif ( ! $rewrite) {
            return $row;
        }

        require_once('fw/string_util.csp');

        if (array_key_exists('title', $channel)) {
            $row->set('title', cb_trim($channel['title']));
            unset($channel['title']);
        }

        foreach ($channel as $key => $value) {
            if (in_array($key, $col_list)) {
                if (in_array($key, $text_col_list)) {
                    $row->set($key, cb_trim($value));
                } else {
                    $row->set($key, $value);
                }
            }
        }

        return $row;
    }

    /**
     * delete specified channel data
     *
     * @param    string $id channel ID
     *
     * @return   boolean   TRUE: success deleting specified channel
     */
    function deleteChannel($id)
    {
        $row = $this->getChannel($id);
        if ($row === false) {
            return false;
        }

        $row->delete();

        return true;
    }

    /**
     * get specified item CB_Row
     *
     * @param    string $channel_id channel ID (channel feed URL)
     * @param    string $item_id    item ID
     *
     * @return   mixed    item CB_Row
     *                    if specified item doesn't exist, return FALSE.
     */
    function getItem($channel_id, $item_id)
    {
        if ($channel_id === '' || $item_id === '') {
            $___ret = false;

            return $___ret;
        }

        $db = $this->_tab_item->getDBConnection();

        $rowset = new CB_RowSet($this->_tab_item);
        $rowset->addJoin($this->_tab_channel,
            cb_queryf($db,
                'c.col_id = \'@S\' AND c._id = tab_grn_rss_item.col_channel AND tab_grn_rss_item.col_id = \'@S\'',
                $channel_id, $item_id),
            CB_DATABASE_INNER_JOIN,
            'c');
        $rowset->limit(0, 1);
        $rowset->setLock(CB_DATABASE_NO_LOCK);

        $row = $rowset->iterate();
        $rowset->destroy();

        if (is_null($row)) {
            $___ret = false;

            return $___ret;
        }

        return $row;
    }

    /**
     * update specified item data
     *
     * @param    string  $channel_id channel ID (channel feed URL)
     * @param    string  $item_id    item ID
     * @param    array   $item       item data
     * @param    boolean $updated    set TRUE if the item is updated
     * @param    boolean $rewrite    forced rewrite (default: TRUE)
     * @param    boolean $future     accept future date
     *
     * @return   mixed    CB_Row item row
     *                    if specified channel doesn't exist, return FALSE.
     *
     * $item['title']       => string   item title
     *      ['url']         => string   item URL
     *      ['description'] => string   item description
     *      ['category']    => string   item category
     *      ['ptime']       => object   CB_TimeStamp   item published time
     *      ['utime']       => object   CB_TimeStamp   item updated time
     *      ['author']      => string   item author
     */
    function updateItem(
        $channel_id,
        $item_id,
        $item,
        & $updated,
        $rewrite = true,
        $future = true
    ) {
        $updated = false;

        if ( ! $future && $item['ptime']->unix_ts > time()) {
            $___ret = false;

            return $___ret;
        }

        $channel_row = $this->getChannel($channel_id);
        if ($channel_row === false) {
            $___ret = false;

            return $___ret;
        }

        $col_list = [
            'title',
            'url',
            'description',
            'category',
            'ptime',
            'utime',
            'author'
        ];

        $item_row = $this->getItem($channel_id, $item_id);
        if ($item_row === false) {
            $item_row = $this->_tab_item->newRow();
            $item_row->set('channel', $channel_row);
            $item_row->set('id', $item_id);
        } elseif ( ! $rewrite) {
            return $item_row;
        } else {
            $ptime = $item_row->get('ptime');
            if ($ptime->unix_ts >= $item['ptime']->unix_ts) {
                return $item_row;
            }
        }
        $updated = true;

        if (array_key_exists('title', $item)) {
            require_once('fw/string_util.csp');
            $item_row->set('title', cb_trim($item['title']));
            unset($item['title']);
        }

        foreach ($item as $key => $value) {
            if (in_array($key, $col_list)) {
                $item_row->set($key, $value);
            }
        }

        return $item_row;
    }

    /**
     * delete specified item data
     *
     * @param    string $channel_id channel ID
     * @param    string $item_id    item ID
     *
     * @return   boolean
     */
    function deleteItem($channel_id, $item_id)
    {
        $row = $this->getItem($channel_id, $item_id);
        if ($row === false) {
            return false;
        }

        $row->delete();

        return true;
    }

    /**
     * delete items
     *
     * @param    string $channel_id channel ID
     *
     * @option   boolean  $update_now
     */
    function deleteItems($channel_id, $update_now = false)
    {
        if (strlen($channel_id) === 0) {
            return;
        }

        $db = $this->_tab_item->getDBConnection();

        $rowset = new CB_RowSet($this->_tab_item);
        $rowset->addCondition(cb_queryf($db, 'col_channel = \'@S\'',
            $channel_id));
        $rowset->setLock(CB_DATABASE_NO_LOCK);

        while ( ! is_null($row = $rowset->iterate())) {
            $row->delete();
            if ($update_now) {
                $row->updateNow();
            }
        }
    }

    /**
     * delete old items
     *
     * @param   object $timestamp    CB_TimeStamp
     * @param   string $channel_type channel type
     */
    function deleteOldItems(
        $timestamp,
        $channel_type = GRN_RSS_CHANNEL_TYPE_GENERAL
    ) {
        $db = $this->_tab_item->getDBConnection();

        $rowset = new CB_RowSet($this->_tab_item);
        $rowset->addJoin($this->_tab_channel,
            cb_queryf($db,
                'col_type = \'@S\' AND c._id = tab_grn_rss_item.col_channel',
                $channel_type),
            CB_DATABASE_INNER_JOIN,
            'c');
        $rowset->addCondition(cb_queryf($db,
            'tab_grn_rss_item.col_utime < \'@S\'', $timestamp));
        $rowset->setLock(CB_DATABASE_NO_LOCK);

        while ( ! is_null($row = $rowset->iterate())) {
            $row->delete();
        }
    }

    /**
     * get item list
     *
     * @param    string $channel_id channel id
     *
     * @option   int      $offset       start position (default: 0)
     * @option   int      $limit        item number you wanna get (default: 20)
     * @option   array    $sort         sort properties (default: array( 'ptime' => TRUE ) )
     * @option   boolean  $show_feature TRUE: show feature item (default: FALSE)
     * @return   array    item list
     *
     * $sort[column name] => boolean   TRUE: sort in descending order
     *                                 FALSE: sort in ascending order
     *
     * return['title'] => item title
     *       ['url']   => item url
     *       ['ptime'] => item ptime
     *       ['utime'] => item utime
     *
     */
    function getItemList(
        $channel_id,
        $offset = 0,
        $limit = 20,
        $sort = ['ptime' => true, 'utime' => true],
        $show_feature = false
    ) {
        if (strlen($channel_id) === 0) {
            return;
        }

        global $G_container_base;
        $db = $G_container_base->getInstance('dbconn');

        $subquery
            = 'SELECT c._id FROM tab_grn_rss_channel c WHERE c.col_id = \''
              . $db->escape($channel_id) . '\'';

        $columns = [
            'i._id i_id',
            'i.col_id iid',
            'i.col_title ititle',
            'i.col_url iurl',
            'i.col_ptime iptime',
            'i.col_utime iutime'
        ];

        $condition = '';
        if ( ! $show_feature) {
            $condition = 'i.col_ptime <= ' . time() . ' AND ';
        }

        $order_bys = [];
        foreach ($sort as $col => $rev) {
            $order_bys[] = 'i.col_' . $col . ($rev ? ' DESC' : '');
        }
        $order_bys[] = 'i._id' . ($rev ? ' DESC' : '');

        $query = 'SELECT ' . implode(', ', $columns)
                 . ' FROM tab_grn_rss_item i WHERE ' . $condition
                 . 'i.col_channel = (' . $subquery . ')' . ' ORDER BY '
                 . implode(', ', $order_bys);
        $query = $db->select_format($query, $offset, $limit,
            CB_DATABASE_NO_LOCK);

        $result = $db->query($query);
        if ($result === false) {
            $db->throwError(['query' => 'failed query on SELECT: ' . $query]);
        }

        $ptime = new CB_TimeStamp();
        $utime = new CB_TimeStamp();
        $item_list = [];
        while ($row = $db->fetch_assoc($result)) {
            $ptime->unix_ts = $row['iptime'];
            $utime->unix_ts = $row['iutime'];
            $item_list[$row['iid']] = [
                'oid'   => $row['i_id'],
                'title' => $row['ititle'],
                'url'   => $row['iurl'],
                'ptime' => clone $ptime,
                'utime' => clone $utime
            ];
        }

        return $item_list;
    }

    /**
     * get specified channel's item number
     *
     * @param    string $channel_id
     *
     * @return   int
     */
    function getItemNum($channel_id, $show_feature = false)
    {
        if (strlen($channel_id) === 0) {
            return 0;
        }

        global $G_container_base;
        $db = $G_container_base->getInstance('dbconn');

        $condition = '';
        if ( ! $show_feature) {
            $condition = ' AND i.col_ptime <= ' . time();
        }

        $query
            = 'SELECT COUNT(*) count FROM tab_grn_rss_item i, tab_grn_rss_channel c WHERE c.col_id = \''
              . $db->escape($channel_id) . '\' AND col_channel = c._id'
              . $condition;
        $result = $db->query($query);
        if ($result === false) {
            $db->throwError(['query' => 'failed query on SELECT: ' . $query]);
        }

        $row = $db->fetch_assoc($result);

        return $row['count'];
    }

}

/**
 * RSS data fetch class
 *
 * @author  Eiji TAEN    2005/03
 * @version 1.0
 * @package grn.common.rss
 */
class GRN_RSS_Fetch
{
    /**
     * constructor
     */
    function __construct()
    {
        //
    }

    /**
     * get instance
     *
     * @return   GRN_RSS_Fetch
     */
    public static function getInstance()
    {
        static $_instance = null;

        if (is_null($_instance)) {
            $_instance = new GRN_RSS_Fetch();
        }

        return $_instance;
    }

    /**
     * fetch RSS data
     *
     * @param    string $url   RSS/RDF/ATOM data URL
     * @param    string $error error code
     *
     * @option   string   $last_modified   HTTP Last-Modifed field value (default: '')
     * @option   int      $timeout         timeout second (default: 30)
     * @option   string   $customer_no     customer number (default: '')
     * @return   mixed    string     HTTP Last-Modifed field value
     *                    boolean   return TRUE if RSS data wasn't modified
     *                              return FALSE if RSS data wasn't modified or error
     *
     * return['last_modified'] => string   HTTP Last-Modifed field value
     *       ['error_code']    => string   error no
     */
    function execute(
        $url,
        & $error,
        $last_modified = '',
        $timeout = 30,
        $customer_no = '',
        $org_url = ''
    ) {
        require_once('grn/http_proxy.csp');
        $phc = new GRN_ProxyHttpClient();
        $hc = $phc->getHttp();
        $ch = $hc->getCurlHandle();
//        curl_setopt( $ch, CURLOPT_CONNECTTIMEOUT, $timeout );
        $hc->setCurlOption(CURLOPT_USERAGENT, GRN_RSS_USERAGENT);
        $hc->setCurlOption(CURLOPT_TIMEOUT, $timeout);
//        curl_setopt( $ch, CURLOPT_USERAGENT, GRN_RSS_USERAGENT );
//        curl_setopt( $ch, CURLOPT_TIMEOUT, $timeout );
        if ($last_modified) {
            $hc->setCurlOption(CURLOPT_HTTPHEADER,
                ['If-Modified-Since: ' . $last_modified]);
//            curl_setopt( $ch, CURLOPT_HTTPHEADER,
//                         array( 'If-Modified-Since: ' . $last_modified ) );
        }

        if ($phc->execute($url . $customer_no)) {
            $status_line = $hc->getStatusLine();

            $status_code = -1;
            if (array_key_exists('status-code', $status_line)) {
                $status_code = $status_line['status-code'];
            }

            switch ($status_code) {
                case 200: // OK
                    if ( ! $org_url) {
                        $org_url = $url;
                    }
                    grn_rss_make_cache_dir();
                    $fh = fopen(grn_rss_cache_path($org_url), 'w');
                    fwrite($fh, $hc->getBody());
                    fclose($fh);
                    $headers = $hc->getHeaders();
                    if (array_key_exists('last-modified', $headers)) {
                        return $headers['last-modified'][0];
                    }

                    return true;
                case 301: // Moved Permanently
                case 302: // Found
                case 303: // See Other
                    if ( ! $org_url) {
                        $org_url = $url;
                    }
                    $headers = $hc->getHeaders();
                    if (array_key_exists('location', $headers)) {
                        // redirect
                        return $this->execute($headers['location'][0], $error,
                            $last_modified,
                            $timeout, $customer_no, $org_url);
                    } else {
                        $error = 'http_error:' . $status_code;

                        return false;
                    }
                    break;
                case 304: // Not Modified
                    return false;
                default:  // something wrong
                    $error = 'http_error:' . $status_code;

                    return false;
            }
        } else {
            $error = 'connection_error';
            $error_info = $hc->getError();
            if (count($error_info) > 0) {
                $error .= ':' . $error_info['errno'] . ':'
                          . $error_info['message'];
            }
        }

        return false;
    }

}

/**
 * RSS cache file class
 *
 * @author  Eiji TAEN    2005/03
 * @version 1.0
 * @package grn.common.rss
 */
class GRN_RSS_Cache
{
    /**
     * @access   private
     */
    private $_file;

    /**
     * constructor
     *
     * @param string $url
     */
    function __construct($url)
    {
        $this->_file = grn_rss_cache_path($url);
    }

    /**
     * return cache file path
     *
     * @return string
     */
    public function getFilePath()
    {
        return $this->_file;
    }

    /**
     * delete cache file
     */
    public function delete()
    {
        if (is_file($this->_file)) {
            @unlink($this->_file);
        }
    }
}

/**
 * RSS Cybozu information class
 *
 * @author  Eiji TAEN   2005/05
 * @version 1.0
 * @package grn.common.rss
 */
class GRN_RSS_CybozuInfo extends CB_ModuleBase
{
    /**
     * @access private
     */
    var $_profile = null;

    /**
     * constructor
     */
    function __construct()
    {
        parent::__construct(GRN_RSS_CYBOZU_MODULE_ID);
    }

    /**
     * @return   GRN_RSS_CybozuInfo
     */
    public static function getInstance()
    {
        static $_instance = null;
        if (is_null($_instance)) {
            $_instance = new GRN_RSS_CybozuInfo();
        }

        return $_instance;
    }

    /**
     * @access   private
     */
    function &_getProfile()
    {
        if (is_null($this->_profile)) {
            $this->_profile = $this->getSystemProfile();
        }

        return $this->_profile;
    }

    /**
     * @access   private
     *
     * @param    string $key
     * @param    string $value
     *
     * @return   string
     */
    function _getAttribute($key, & $value)
    {
        $profile = $this->_getProfile();

        return $profile->getAttribute($key, $value);
    }

    /**
     * @access   private
     *
     * @param    string $key
     * @param    string $value
     */
    function _setAttribute($key, $value)
    {
        $profile = $this->_getProfile();

        if ($profile->getAttribute($key, $dummy)) {
            $profile->updateAttribute($key, $value);
        } else {
            $profile->createAttribute($key, $value);
        }
    }

    /**
     * @return   boolean
     */
    function isActivate()
    {
        if (defined('ON_FOREST')) {
            return false;
        }

        $activation = null;
        if ( ! $this->_getAttribute('activate', $activation)) {
            return true; // default
        }

        return strcmp($activation, '0') === 0 ? false : true;
    }

    /**
     * @param    object  $user        CB_User
     * @param    boolean $is_activate TRUE: activate
     */
    function setActivateAttribute(& $user, $is_activate)
    {
        $this->_setAttribute('activate', $is_activate ? '1' : '0');

        // log
        require_once('rss/inspection.csp');
        $inspection = GRN_Rss_Inspection::getInstance();
        if ($inspection->isEnabled()) {
            $is_activate = $is_activate ? 'ON' : 'OFF';
            $inspection->writeInspectionLogNotice('config',
                'system_cybozu_information', [
                    'cybozu_information' => $is_activate,
                    'uid'                => $user->getOID()
                ]);
        }
    }

    /**
     * get a feed URL
     *
     * @param    string $name URL type name (default: '')
     *
     * @return   string   cybozu information feed URL
     */
    function getFeedURL($name = '')
    {
        if ( ! $name) {
            $customer_info = $this->getCustomerInfo();
            switch ($customer_info['license_type']) {
                case GRN_RSS_LICENSE_TYPE_VALID:
                    $name = 'url_valid';
                    break;
                case GRN_RSS_LICENSE_TYPE_EXPIRED:
                    $name = 'url_expired';
                    break;
                case GRN_RSS_LICENSE_TYPE_TRIAL:
                default:
                    $name = 'url_trial';
                    break;
            }
        }

        global $G_config_grn;
        $url = $G_config_grn->get('CybozuInfo', $name);
        if ( ! $url) {
            $url = '';
        }

        return $url;
    }

    /**
     * get cybozu information cache preservation term
     */
    function getCacheLifeTime()
    {
        global $G_config_grn;
        $ret = intval($G_config_grn->get('CybozuInfo', 'cache_lifetime'));
        if ( ! $ret) {
            $ret = GRN_RSS_CYBOZU_CACHE_LIFTTIME;
        }

        return $ret;
    }

    /**
     * get cybozu information timeout value
     */
    function getTimeout()
    {
        global $G_config_grn;
        $ret = intval($G_config_grn->get('CybozuInfo', 'timeout'));
        if ( ! $ret) {
            $ret = GRN_RSS_CYBOZU_TIMEOUT;
        }

        return $ret;
    }

    /**
     * get customer information
     *
     * @access   private
     * @return   array   customer information
     *
     * return['customer_no']  => string   customer number
     *       ['license_type'] => int      GRN_RSS_LICENSE_TYPE_[VALID|EXPIRED|TRIAL]
     */
    function getCustomerInfo()
    {
        $customer_info = [];

        require_once('grn/license.csp');
        $lm = GRN_LicenseManager::getInstance();
        $license_info = $lm->getLicense(GRN_LICENSE_BASESYSTEM);

        $customer_no = '';
        if (array_key_exists('customer', $license_info)) {
            $customer_no = $license_info['customer'];
        }
        $customer_info['customer_no'] = $customer_no;

        if ($lm->isDemoLicense($license_info['type'])) {
            $customer_info['license_type'] = GRN_RSS_LICENSE_TYPE_TRIAL;
        } else {
            $limit = $license_info['service_limit'];
            $remind_days = $lm->getRemindDays($limit,
                GRN_LICENSE_SERVICE_EXPIRED_OFFSET);
            if ($remind_days < 0) {
                // expired
                $customer_info['license_type'] = GRN_RSS_LICENSE_TYPE_EXPIRED;
            } else {
                $customer_info['license_type'] = GRN_RSS_LICENSE_TYPE_VALID;
            }
        }

        return $customer_info;
    }

    function updateNotification($item_list)
    {
        if ( ! is_array($item_list) || count($item_list) == 0) {
            return false;
        }

        // get users who has a Administrator role
        $user_list = $this->_getAdministratorList();

        if (is_array($user_list) && count($user_list) > 0
            && count($item_list) > 0
        ) {
            require_once('fw/i18n.csp');
            $sender_name = cb_msg(GRN_RSS_MODULEID, 'cybozu_name');

            require_once('grn/rss.csp');
            require_once('grn/notification.csp');
            global $G_container_base;
            $manager = $G_container_base->getInstance('table_manager');
            $tab_channel = $manager->getTableInfo('GRN_RSS_Channel');
            $tab_item = $manager->getTableInfo('GRN_RSS_Item');
//            $tab_notification =& $manager->getTableInfo( 'GRN_Notification_History' );

            // cybozu info URL
            $url = $this->getFeedURL();

            // customer info
            $customer = $this->getCustomerInfo();

            $service = GRN_Notification_Service::getInstance();

            require_once('grn/outside_application.csp');
            $app_manager = GRN_Notification_ApplicationManager::getInstance();
            // get an outside application
            $app = $app_manager->getById(GRN_RSS_CYBOZU_ID);
            // get the module id
            $module_id = $app->getModuleId();

            $dbconn = $G_container_base->getInstance('dbconn');
            $tmp_item_list = [];
            foreach ($item_list as $item) {
                array_push($tmp_item_list, $dbconn->escape($item));
            }

            foreach ($user_list as $user) {
                $rowset = new CB_RowSet($tab_item);
                $rowset->addJoin($tab_channel,
                    'c.col_id = \'' . $url . '\' AND col_type = '
                    . GRN_RSS_CHANNEL_TYPE_CYBOZU
                    . ' AND c._id = tab_grn_rss_item.col_channel',
                    CB_DATABASE_INNER_JOIN,
                    'c');
                $rowset->addCondition('tab_grn_rss_item.col_id IN (\''
                                      . implode('\',\'', $tmp_item_list)
                                      . '\')');
                $rowset->setLock(CB_DATABASE_NO_LOCK);

                while ( ! is_null($row = $rowset->iterate())) {
                    $properties = $service->getNotifyDataProperties($user,
                        $module_id,
                        $row->get('id'));
                    if (is_null($properties)) {
                        $properties = $this->_createNotificationData($module_id,
                            $row,
                            $customer['customer_no'],
                            $sender_name);
                        $properties->setStatusToUnread();

                        $service->addNotifyData($user, $properties);
                    }
                }
            }
        }
    }

    /**
     * @access   private
     */
    function _getAdministratorList()
    {
        global $G_container_base;
        $uum = $G_container_base->getInstance('uum');

        return $uum->getRoleUsers(GRN_UUM_ADMINISTRATION_ROLE, 0, -1);
    }

    /**
     * @access   private
     * @return GRN_Notification_Data
     */
    function _createNotificationData(
        $module_id,
        & $item_row,
        $customer_no,
        $sender_name
    ) {
        // create url to cybozu information
        // URL + customer number
        $url = cb_trim($item_row->get('url'));

        $properties = new GRN_Notification_Data;
        $properties->setModuleId($module_id);
        $properties->setUniqueId($item_row->get('id'));
        $properties->setSubjectData($item_row->get('title'), null, null, $url,
            GRN_RSS_CYBOZU_ICON);
        $properties->setAbstractData($item_row->get('description'), null, null,
            $url,
            null);
        $properties->setSenderData($sender_name, null, GRN_RSS_CYBOZU_URL);
        $properties->setTimeStampData($item_row->get('ptime'));
        $properties->setAutoConfirmFlag(true);

        return $properties;
    }

    /**
     * get item URL and confirm notification
     *
     * @param    object $user
     * @param    string $item_oid
     *
     * @return   mixed    string   item URL
     *                    boolean  FALSE if specified item doesn't exist
     */
    function getItem(& $user, $item_oid)
    {
        global $G_container_base;
        $manager = $G_container_base->getInstance('table_manager');
        $table = $manager->getTableInfo('GRN_RSS_Item');
        $table->setLock(CB_DATABASE_NO_LOCK);
        $item_row = $table->getRow($item_oid);

        if ( ! $item_row) {
            return false;
        }

        require_once('grn/outside_application.csp');
        $app_manager = GRN_Notification_ApplicationManager::getInstance();
        // get an outside application
        $app = $app_manager->getById(GRN_RSS_CYBOZU_ID);
        // get the module id
        $module_id = $app->getModuleId();

        $item_id = $item_row->get('id');

        // update notification data
        require_once('grn/notification.csp');
        $service = GRN_Notification_Service::getInstance();
        $properties = $service->getNotifyDataProperties($user, $module_id,
            $item_id);

        if (is_null($properties)) {
            // customer info
            $customer = $this->getCustomerInfo();

            // create notification data
            $properties = $this->_createNotificationData($module_id, $item_row,
                $customer['customer_no'],
                cb_msg(GRN_RSS_MODULEID,
                    'cybozu_name'));
            $properties->setStatusToConfirm();
            // add notification
            require_once('fw/i18n.csp');
            $service->addNotifyData($user, $properties);
        } else {
            // confirm notification
            $now = new CB_TimeStamp();
            $now->unix_ts = time();
            $service->confirmNotifyData($user, $module_id, $item_id, $now);
        }

        return $item_row->get('url');
    }

}


