<?php

/**
 * Command Line Interface API for Command Line Tools
 */


//
// Pre-Defined Common Options
//

class CB_CLI_BEFORE_OPTION extends CB_CLI_GENERIC_TIMESTAMP_OPTION
{
    function __construct($type = 0)
    {
        parent::__construct($type);
    }

    function description()
    {
        return 'Process items that have been modified prior to this date';
    }
}

class CB_CLI_HELP_OPTION extends CB_CLI_GENERIC_PRESENCE_OPTION
{
    function description()
    {
        return 'Show this help message';
    }
}

class CB_CLI_EXEC_OPTION extends CB_CLI_GENERIC_PRESENCE_OPTION
{
    function description()
    {
        return 'When specified, actually make changes to the system';
    }
}

class CB_CLI_MAX_COUNT_OPTION extends CB_CLI_GENERIC_POSITIVE_INTEGER_OPTION
{
    function description()
    {
        return 'Process a maximum number of items';
    }
}

class CB_CLI_MAX_DURATION_OPTION extends CB_CLI_GENERIC_POSITIVE_INTEGER_OPTION
{
    function description()
    {
        return 'Process items for no longer than a set duration';
    }
}

class CB_CLI_MAX_WEEK_OPTION extends CB_CLI_GENERIC_POSITIVE_INTEGER_OPTION
{
    function description()
    {
        return 'Maximum amount of week will be export to archive files';
    }
}


//
// Generic(TM) Options
//
// Extend these to get most/all of your desired parameter value processing done "for free".
//

class CB_CLI_GENERIC_POSITIVE_INTEGER_OPTION
{
    function action($g_input_value)
    {
        if ( ! preg_match('/^\d+$/', $g_input_value)) {
            // USAGE: Return CB_CLI_OPTION_ERROR to indicate an errornous $G_INPUT value.
            return CB_CLI_OPTION_ERROR;
        }

        $val = intval($g_input_value);

        return $val >= 1 ? $val : CB_CLI_OPTION_ERROR;
    }

    function usage()
    {
        return 'POSITIVE_INTEGER';
    }
}

class CB_CLI_GENERIC_PRESENCE_OPTION
{
    function action($g_input_value)
    {
        return strlen($g_input_value) == 0 ? true : CB_CLI_OPTION_ERROR;
    }

    function usage()
    {
    }
}

/*
 * Returns a CB_DateTime class instance if the input string could be parsed.
 * There are only two acceptable input formats, both patterned after "Year-Month-Day Hour:Minute:Second":
 *   '2017-08-22 12:34:56'    Full date & time specification.
 *   '2017-08-22'             Specifies the date only; the time is set to 00:00:00. The final value is '2017-08-22 00:00:00'.
 */

class CB_CLI_GENERIC_TIMESTAMP_OPTION
{
    var $_type = 0; // 0: date only, 1: full date & time

    function __construct($type = 0)
    {
        $this->_type = $type;
    }

    function action($g_input_value)
    {
        $regexes = ['/^(\d{4})-(\d{2})-(\d{2})$/']; // Date only
        if ($this->_type === 1) {
            $regexes[] = '/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})$/';
        } // Date and time

        foreach ($regexes as $regex) {
            if (preg_match($regex, $g_input_value)) {
                return _cb_date_convert_to_datetime($g_input_value);
            }
        }

        return CB_CLI_OPTION_ERROR;
    }

    function usage()
    {
        $retstr = 'YYYY-MM-DD';
        if ($this->_type === 1) {
            $retstr .= ' [HH:MM:SS]';
        }

        return $retstr;
    }
}

class CB_CLI_LOGIN_NAME_OPTION
{
    function action($_input_value)
    {
        return strlen($_input_value) >= 1 ? $_input_value : CB_CLI_OPTION_ERROR;
    }

    function usage()
    {
        return 'LOGINNAME';
    }

    function description()
    {
        return "User's login name";
    }
}

class CB_CLI_TARGET_OPTION
{
    function action($_input_value)
    {
        return ($_input_value == 'notify' || $_input_value == 'confirmed'
                || $_input_value == 'all'
                || $_input_value == 'all_without_workflow_notify')
            ? $_input_value : CB_CLI_OPTION_ERROR;
    }

    function usage()
    {
        return "'notify' or 'confirmed' or 'all' or 'all_without_workflow_notify'";
    }

    function description()
    {
        return "Select target for processing";
    }
}

//
// Public API
//

/**
 * Option action() methods indicate an error condition by returning this define value.
 */
define('CB_CLI_OPTION_ERROR', 'CB_CLI_OPTION_ERROR');

/*
 * Command-line tools call this function before processing, when they want access to the command line parameters.
 */
function cb_cli_start($mandatory = [], $other = [])
{
    _cb_cli_register_error_handler_hook();
    _cb_cli_register_option_classes();
    $other[] = new CB_CLI_HELP_OPTION();
    $opt = _cb_cli_get_options($mandatory, $other);
    _cb_cli_emit_header();

    return $opt;
}

/*
 * By convention, command line tools call this function after they have finished processing.
 */
function cb_cli_end($summary = null)
{
    _cb_cli_emit_trailer($summary);
}

/*
 * Use this function to emit messages. Messages are written to the console and to a log file.
 */
function cb_cli_log($message = "", $output_to_console = true)
{
    global $_cb_cli_log_file;
    if (empty($_cb_cli_log_file)) {
        _cb_cli_configure_logging();
    }

    // Prepare the log line
    $timestamp = _cb_date_convert_to_datetime(null);
    $line = $timestamp->format() . " $message\n";

    // Output to both stdout and the log file
    if ($output_to_console) {
        print($line);
    }
    fwrite($_cb_cli_log_file, $line);

    // Flush the output buffers so that output is preserved for the user even in the event of an error
    while (ob_get_level() > 0) {
        ob_end_flush();
    }
}

/*
 * Use this function to emit messages in console.
 */
function cb_simple_cli_log($message)
{
    require_once('fw/date.csp');
    $ts = _cb_date_convert_to_datetime(null);
    print $ts->format() . ' ' . $message . PHP_EOL;
}


//
// Private Implementation
//

/*
 * IMPLEMENTATION NOTES
 *
 * "Class Name" refers to the identifier of a class that implements option-related logic and a PHP define()
 * that conveniently represents the option. They both share the same identifier i.e. "CB_CLI_BEFORE_OPTION",
 * although in separate namespaces. Canonically upper-case.
 * "Option Name" means an option identifier as used on the command line and the value of the associated PHP
 * define() i.e. "before". Canonically lower-case.
 */

/*
 * File handle for the log file.
 */
$_cb_cli_log_file = null;

/*
 * Used to calculate the final processing duration.
 */
$_cb_cli_starting_timestamp = null;

function _cb_cli_close_logging()
{
    global $_cb_cli_log_file;
    if ($_cb_cli_log_file != null) {
        fclose($_cb_cli_log_file);
        $_cb_cli_log_file = null;
    }
}

/*
 * Configures logging: determine the log file path and then open that file in overwrite mode.
 */
function _cb_cli_configure_logging()
{
    // Determine the path and filename of the log
    $script_name = basename(_cb_cli_get_script_name());
    $found = preg_match('/(.*)\.csp$/i', $script_name, $matches);
    if ( ! $found) {
        cb_throw_error(); // Did not match the script name
    }
    $script_name = $matches[1];

    $separator = '/';
    if (strncasecmp(php_uname('s'), 'WIN', 3) == 0) {
        $separator = '\\';
    }
    $log_file = cb_basedir() . $separator . $script_name . ".log";

    // Open the log file in overwrite mode.
    global $_cb_cli_log_file;
    $_cb_cli_log_file = @fopen($log_file, 'a');

    if ( ! $_cb_cli_log_file) {
        require_once('fw/error_code.csp');
        cb_throw_error(E_COMMON_FOPEN_WRITE, null, ['file' => $log_file]);
    }

    // Register a shutdown function to close the log file
    register_shutdown_function('_cb_cli_close_logging');

    cb_cli_log("Writing to log file: $log_file"); // NOTE: This is a recursive call, but logging will be setup by this time.
}

/*
 * Summarizes how long the tool ran (in wall-clock time) and an optional message.
 */
function _cb_cli_emit_trailer($summary = null)
{
    // Calculate how long the tool ran in wall-clock time
    $_cb_cli_ending_timestamp
        = new CB_DateTimeEx(_cb_date_convert_to_datetime(null));
    global $_cb_cli_starting_timestamp;
    $duration
        = $_cb_cli_ending_timestamp->getInterval($_cb_cli_starting_timestamp);
    $duration_str = _cb_cli_seconds_to_string($duration->toSeconds());

    cb_cli_log(sprintf("Done in %s%s", $duration_str,
        strlen($summary) < 1 ? '.' : ": $summary"));
}

/*
 * Summarizes system information
 */
function _cb_cli_emit_header()
{
    // Emit Garoon version information
    global $G_config_grn;
    $grn_version = $G_config_grn->get("System", "version");
    cb_cli_log("Garoon: Version $grn_version");

    // Ask PHP for system information
    ob_start();
    phpinfo();
    $phpinfo = ob_get_clean();

    // I don't understand why, but the following regular expression will put our desired match result into
    // $matches index 1 or 2, as a function of whether the first or second regex found a match, respectively.
    $found
        = preg_match('#(?:\bSystem\s*</td><td(?: class=".*?")?>(.*)</td>)|(?:\bSystem => (.*))#',
        $phpinfo, $matches);
    if ($found and count($matches) >= 2) {
        $system_os = $matches[count($matches) - 1];
        cb_cli_log("Operating System: $system_os");
    } else {
        cb_cli_log('Operating System: WARN: Could not find Operating System information using phpinfo()');
    }

    // Log the command line parameters used
    global $G_INPUT;
    $cli_params_line = 'Command Line Parameters:';
    foreach ($G_INPUT as $key => $value) {
        $cli_params_line .= strlen($value) > 0 ? " $key='$value'" : " $key";
    }
    cb_cli_log($cli_params_line);

    // Start timing how long this tool takes to run
    global $_cb_cli_starting_timestamp;
    $_cb_cli_starting_timestamp
        = new CB_DateTimeEx(_cb_date_convert_to_datetime(null));
    cb_cli_log('Starting');
}

/*
 * Intercept and log error messages from the 'fw/error_handler.csp' system.
 */
function _cb_cli_error_handler_hook($error_info)
{
    // Determine the path and filename of the log
    $script_name = basename(_cb_cli_get_script_name());
    $found = preg_match('/(.*)\.csp$/i', $script_name, $matches);
    if ( ! $found) {
        cb_throw_error(); // Did not match the script name
    }
    $script_name = $matches[1];
    $log_file = sprintf("%s/%s.log", cb_basedir(), $script_name);

    // Open the log file in overwrite mode.
    global $_cb_cli_log_file;
    $_cb_cli_log_file = @fopen($log_file, 'a');

    if ($_cb_cli_log_file) {
        cb_cli_log('Encountered an error: ' . print_r($error_info, true),
            false);
    }
}

function _cb_cli_get_options($mandatory = [], $other = [])
{
    // Create a map of option names => option class instances
    $all = [];
    foreach (array_merge($mandatory, $other) as $option_class_instance) {
        // Help programmers by verifying that the option class conforms to the expected interface.
        _cb_cli_verify_option_class($option_class_instance);

        $name
            = _cb_cli_get_option_name(strtolower(get_class($option_class_instance)));
        $all[$name] = $option_class_instance;
    }

    // Check that help option exists
    global $G_INPUT;
    if (array_key_exists('help', $G_INPUT)) {
        _cb_cli_help($mandatory, $other);
    }

    $parsed
        = []; // Holds those option class instances that were parsed. After parsing options, use this to check that all mandatory options were parsed.
    $option_map = [];

    // Parse command line options
    foreach ($G_INPUT as $g_input_key => $g_input_val) {
        // Print help if this option isn't recognized
        if ( ! array_key_exists($g_input_key, $all)) {
            _cb_cli_help($mandatory, $other,
                "Unrecognized option: $g_input_key");
        }

        // Process the option and map the result
        $option_class_instance = $all[$g_input_key];
        $processed_value = $option_class_instance->action($g_input_val);
        if ($processed_value === CB_CLI_OPTION_ERROR) {
            _cb_cli_help($mandatory, $other,
                "Invalid parameter: $g_input_key=$g_input_val");
        }
        $option_map[$g_input_key] = $processed_value;

        // Record that we processed this option
        $parsed[] = _cb_cli_get_option_name($option_class_instance);
    }

    // After parsing options, check that all mandatory options were parsed
    foreach ($mandatory as $elem) {
        if ( ! in_array(_cb_cli_get_option_name($elem), $parsed)) {
            _cb_cli_help($mandatory, $other);
        }
    }

    return $option_map;
}

/*
 * Takes the implementation name of an option as a string (such as "CB_CLI_ABC_OPTION") and returns
 * just the option name in lowercase (in this example, "abc").
 */
function _cb_cli_get_option_name($option)
{
    if (gettype($option) == 'object') {
        $option = strtolower(get_class($option));
    }
    $found = preg_match('/^cb_cli_(.*)_option$/i', $option, $matches);

    return $found ? strtolower($matches[1]) : null;
}

/*
 * Gets the name of the currently executing PHP script.
 */
function _cb_cli_get_script_name()
{
    global $argv;

    return $argv[0];
}

/*
 * Prints command line tool usage.
 */
function _cb_cli_help($mandatory, $other, $message = '')
{
    if (strlen($message) > 0) {
        cb_cli_log($message);
    }

    cb_cli_log('Usage: ' . basename(_cb_cli_get_script_name())
               . ' [OPTION] ...');

    _cb_cli_help_category('Mandatory', $mandatory);
    _cb_cli_help_category('Other', $other);

    die();
}

function _cb_cli_help_category($label, $options)
{
    if (count($options) == 0) {
        return;
    }

    cb_cli_log(); // Separating option groups with a blank line helps the reader organize visually
    cb_cli_log("$label Options:");
    foreach ($options as $opt) {
        $usage = _cb_cli_get_option_name($opt) . (strlen($opt->usage()) > 0
                ? '=' . $opt->usage() : '');
        cb_cli_log(sprintf("  %-30s %s", $usage, $opt->description()));
    }
}

function _cb_cli_register_error_handler_hook()
{
    require_once('fw/error_handler.csp');
    $error_handler = CB_ErrorHandler::getInstance();
    $error_handler->addHook('_cb_cli_error_handler_hook');
}

/*
 * Automatically register declared option classes.
 */
function _cb_cli_register_option_classes()
{
    foreach (get_declared_classes() as $class_name) {
        $name = _cb_cli_get_option_name($class_name);
        if (empty($name)) {
            continue;
        }
        define(strtoupper($class_name),
            $name); // define()s for option classes are all upper-case
    }
}

/*
 * Given a number of seconds, writes out the time as an English phrase.
 */
function _cb_cli_seconds_to_string($seconds)
{
    $str = "";
    // Time unit words and the divisor that can produce the associated unit from seconds
    $ary = [
        "day"    => 24 * 60 * 60,
        "hour"   => 60 * 60,
        "minute" => 60,
        "second" => 1
    ];
    // WARNING: Assuming/Relying that foreach() iterates over $ary elements in order of appearance
    foreach ($ary as $unit => $divisor) {
        $dividend = intval($seconds / $divisor);
        if ($dividend > 0 or (strlen($str) == 0 and $divisor
                                                    == 1)
        ) // The 2nd condition will at least say "0 seconds".
        {
            $str .= sprintf("%d %s%s ", $dividend, $unit,
                $dividend == 1 ? "" : "s");
        }
        $seconds %= $divisor;
    }

    return trim($str);
}

/*
 * Introspect the class to see that it conforms to the necessary interface.
 * This function is to help programmers find problems!
 */
function _cb_cli_verify_option_class($clazz)
{
    $interface = ['action', 'description', 'usage'];
    $methods = array_map("strtolower", get_class_methods($clazz));
    $intersection = array_intersect($interface, $methods);
    if (count($interface) != count($intersection)) {
        cb_throw_error();
    }
}

class CB_CLI_DB_ADMIN_PASSWORD_OPTION
{
    function action($_input_value)
    {
        return strlen($_input_value) >= 1 ? $_input_value : CB_CLI_OPTION_ERROR;
    }

    function usage()
    {
        return 'Password of the database administrator';
    }

    function description()
    {
        return "Password of the database administrator";
    }
}

class CB_CLI_DB_USER_PASSWORD_OPTION
{
    public function action($_input_value)
    {
        return strlen($_input_value) >= 1 ? $_input_value : CB_CLI_OPTION_ERROR;
    }

    public function usage()
    {
        return 'Password of the database user';
    }

    public function description()
    {
        return "Password of the database user";
    }
}

class CB_CLI_GAROON_ADMIN_PASSWORD_OPTION
{
    function action($_input_value)
    {
        return $_input_value;
    }

    function usage()
    {
        return 'Password of the administrator of Garoon';
    }

    function description()
    {
        return "Password of the administrator of Garoon";
    }
}

class CB_CLI_DEFAULT_LOCALE_OPTION
{
    function action($_input_value)
    {
        require_once("fw/i18n.csp");
        if ( ! in_array($_input_value,
            CB_LanguageManager::getAllowedLanguagesByConfigurationFile())
        ) {
            return CB_CLI_OPTION_ERROR;
        }

        return $_input_value;
    }

    function usage()
    {
        return 'ja, en or zh';
    }

    function description()
    {
        return "Default Locale";
    }
}

class CB_CLI_DEFAULT_TIMEZONE_OPTION
{
    function action($_input_value)
    {
        require_once("fw/i18n.csp");
        if ( ! in_array($_input_value, CB_I18N::getAvailableTimezones())) {
            return CB_CLI_OPTION_ERROR;
        }

        return $_input_value;
    }

    function usage()
    {
        return 'Asia/Tokyo etc.';
    }

    function description()
    {
        return "Default Timezone";
    }
}

class CB_CLI_FORCE_INITIALIZE_OPTION
{
    function action($_input_value)
    {
        $choices = ["yes", "no"];
        if ( ! in_array(strtolower($_input_value), $choices)) {
            return CB_CLI_OPTION_ERROR;
        }

        return $_input_value;
    }

    function usage()
    {
        return 'yes/no';
    }

    function description()
    {
        return "To start initialization without confirmation, set yes.";
    }

}

class CB_CLI_INIT_DATA_OPTION
{
    function action($_input_value)
    {
        require_once("fw/Initialization.csp");
        if ( ! in_array($_input_value, [
            Initialization::INIT_DATA_TYPE_NONE,
            Initialization::INIT_DATA_TYPE_HOLIDAY,
        ])
        ) {
            return CB_CLI_OPTION_ERROR;
        }

        return $_input_value;
    }

    function usage()
    {
        return '';
    }

    function description()
    {
        return "Initial data";
    }
}

/**
 * Class For Dezie/Office Link Get Command Line URL Option
 */
class CB_CLI_URL_OPTION
{
    //Module Name (Dezie or Cybozu Office)
    private $_module_name;

    /**
     * @param string $module_name Dezie or Cybozu Office
     */
    public function setModuleName($module_name)
    {
        $this->_module_name = $module_name;
    }

    /**
     * @param string $_input_value
     *
     * @return string
     */
    public function action($_input_value)
    {
        return strlen($_input_value) >= 1 ? $_input_value : CB_CLI_OPTION_ERROR;
    }

    /**
     * @return string  Dezie/Office Link URL Sample
     */
    public function usage()
    {
        $file_name = $this->_module_name == 'Dezie' ? 'db.cgi' : 'ag.cgi';

        return 'http(s)://<SERVER_NAME>/<PATH>/' . $file_name . '(exe)';
    }

    /**
     * @return string  Dezie/Office Link CI Option's Description
     */
    public function description()
    {
        return $this->_module_name . "'s URL for user synchronization";
    }
}
