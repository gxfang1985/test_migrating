<?php

namespace grn\grn\access\utility;

use grn\grn\Validate;

use grn\grn\access\logic\AvailabilitySettingLogic;

class IpUtil
{
    CONST MIN_CIDR = 1;
    CONST MAX_CIDR_IPV4 = 32;
    CONST MAX_CIDR_IPV6 = 128;
    CONST IPV4 = 'IPv4';
    CONST IPV6 = 'IPv6';

    /**
     * @param string $ip
     *
     * @return bool|string
     * - Return false if $ip is invalid
     * - Return string "IPv4" if $ip is IPv4
     * - Return string "IPv6" if $ip is IPv6
     */
    public static function validateIp($ip)
    {
        $types = [
            IpUtil::IPV4 => FILTER_FLAG_IPV4,
            IpUtil::IPV6 => FILTER_FLAG_IPV6
        ];

        foreach ($types as $key => $type) {
            $valid = filter_var($ip, FILTER_VALIDATE_IP, $type);
            if ($valid) {
                return $key;
            }
        }

        return false;
    }

    /**
     * @param int    $cidr
     * @param string $ip_version
     *
     * @return bool
     */
    public static function isValidCIDR($cidr, $ip_version = IpUtil::IPV4)
    {
        $valid = false;
        if ( ! Validate::isNumber($cidr) || $cidr < IpUtil::MIN_CIDR) {
            return $valid;
        }

        switch ($ip_version) {
            case IpUtil::IPV4:
                $valid = $cidr <= IpUtil::MAX_CIDR_IPV4;
                break;
            case IpUtil::IPV6:
                $valid = $cidr <= IpUtil::MAX_CIDR_IPV6;
                break;
            default:
                assert(false);
        }

        return $valid;
    }

    /**
     * @param string $forwarded_value The value of the X_FORWARDED_FOR, the format is X-Forwarded-For: client, proxy1, proxy2
     *
     * @return string The client ip address
     */
    public static function getIpFromXForWardedFor($forwarded_value)
    {
        $regs = null;
        if (IpUtil::validateIp($forwarded_value) !== false) {
            return $forwarded_value;
        }

        if (preg_match("/^for=([^([,|;]*)/", $forwarded_value, $regs)) {
            if (self::validateIp($regs[1]) !== false) {
                return $regs[1];
            }
        }

        return '';
    }

    /**
     * @return string
     */
    public static function getClientIp()
    {
        $proxy_config_key = AvailabilitySettingLogic::getProxyConfigKey();
        $http_headers = [$proxy_config_key, 'REMOTE_ADDR'];
        $ip_address = "";
        foreach ($http_headers as $name) {
            $ip_address = getenv($name);
            if ($ip_address) {
                if ($name === $proxy_config_key) {
                    $ip_address = self::getIpFromXForWardedFor($ip_address);
                }

                return explode('%', $ip_address)[0];
            }
        }

        return $ip_address;
    }

    /**
     * The function to parse information of the IP, netmask
     *
     * @param $range
     * @param $netmask
     *
     * @return array eg. array(ip, cidr, host_bit, range_decimal, wildcard_decimal) if the IP and netmask is valid
     */
    public static function getInformationFromIpv4Range($range, $netmask)
    {
        $host_bit = self::MAX_CIDR_IPV4 - $netmask;
        $range_decimal = ip2long($range);
        $wildcard_decimal = pow(2, $host_bit) - 1;

        return [
            'ip'               => $range,
            'cidr'             => $netmask,
            'host_bit'         => $host_bit,
            'range_decimal'    => $range_decimal,
            'wildcard_decimal' => $wildcard_decimal
        ];
    }

    /**
     *  Check IPv4 address is within an IP range
     *
     * @param  string $ip_address IP to check in IPV4 format eg. 10.192.12.27
     * @param  string $range      IP/CIDR netmask eg. 10.192.12.0/16, also 10.192.12.0 is accepted and /32 assumed
     * @param  int    $cidr       CIDR netmask eg. 16
     *
     * @return boolean true if the ip is in this range / false if not.
     */
    public static function isIpInRange($ip_address, $range, $cidr)
    {
        $range_information = self::getInformationFromIpv4Range($range, $cidr);
        $ip_decimal = ip2long($ip_address);
        $netmask_decimal = ~$range_information['wildcard_decimal'];
        $is_ip_in_range = ($ip_decimal & $netmask_decimal)
                          == ($range_information['range_decimal']
                              & $netmask_decimal);

        return $is_ip_in_range;
    }

    /**
     * Check IPv6 address is within an IPv6 range
     *
     * @param  string $ip_address IP to check in IPV6 format eg. 2607:f0d0:1002:51::4
     * @param  string $range      IP netmask eg. 2607:f0d0:1002:51::4
     * @param string  $mask       a valid IPv6 subnet mask
     *
     * @return bool whether $address is within the ip range made up of the subnet and mask
     */
    public static function isIpInRangeIpv6($ip_address, $range, $mask)
    {
        $range = inet_pton($range);
        $ip_address = inet_pton($ip_address);
        $bin_mask = str_repeat("f", $mask / 4);
        switch ($mask % 4) {
            case 0:
                break;
            case 1:
                $bin_mask .= "8";
                break;
            case 2:
                $bin_mask .= "c";
                break;
            case 3:
                $bin_mask .= "e";
                break;
        }

        $bin_mask = str_pad($bin_mask, 32, '0');
        $bin_mask = pack("H*", $bin_mask);
        $is_ip_in_range = ($ip_address & $bin_mask) == ($range & $bin_mask);

        return $is_ip_in_range;
    }

}
