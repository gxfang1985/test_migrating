<?php

namespace grn\grn\access\logic;

use grn\grn\access\bean\Availability;
use grn\grn\access\dao\AvailabilityBaseDAO;
use grn\grn\access\dao\AvailabilityDynamicRoleDAO;
use grn\grn\access\dao\AvailabilityGroupDAO;
use grn\grn\access\dao\AvailabilityRoleDAO;
use grn\grn\access\dao\AvailabilityUserDAO;
use grn\grn\access\utility\AppAvailabilityUtil;


class AvailabilitySettingLogic
{
    CONST ACCESS_TYPE_UNRESTRICTED = 0;
    CONST ACCESS_TYPE_REMOTE_SERVICE = 1;
    CONST ACCESS_TYPE_INTERNAL = 2;
    CONST X_CYBOZU_PROXY = "client_ip_identify_header";
    CONST SETTING_NAME_EXTERNAL_ACCESS = 'external_access';
    CONST NOT_USE = "not_use";
    CONST USE_RSM = "use_rsm";
    CONST USE_INTERNAL_ADDRESS = "use_internal_address";
    CONST MAX_IP_NUMBER = 500;
    private $dynamicRoleDAO;
    private $roleDAO;
    private $groupDAO;
    private $userDAO;
    private static $availabilityCached = [];
    private static $countResultCached = [];
    private $appAvailabilityUtil;

    /**
     * AvailabilitySettingLogic constructor.
     */
    public function __construct()
    {
        $this->dynamicRoleDAO = new AvailabilityDynamicRoleDAO();
        $this->roleDAO = new AvailabilityRoleDAO();
        $this->groupDAO = new AvailabilityGroupDAO();
        $this->userDAO = new AvailabilityUserDAO();
        $this->appAvailabilityUtil = new AppAvailabilityUtil();
    }

    /**
     * @param string $target
     *
     * @return Availability[]
     */
    public function getAll($target)
    {
        $cache_key = 'getAll' . '_' . $target;
        if (array_key_exists($cache_key, self::$availabilityCached)) {
            return self::$availabilityCached[$cache_key];
        }
        $availability_dao = $this->getDao($target);
        self::$availabilityCached[$cache_key] = $availability_dao->getAll();

        return self::$availabilityCached[$cache_key];
    }

    /**
     * @param int|string $target_id
     * @param string     $target
     *
     * @return Availability
     */
    public function getByTargetId($target_id, $target)
    {
        $cache_key = 'getByTargetId' . '_' . $target_id . '_' . $target;
        if (array_key_exists($cache_key, self::$availabilityCached)) {
            return self::$availabilityCached[$cache_key];
        }
        self::$availabilityCached[$cache_key] = $this->getDao($target)
                                                     ->getByTargetId($target_id);

        return self::$availabilityCached[$cache_key];
    }

    /**
     * @param Availability $availability
     * @param              $target_type
     */
    public function insert(Availability $availability, $target_type)
    {
        $this->insertTargets([$availability], $target_type);
    }

    /**
     * @param $availabilities
     * @param $target_type
     */
    public function insertTargets($availabilities, $target_type)
    {
        $this->getDao($target_type)->insertTargets($availabilities);
    }

    /**
     * @param $id
     * @param $target
     *
     * @return bool|int
     */
    public function delete($id, $target)
    {
        return $this->getDao($target)->delete($id);
    }

    /**
     * @param $target_id
     * @param $target
     *
     * @return bool|int
     */
    public function deleteByTargetId($target_id, $target)
    {
        return $this->deleteByTargetIds([$target_id], $target);
    }

    public function deleteByTargetIds($target_ids, $target_type)
    {
        return $this->getDao($target_type)->deleteByTargetIds($target_ids);
    }

    /**
     * @param $target
     *
     * @return bool|int
     */
    public function deleteAll($target)
    {
        return $this->getDao($target)->deleteAll();
    }

    /**
     * @param $target
     *
     * @return int
     */
    public function getCount($target)
    {
        $cache_key = 'getCount' . '_' . $target;
        if (array_key_exists($cache_key, self::$countResultCached)) {
            return self::$countResultCached[$cache_key];
        }
        self::$countResultCached[$cache_key] = $this->getDao($target)
                                                    ->getCount();

        return self::$countResultCached[$cache_key];
    }

    /**
     * @param int[]  $user_ids
     * @param string $target
     *
     * @return Availability[]
     */
    public function getByUserIds($user_ids, $target)
    {
        $cache_key = 'getByUserIds' . '_' . $target . '_' . implode('_',
                $user_ids);
        /** @var  $availabilityDAO AvailabilityBaseDAO */
        $availability_dao = $this->getDao($target);
        if ( ! array_key_exists($cache_key, self::$availabilityCached)) {
            self::$availabilityCached[$cache_key]
                = $availability_dao->getByUserIds($user_ids);
        }

        return self::$availabilityCached[$cache_key];
    }

    /**
     * @param string $target
     *
     * @return AvailabilityBaseDAO
     */
    private function getDao($target)
    {
        if ($target === Availability::DYNAMIC_ROLE) {
            return new AvailabilityDynamicRoleDAO();
        } elseif ($target === Availability::STATIC_ROLE) {
            return new AvailabilityRoleDAO();
        } elseif ($target === Availability::GROUP) {
            return new AvailabilityGroupDAO();
        }

        return new AvailabilityUserDAO();
    }

    /**
     * @return array
     */
    public function getActiveAppIds()
    {
        return AppAvailabilityUtil::getActiveAppIds();
    }

    /**
     * The function get the key using for proxy
     *
     * @return string - The result is HTTP_X_FORWARDED_FOR
     */
    public static function getProxyConfigKey()
    {
        global $G_config_common;
        $proxy_config_key = $G_config_common->get("Global",
            self::X_CYBOZU_PROXY);
        $proxy_config_key = preg_replace('/-/', '_', $proxy_config_key);
        $proxy_config_key = strtoupper($proxy_config_key);

        return 'HTTP_' . $proxy_config_key;
    }

    public static function getExternalAccessSetting()
    {
        require_once('fw/profile.csp');
        $system_profile = cb_get_system_profile('grn.common');
        $external_connect_setting = "";
        if ( ! $system_profile->getAttribute(self::SETTING_NAME_EXTERNAL_ACCESS,
            $external_connect_setting)
        ) {
            $external_connect_setting = self::ACCESS_TYPE_UNRESTRICTED;
        }

        return $external_connect_setting;
    }

    public static function setExternalAccessSetting($config_value)
    {
        require_once('fw/profile.csp');
        $system_profile = cb_get_system_profile('grn.common');
        $old_config_value = null;
        $is_configured
            = $system_profile->getAttribute(self::SETTING_NAME_EXTERNAL_ACCESS,
            $old_config_value);
        if ( ! $is_configured
             && ! $system_profile->createAttribute(self::SETTING_NAME_EXTERNAL_ACCESS,
                $config_value)
        ) {
            return false;
        }

        return $system_profile->updateAttribute(self::SETTING_NAME_EXTERNAL_ACCESS,
            $config_value);
    }

    /**
     * Get the setting display name.
     *
     * @return string
     */
    public static function getExternalAccessSettingText()
    {
        $setting_text = '';
        switch (self::getExternalAccessSetting()) {
            case self::ACCESS_TYPE_UNRESTRICTED:
                $setting_text = cb_msg('grn.system.application',
                    'external_access_not_use');
                break;
            case self::ACCESS_TYPE_REMOTE_SERVICE:
                $setting_text = cb_msg('grn.system.application',
                    'external_access_use_rsm');
                break;
            case self::ACCESS_TYPE_INTERNAL:
                $setting_text = cb_msg('grn.system.application',
                    'external_access_use_internal_address');
                break;
            default:
                assert('FALSE');
        }

        return $setting_text;
    }

    /**
     * @return array
     *  Example:
     *      array(
     *          'dynamic_role' => array( 'Everyone' => array( 'apps' => array( 'workflow' => array( 'internal' => 1, 'external' => 1 ) ) ) ),
     *          'cb_role' => array(
     *                          1 => array( 'apps' => array( 'space' => array( 'internal' => 1, 'external' => 0 ) ) ),
     *                          2 => array( 'apps' => array( 'schedule' => array( 'internal' => 1, 'external' => 1 ) ) )
     *                       ),
     *          'cb_group' => array(
     *                          1 => array( 'apps' => array( 'link' => array( 'internal' => 1, 'external' => 1 ) ) ),
     *                          2 => array( 'apps' => array( 'message' => array( 'internal' => 1, 'external' => 1 ) ) )
     *                      ),
     *          'cb_user' => array( 1 => array( 'apps' => array( 'cabinet' => array( 'internal' => 0, 'external' => 0 ) ) ) )
     *      )
     */
    public function getAvailabilitySettingTargets()
    {
        $availability_setting = new AvailabilitySettingLogic();
        $target_type_map = [
            'dynamic_role' => Availability::DYNAMIC_ROLE,
            'cb_role'      => Availability::STATIC_ROLE,
            'cb_group'     => Availability::GROUP,
            'cb_user'      => Availability::USER
        ];
        $activated_apps
            = array_fill_keys($this->appAvailabilityUtil->getActiveAppIds(),
            [
                'internal' => AppAvailabilityUtil::ACCESS_DENIED,
                'external' => AppAvailabilityUtil::ACCESS_DENIED
            ]);
        $apps = [];
        foreach ($target_type_map as $type => $type_value) {
            $availability_apps = $availability_setting->getAll($type_value);
            foreach ($availability_apps as $availability) {
                $available_apps = $availability->getAppsAvailability();
                $available_apps
                    = array_filter($available_apps,
                    function ($app_id) {
                        return $this->appAvailabilityUtil->isActive($app_id);
                    }, ARRAY_FILTER_USE_KEY);
                $available_apps
                    = array_merge($activated_apps, $available_apps);
                $apps[$type][$availability->getTarget()]
                    = ['apps' => $available_apps];
            }
        }

        if (isset($apps['cb_user'])) {
            $users_id = array_keys($apps['cb_user']);
            if (count($users_id) > 0) {
                $uum = cb_lwc_uum();
                $users_info = $uum->getUsersInfo($users_id);
                foreach ($users_id as $user_id) {
                    if ( ! array_key_exists($user_id, $users_info)) {
                        unset($apps['cb_user'][$user_id]);
                    }
                }
                if (count($apps['cb_user']) === 0) {
                    unset($apps['cb_user']);
                }
            }
        }

        return $apps;
    }

    /**
     * @param int|string $target_id
     * @param string     $target_type
     *
     * @return array
     */
    public function getAvailabilitySettingByTargetId($target_id, $target_type)
    {
        $availability_setting = new AvailabilitySettingLogic();
        $apps_availability = $availability_setting->getByTargetId($target_id,
            $target_type)->getAppsAvailability();
        if ($apps_availability === null) {
            $apps_availability = [];
        }

        return $apps_availability;
    }
}

