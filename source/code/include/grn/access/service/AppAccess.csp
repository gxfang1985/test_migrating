<?php

namespace grn\grn\access\service;


use grn\grn\access\exception\AppNotAvailableForExternalException;
use grn\grn\access\exception\AppNotAvailableForInternalException;
use grn\grn\access\logic\AppAvailabilityExternalLogic;
use grn\grn\access\logic\AppAvailabilityLogic;
use grn\grn\access\logic\AvailabilitySettingLogic;
use grn\grn\access\utility\AppAvailabilityUtil;
use grn\grn\access\utility\IpUtil;

class AppAccess
{

    /**
     * @param      $app_id
     * @param null $user_id
     * @param null $ip_address
     *
     * @throws AppNotAvailableForInternalException|AppNotAvailableForExternalException
     */
    public static function checkAccess(
        $app_id,
        $user_id = null,
        $ip_address = null
    ) {
        self::checkInternalAccess($app_id, $user_id);
        self::checkExternalAccess($app_id, $user_id, $ip_address);
    }

    /**
     * @param null|int    $user_id
     * @param string      $app_id
     * @param null|string $ip_address
     *
     * @return bool
     */
    public static function isAppAvailable(
        $app_id,
        $user_id = null,
        $ip_address = null
    ) {
        $availability_logic = new AppAvailabilityLogic();
        if ( ! $availability_logic->isAppAvailableForUser($app_id, $user_id)) {
            return false;
        }

        if ( ! isset($ip_address)) {
            $ip_address = IpUtil::getClientIp();
        }

        return self::isAppAvailableExternalAccess($app_id, $user_id,
            $ip_address);

    }

    /**
     * The function get all application-ids which the user-id can access both internal and external
     *
     * @param      $user_id
     * @param null $ip_client
     *
     * @return array
     *   e.g array('schedule','space,...,cellular)
     */
    public static function getAvailableAppIdsByUserId(
        $user_id,
        $ip_client = null
    ) {
        if ( ! isset($ip_client)) {
            $ip_client = IpUtil::getClientIp();
        }
        $availability_logic = new AppAvailabilityLogic();
        $availability_external_logic = new AppAvailabilityExternalLogic();
        $app_ids_allow_access
            = $availability_logic->getAvailableAppIdsByUserId($user_id);

        return $availability_external_logic->getAvailableAppIdsByUserId($user_id,
            $app_ids_allow_access, $ip_client);
    }

    /**
     * The function get all application-ids which the user-id can access both internal and external
     * The applications does not support privilege are always in the result.
     *
     * @param int         $user_id
     * @param null|string $ip_client
     *
     * @return array
     *   e.g array('schedule','space,...,'memo','dezielink','job')
     */
    public static function getAllAppIdsAvailableByUserId(
        $user_id,
        $ip_client = null
    ) {
        $app_ids_privilege = AppAvailabilityUtil::getAppIdsSupportPrivilege();
        $active_app_ids
            = array_diff(AppAvailabilityUtil::getActiveApplicationIds(),
            $app_ids_privilege);
        $app_id_result
            = array_merge(self::getAvailableAppIdsByUserId($user_id,
            $ip_client), $active_app_ids);

        return $app_id_result;
    }

    /**
     * @param string   $app_id
     * @param null|int $user_id
     *
     * @throws AppNotAvailableForInternalException
     */
    public static function checkInternalAccess($app_id, $user_id = null)
    {
        $availability_logic = new AppAvailabilityLogic();
        $availability_logic->checkForUserAccess($app_id, $user_id);
    }

    /**
     * @param string   $app_id
     * @param null|int $user_id
     *
     * @return bool
     */
    public static function isAppAvailableInternalAccess(
        $app_id,
        $user_id = null
    ) {
        $availability_logic = new AppAvailabilityLogic();

        return $availability_logic->isAppAvailableForUser($app_id, $user_id);
    }

    /**
     * @param int[]  $user_ids e.g: array(1,2,3,4,...,100,101)
     * @param string $app_id
     *
     * @return array
     */
    public static function filterUserIdsInternalAccessByAppId(
        $user_ids,
        $app_id
    ) {
        $availability_logic = new AppAvailabilityLogic();
        $user_ids = array_values($user_ids);//Reset index of array

        return $availability_logic->filterUserIdsByAppId($user_ids, $app_id);
    }

    /**
     * The function get app_id in the app list support privilege which user can use.
     *
     * @param               $user_id
     * @param null|string[] $app_ids_evaluate
     *
     * @return string[]
     */
    public static function getAvailableAppIdsInternalByUserId(
        $user_id,
        $app_ids_evaluate = null
    ) {
        $availability_logic = new AppAvailabilityLogic();

        return $availability_logic->getAvailableAppIdsByUserId($user_id,
            $app_ids_evaluate);
    }

    /**
     * @param               $user_id
     * @param null|string[] $app_ids_evaluate
     *
     * @return array
     * e.g array(schedule=>0, message=>1, .., cellular=>1)
     */
    public static function getAvailabilityAppIdsInternalByUserId(
        $user_id,
        $app_ids_evaluate = null
    ) {
        $availability_logic = new AppAvailabilityLogic();

        return $availability_logic->getAvailabilityAppIdsByUserId($user_id,
            $app_ids_evaluate);
    }

    /**
     * @param int[]       $user_ids array id of the user such as array (1,2,3,4,5,6,...)
     * @param null|string $app_id_check
     *
     * @return array
     * array (  1=>(schedule=>0, message=>1, .., cellular=>1),
     *          2=>(schedule=>1, message=>1, .., cellular=>0),
     *          3=>(schedule=>0, message=>0, .., cellular=>1),
     * )
     */
    public static function getAvailabilityAppIdsInternalByUserIds(
        array $user_ids,
        $app_id_check = null
    ) {
        $availability_logic = new AppAvailabilityLogic();
        if (isset($app_id_check) && ! is_array($app_id_check)) {
            $app_id_check = [$app_id_check];
        }
        $user_ids = array_values($user_ids);

        return $availability_logic->getAvailabilityAppIdsByUserIds($user_ids,
            $app_id_check);
    }

    /**
     * @param string      $app_id
     * @param null|int    $user_id
     * @param null|string $ip_address
     *
     * @return bool
     */
    public static function isAppAvailableExternalAccess(
        $app_id,
        $user_id = null,
        $ip_address = null
    ) {
        if (AvailabilitySettingLogic::getExternalAccessSetting()
            === AvailabilitySettingLogic::ACCESS_TYPE_UNRESTRICTED
        ) {
            return true;
        }

        return (new AppAvailabilityExternalLogic())->isAppAvailableForUser($app_id,
            $user_id, $ip_address);
    }

    /**
     * @param string      $app_id
     * @param null|int    $user_id
     * @param null|string $ip_address
     *
     * @throws AppNotAvailableForExternalException
     */
    public static function checkExternalAccess(
        $app_id,
        $user_id = null,
        $ip_address = null
    ) {
        AppAvailabilityExternalLogic::checkForUserAccess($app_id, $user_id,
            $ip_address);
    }

    /**
     * @param int           $user_id
     * @param null|string[] $app_ids_to_evaluate
     * @param null|string   $ip_client
     *
     * @return array (schedule=>0, message=>1, .., cellular=>1, job=>1)
     */
    public static function getAvailabilityExternalAppIdsByUserId(
        $user_id,
        array $app_ids_to_evaluate = null,
        $ip_client = null
    ) {
        $availability_external_logic = new AppAvailabilityExternalLogic();

        return $availability_external_logic->getAvailabilityAppIdsByUserId($user_id,
            $app_ids_to_evaluate, $ip_client);
    }

}
