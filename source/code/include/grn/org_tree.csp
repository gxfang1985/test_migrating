<?php

/**
 * Organization Tree
 *
 * @package grn.common
 */

require_once('fw/module.csp');
require_once('schedule/facility_tree.csp');

define('GRN_ORG_TREE_OID', 'oid');
define('GRN_ORG_TREE_NAME', 'name');
define('GRN_ORG_TREE_PARENT', 'parent');
define('GRN_ORG_TREE_COUNT', 'count');
define('GRN_ORG_TREE_EXPANDED', 'expanded');
define('GRN_ORG_TREE_CHILDREN', 'children');
define('GRN_ORG_TREE_LIST_INDEX', 'list_index');

/**
 * Organization tree class
 *
 * @package grn.common
 */
class GRN_OrgTree
{
    var $_nodes = null;

    var $_tree = null;

    var $_selectedNode = null;

    var $_groups_have_childs = null;

    var $_uid = null;

    public $init_time = null;

    public $check_init = false;

    function __construct()
    {
    }

    /**
     * @param int $uid
     */
    function setUID($uid)
    {
        $this->_uid = $uid;
    }

    /**
     * @return int
     */
    function getUID()
    {
        return $this->_uid;
    }

    /**
     * @return GRN_Uum
     */
    protected function getUum()
    {
        return cb_lwc_uum();
    }

    /**
     * @return GRN_UumUtil
     */
    protected function getUumUtil()
    {
        require_once('grn/uum_util.csp');

        return GRN_UumUtil::getInstance();
    }

    /**
     * @access private
     * 子組織数を取得する。
     *
     * @param  int $oid 親組織ID
     *
     * @return int num of child organization
     */
    function _getChildCount($oid)
    {
        if (array_key_exists($oid, $this->_groups_have_childs)) {
            return $this->_groups_have_childs[$oid];
        } else {
            return 0;
        }
    }

    /**
     * @access private
     * 子組織を取得する。
     *
     * @param   int $oid 親組織ID
     *
     * @return  array 子組織
     */
    function _getChildren($oid)
    {
        return $this->getUum()->getChildGroupsInfo($oid);
    }

    /**
     * @access private
     * To get ancestors of a node
     * The return value of this method provides data for expandTo() method to expand the tree to selected node
     *
     * @param int $oid
     *
     * @return  array associated array
     */
    function _getAncestors($oid)
    {
        if ($oid < 1) {
            return null;
        }

        $ret = [];

        $uum = $this->getUum();

        $parentOId = $oid;
        while ($parentOId > 0) {
            $ret[$parentOId] = $parentOId;
            $parentOId = $uum->getParentOfGroup($parentOId);
        }

        return array_reverse($ret, true);
    }

    /**
     * ツリーを初期化する。
     *
     * @param bool $expanded
     *
     * @return  array 初期化したツリー
     */
    function initialize($expanded = false)
    {
        $this->_nodes = [];
        $this->_tree = [];
        $this->buildChild(null, $expanded);
        // set init time
        $this->init_time = time();

        return $this->_tree;
    }

    /**
     * ツリーを再構築する。
     *
     * @return  array ツリー
     */
    function rebuild()
    {
        $this->buildChild(null);

        return $this->_tree;
    }

    /**
     * ツリーの子ノードを構築する。
     *
     * @param int  $parent_oid 親ノードID
     * @param bool $expanded
     * @param bool $force
     *
     * @return array|bool 構築した子ノード
     */
    function buildChild($parent_oid, $expanded = false, $force = true)
    {
        $uum = $this->getUum();
        $this->_groups_have_childs = $uum->getChildGroupsCountInfo();

        return $this->_buildChild($parent_oid, $expanded, $force);
    }

    function _onCreateChild(&$child, &$child_row)
    {
    }

    function _buildChild(
        $parent_oid,
        $expanded = false,
        $force = true,
        $subtree = false
    ) {
        if ($parent_oid && ! $subtree) {
            $this->isInitialized();
            if ( ! array_key_exists($parent_oid, $this->_nodes)) {
                $__ret = false;

                return $__ret;
            }
            // (for non-root)
            $parent =& $this->_nodes[$parent_oid];
            if ( ! is_array($parent)) {
                $__ret = false;

                return $__ret;
            }

            if ( ! $force) {
                if (array_key_exists(GRN_ORG_TREE_CHILDREN, $parent)
                    && array_key_exists(GRN_ORG_TREE_COUNT, $parent)
                    && count($parent[GRN_ORG_TREE_CHILDREN])
                       == $parent[GRN_ORG_TREE_COUNT]
                ) {
                    return;
                }
            }

            // 循環参照を防ぐ
            unset($this->_nodes[$parent_oid]);

            $parent[GRN_ORG_TREE_CHILDREN] = [];
        }
        $child_rows = $this->_getChildren($parent_oid);

        $children = [];
        foreach (array_keys($child_rows) as $id) {
            $oid = $child_rows[$id]['_id'];

            $children[$oid] = [
                GRN_ORG_TREE_OID      => $oid,
                GRN_ORG_TREE_NAME     => $child_rows[$id]['col_name'],
                GRN_ORG_TREE_PARENT   => $parent_oid,
                GRN_ORG_TREE_EXPANDED => $expanded
            ];

            if (array_key_exists('col_list_index', $child_rows[$id])) {
                $children[$oid][GRN_ORG_TREE_LIST_INDEX]
                    = $child_rows[$id]['col_list_index'];
            }

            $child_count = $this->_getChildCount($oid);
            $children[$oid][GRN_ORG_TREE_COUNT] = $child_count;
            $children[$oid][GRN_ORG_TREE_CHILDREN] = [];

            $this->_onCreateChild($children[$oid], $child_rows[$id]);

            if (array_key_exists('deleted', $child_rows[$id])) {
                if ($parent_oid && isset($parent)
                    && array_key_exists('deleted', $parent)
                    && $parent['deleted'] != null
                ) {
                    $children[$oid]['deleted'] = $parent['deleted'];
                } else {
                    $children[$oid]['deleted'] = $child_rows[$id]['deleted'];
                }
            }

            $this->_nodes[$oid] =& $children[$oid];
            $node =& $this->_nodes[$oid];
            if (is_array($node)) {
                if ($child_count > 0 && $node[GRN_ORG_TREE_EXPANDED] == 1) {
                    // recursive rebuild
                    $this->_buildChild($oid, $expanded, $force);
                }
            }
        }

        if ($parent_oid && ! $subtree) {
            $parent[GRN_ORG_TREE_CHILDREN] =& $children;
            $parent[GRN_ORG_TREE_COUNT] = count($children);
            $parent[GRN_ORG_TREE_EXPANDED] = $expanded ? 1 : 0;
            $this->_nodes[$parent_oid] =& $parent;
        } else {
            $this->_tree =& $children;
        }

        return $children;
    }

    /**
     * ツリーからノードを削除する。
     *
     * @param int $oid
     *
     * @return  bool
     */
    function remove($oid)
    {
        $node =& $this->_nodes[$oid];
        if (is_array($node)) {
            $parent_oid = @$node[GRN_ORG_TREE_PARENT];

            if ( ! is_null($parent_oid)) {
                $parent =& $this->_nodes[$parent_oid];

                if (is_array($parent)) {
                    unset($parent[GRN_ORG_TREE_CHILDREN][$oid]);

                    $child_count = (int)$parent[GRN_ORG_TREE_COUNT]
                                   - 1;
                    $parent[GRN_ORG_TREE_COUNT] = $child_count;
                    if ($child_count == 0) {
                        $parent[GRN_ORG_TREE_EXPANDED] = 0;
                    }

                    return true;
                }
            }
            unset($this->_nodes[$oid]);
        }

        return false;
    }

    /**
     * ノードを展開する。
     *
     * @param int  $oid
     * @param bool $parents
     *
     * @return  bool
     */
    function expand($oid, $parents = false)
    {
        $this->isInitialized();
        $node =& $this->_nodes[$oid];
        if (is_array($node)) {
            if ($parents) {
                $this->expand($node[GRN_ORG_TREE_PARENT]);
            }
            $node[GRN_ORG_TREE_EXPANDED] = 1;

            return true;
        }

        return false;
    }

    /**
     * ノードを折りたたむ。
     *
     * @param int  $oid
     * @param bool $parents
     *
     * @return  bool
     */
    function collapse($oid, $parents = false)
    {
        $this->isInitialized();
        $node =& $this->_nodes[$oid];
        if (is_array($node)) {
            if ($parents) {
                $this->expand($node[GRN_ORG_TREE_PARENT]);
            }
            $node[GRN_ORG_TREE_EXPANDED] = 0;

            return true;
        }

        return false;
    }


    /**
     * ツリーを取得する。
     *
     * @return array ツリー全体
     */
    function getRoot()
    {
        return $this->_tree;
    }

    /**
     * 選択中のノードOIDを取得する。
     *
     * @return  int
     */
    function getSelectedNode()
    {
        $uum = $this->getUum();
        if ( ! is_null($this->_selectedNode)
             && $uum->getGroupInfo($this->_selectedNode) === false
        ) {
            $this->_selectedNode = null;
            $this->initialize();

            return null;
        } else {
            return $this->_selectedNode;
        }

    }

    /**
     * 選択中のノードOIDを設定する。
     *
     * @param oid
     */
    function setSelectedNode($oid)
    {
        $this->_selectedNode = $oid;

        // expand tree to selected node and display child node
        $this->expandToAndDisplayChild($oid);
    }

    /**
     * 選択中のノードOIDを設定する。
     *
     * @param oid
     */
    function setSelectedNodeNotDisplay($oid)
    {
        $this->_selectedNode = $oid;

        // expand tree to selected node and display child node
        $this->expandTo($oid, false);
    }

    /**
     * Expand tree to specified node
     * The current node is also expanded
     *
     * Create ancestor nodes when they do not exist
     *
     * @param int  $oid
     * @param bool $current_expanded
     */
    function expandTo($oid, $current_expanded = true)
    {
        if ($current_expanded) {
            $this->_nodes[$oid][GRN_ORG_TREE_EXPANDED] = true;
        }
        $ancestors = $this->_getAncestors($oid);
        if ( ! is_array($ancestors)) {
            return;
        }

        $parent = isset($this->_nodes[$oid][GRN_ORG_TREE_PARENT])
            ? $this->_nodes[$oid][GRN_ORG_TREE_PARENT] : null;
        foreach (array_keys($ancestors) as $ancestor_id) {
            if (array_key_exists($ancestor_id, $this->_nodes)
                && $ancestor_id != $oid
            ) {
                if ($parent) {
                    $this->_nodes[$ancestor_id][GRN_ORG_TREE_EXPANDED] = true;
                } else {
                    $this->_buildChild($ancestor_id);
                    $this->_nodes[$ancestor_id][GRN_ORG_TREE_EXPANDED] = true;
                }
            }
        }
    }

    /**
     * Expand tree to specified node
     * Display child node of the specified node
     * Create ancestor nodes when they do not exist
     *
     * @param oid
     */
    function expandToAndDisplayChild($oid)
    {
        $ancestors = $this->_getAncestors($oid);
        if ( ! is_array($ancestors)) {
            return;
        }

        $parent = isset($this->_nodes[$oid][GRN_ORG_TREE_PARENT])
            ? $this->_nodes[$oid][GRN_ORG_TREE_PARENT] : null;
        foreach (array_keys($ancestors) as $ancestor_id) {
            if (array_key_exists($ancestor_id, $this->_nodes)) {
                if ($parent) {
                    if (count($this->_nodes[$ancestor_id]['children']) == 0) {
                        $this->_buildChild($ancestor_id, false, false);
                    }
                    $this->_nodes[$ancestor_id][GRN_ORG_TREE_EXPANDED] = true;
                } else {
                    $ret = $this->_buildChild($ancestor_id,
                        false);
                    $this->_nodes[$ancestor_id][GRN_ORG_TREE_EXPANDED] = true;
                }
            }
        }
        $this->_nodes[$oid][GRN_ORG_TREE_EXPANDED] = true;
    }

    /**
     * Expand tree and display to specified node
     * Create ancestor nodes when they do not exist
     *
     * @param oid
     */
    function expandToAndDisplay($oid)
    {
        $ancestors = $this->_getAncestors($oid);
        if ( ! is_array($ancestors)) {
            return;
        }

        $parent = isset($this->_nodes[$oid][GRN_ORG_TREE_PARENT])
            ? $this->_nodes[$oid][GRN_ORG_TREE_PARENT] : null;
        array_pop($ancestors);
        foreach (array_keys($ancestors) as $ancestor_id) {
            if (array_key_exists($ancestor_id, $this->_nodes)) {
                if ($parent) {
                    if (count($this->_nodes[$ancestor_id]['children']) == 0) {
                        $this->_buildChild($ancestor_id, false, false);
                    }
                    $this->_nodes[$ancestor_id][GRN_ORG_TREE_EXPANDED] = true;
                } else {
                    $ret = $this->_buildChild($ancestor_id,
                        false, false);
                    $this->_nodes[$ancestor_id][GRN_ORG_TREE_EXPANDED] = true;
                }
            }
        }
    }

    /**
     * Expand tree to specified node
     * The current node is not expanded
     *
     * Skip ancestor nodes when they do not exist
     *
     * @param oid
     */
    function showPathToNode($nodeId)
    {
        $parentId = null;
        if (array_key_exists('parent', $this->_nodes[$nodeId])) {
            $parentId = $this->_nodes[$nodeId]['parent'];
        }
        while ( ! is_null($parentId)) {
            $this->_nodes[$parentId]['expanded'] = 1;
            if (array_key_exists('parent', $this->_nodes[$parentId])) {
                $parentId = $this->_nodes[$parentId]['parent'];
            } else {
                break;
            }
        }
    }

    /**
     * Confirm the tree is initialized.
     * This Method is for confirming the tree generated by un-serialized session data is valid.
     */
    function isInitialized()
    {
        if ( ! is_array($this->_nodes)) {
            cb_throw_error('FW00043', null, null, null,
                ['page' => cb_get_pagename()]);
        }
    }

    /**
     * Checking exist of node.
     *
     * @param int $oid id of node
     *
     * @return bool
     */
    function containNode($oid)
    {
        if (is_array($this->_nodes) && count($this->_nodes) > 0) {
            return array_key_exists($oid, $this->_nodes);
        }

        return false;
    }

    /**
     * @param array $groupIds
     *
     * @return array
     */
    public function getFullPaths(array $groupIds)
    {
        $root = $this->getRoot();
        $ret = [];
        foreach ($root as &$node) {
            $this->searchRecursive($node, $ret, $groupIds);
        }

        assert('empty($groupIds)');

        return $ret;
    }

    /**
     * @param array $node
     * @param array $ret
     * @param array $groupIds
     */
    private function searchRecursive(
        array &$node,
        array &$ret,
        array &$groupIds
    ) {
        $groupId = $node['oid'];
        $this->expandToAndDisplayChild($groupId);
        $key = array_search($groupId, $groupIds);
        if ($key !== false) {
            $ret[] = $this->generatePath($groupId);
            unset($groupIds[$key]);
        }

        foreach ($node['children'] as &$child) {
            $this->searchRecursive($child, $ret, $groupIds);
        }
    }

    /**
     * @param string $groupId
     *
     * @return array
     */
    private function generatePath($groupId)
    {
        $uum_util = $this->getUumUtil();

        return [
            "id"   => $groupId,
            "name" => $uum_util->getGroupPathString($groupId, ' > ')
        ];
    }
}

/**
 * Provide utility methods over GRN_OrgTree for View-Controller.
 *
 * @package grn.common
 */
class GRN_OrgTreeUtil extends CB_ModuleBase
{
    /**
     * @return GRN_OrgTreeUtil
     */
    public static function getInstance()
    {
        static $_instance = null;
        if (is_null($_instance)) {
            $_instance = new GRN_OrgTreeUtil();
        }

        return $_instance;
    }

    function __construct()
    {
        parent::__construct('grn.common.org_tree_util');
    }

    /**
     * @param string $name
     * @param null   $class_name
     * @param null   $params
     * @param bool   $create_new
     *
     * @return GRN_OrgTree|mixed
     */
    function &getTree(
        $name,
        $class_name = null,
        $params = null,
        $create_new = false
    ) {
        $session = parent::getSession();

        $serialized = $session->get($name);

        global $G_container_base;
        /** @var GRN_Uum $uum */
        $uum = $G_container_base->getInstance('uum');
        $user = $uum->getLoginUser();

        $create = false;
        if (is_null($serialized)) {
            $create = true;
        } else {
            $tree = cb_unserialize($serialized, [
                "allowed_classes" => [
                    "GRN_OrgTree",
                    "GRN_Bulletin_FolderTree",
                    "GRN_Cabinet_FolderTree",
                    "GRN_Link_CategoryTree",
                    "GRN_Link_SystemCategoryTree",
                    "GRN_Mail_FolderTree",
                    "GRN_Memo_FolderTree",
                    "GRN_Message_FolderTree",
                    "GRN_Report_CategoryTree",
                    "GRN_Schedule_PortletOrgTree",
                    "GRN_FacilityTree",
                    "GRN_FacilityAccessTree",
                    "GRN_FacilityPrivilegeTree",
                    "GRN_FacilityGroupMoveTree",
                    "GRN_FacilityGroupMovePrivilegeTree",
                    "GRN_PrivilegedOrgTree",
                    "grn\\system\\sandbox\\GRN_OrgSandboxTree"
                ]
            ]);
            if ($tree->getUID() !== $user->getOID()) {
                $create = true;
            }
        }

        if ($create_new) {
            $create = true;
        }
        if ($create) {
            if (is_null($class_name)) {
                $tree = new GRN_OrgTree();
            } else {
                $tree = new $class_name($params);
            }
            $tree->setUID($user->getOID());
        }

        // check update from system and init
        if ($class_name != 'GRN_FacilityGroupMoveTree'
            && $class_name != 'GRN_FacilityGroupMovePrivilegeTree'
        ) {
            $this->initTreeByUpdateSystem($name, $tree);
        }

        return $tree;

    }

    /**
     * @param             $name
     * @param GRN_OrgTree $tree
     */
    function setTree($name, & $tree)
    {
        $session = parent::getSession();

        $session->set($name, serialize($tree));

    }

    /**
     * @param string $key
     *
     * @return null|string
     */
    function getAttribute($key)
    {
        $profile = $this->getSystemProfile();

        $value = null;
        $ret = $profile->getAttribute($key, $value);
        if ($ret) {
            return $value;
        }

        return null;
    }

    /**
     * @param $key
     * @param $value
     *
     * @return bool
     */
    function setAttribute($key, $value)
    {
        $profile = $this->getSystemProfile();

        $temp = null;
        $ret = $profile->getAttribute($key, $temp);
        if ($ret === false) {
            $ret = $profile->createAttribute($key, $value);
            if ($ret === false) {
                return false;
            }
        }

        return $profile->updateAttribute($key, $value);
    }

    /**
     * @return   array   init page list
     */
    function getInitPageList()
    {
        $init_page = $this->getAttribute('init_page_list');
        if ( ! is_array($init_page)) {
            $init_page = [];
        }

        return $init_page;
    }

    /**
     * update init page list and time for tree
     *
     * @param array       $pages page names
     * @param GRN_OrgTree $tree
     */
    function updateInitPageList($pages, $tree)
    {
        if ( ! is_array($pages)) {
            $pages = [$pages];
        }
        $init_page = $this->getInitPageList();
        $init_time = time();
        // set init time for tree
        $tree->init_time = $init_time;
        foreach ($pages as $page) {
            $page_parts = explode('/', $page);
            // update init page list
            $init_page[$page_parts[0]] = $init_time;
            $this->setAttribute('init_page_list', $init_page);
        }
    }

    /**
     * check and init tree
     *
     * @param   array       $page page name
     * @param   GRN_OrgTree $tree GRN_OrgTree object
     */
    function initTreeByUpdateSystem($page, $tree)
    {
        // get init time
        $init_page = $this->getInitPageList();
        $page_parts = explode('/', $page);
        $module = $page_parts[0];
        $tree->check_init = false;
        if (array_key_exists($module, $init_page)) {
            $init_time = $init_page[$module];
            if ($init_time > $tree->init_time) {
                $tree->initialize();
                $tree->check_init = true;
            }
        } else {
            $this->updateInitPageList($page, $tree);
            $tree->initialize();
            $tree->check_init = true;
        }
    }
}

/**
 * @param      $list_page
 * @param      $class_name
 * @param null $expand_oid
 *
 * @return GRN_OrgTree|mixed
 */
function grn_rebuild_tree_group_user(
    $list_page,
    $class_name,
    $expand_oid = null
) {
    require_once('grn/org_tree.csp');
    $util = GRN_OrgTreeUtil::getInstance();
    $tree = $util->getTree($list_page, $class_name);
    $tree->rebuild();
    if ( ! is_null($expand_oid)) {
        require_once('grn/nested_set_model.csp');
        $nested_group = GRN_NestedGroup::getInstance();
        $ancestors = $nested_group->getAncestorsByID($expand_oid, true);
        if ($ancestors !== false) {
            foreach (array_keys($ancestors) as $ancestor) {
                $tree->buildChild($ancestor);
            }
        }
    }

    return $tree;
}


