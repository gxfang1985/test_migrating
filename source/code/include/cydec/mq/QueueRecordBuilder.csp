<?php

namespace grn\cydec\mq;

use grn\fts\SearchEntry;
use grn\fts\SearchFields;

/**
 *
 * Class QueueRecordBuilder
 *
 * @package grn\cydec\mq
 */
class QueueRecordBuilder
{
    /** @var  JobMessage */
    private $jobMessage;

    private $arguments = [];
    /**
     * @see build
     * @var \Closure
     */
    private $onBuildFunction;

    /**
     * @param JobMessage $jobMessage
     * @param \Closure   $onBuildFunction
     *        function(QueueRecordInterface[]):void;
     *        build実行時のコールバック。QueueRecordBuilder内に蓄積したデータから変換されたQueueRecordInterface[]が渡される
     */
    public function __construct(
        JobMessage $jobMessage,
        \Closure $onBuildFunction
    ) {
        $this->jobMessage = $jobMessage;
        $this->onBuildFunction = $onBuildFunction;
    }

    /**
     * @param array|string $argument
     * @param string       $argument_type
     */
    public function addArgument($argument, $argument_type = null)
    {
        if (json_encode($argument) === false) {
            $this->logFailedJsonEncode($argument);

            return;
        }

        if ($this->jobMessage->exceedsSize($this->arguments, $argument,
            $argument_type)
        ) {
            // If the size of stored $arguments exceeds the limit which defined for each message types,
            // insert it to MySQL and refresh it.
            $this->build();
        }

        if ($argument_type === null) {
            $this->arguments[] = $argument;
        } else {
            $this->arguments[$argument_type][] = $argument;
        }
    }

    /**
     * 内部データをQueueRecordInterface[]に変換し、内部に蓄積したデータを開放する
     * QueueRecordInterface[]をコールバックに渡して関数を実行する
     */
    public function build()
    {
        if (empty($this->arguments)) {
            return;
        }
        $message
            = json_encode($this->jobMessage->constructMessage($this->arguments),
            JSON_UNESCAPED_UNICODE);

        if ($message !== false) {
            $callBack = $this->onBuildFunction;
            $callBack([
                new QueueRecord($message, $this->jobMessage->getJobName())
            ]);
        } else {
            $this->logFailedJsonEncode();
        }
        $this->arguments = [];
        gc_collect_cycles();
    }

    /**
     * @param $forward
     */
    public function setForward($forward)
    {
        if ($this->jobMessage instanceof FTSIndexJobMessage) {
            $this->jobMessage->setForward($forward);
        }
    }

    /**
     * @param array|string|null $argument
     */
    private function logFailedJsonEncode($argument = null)
    {
        if (is_array($argument)) {
            $doc = cb_at($argument, SearchEntry::DOC_ARG_KEY, []);
            $id = cb_at($doc, SearchFields::ID_FIELD, '');
        } else {
            $id = '';
        }

        $errorMsg = json_last_error_msg();
        $errorCode = json_last_error();

        if (defined('ON_FOREST')) {
            $domain = \CB_CyDECUtil::getInstance()->getDomainID();
            $message
                = "Failed to json_encode()!! [domain: {$domain}, id: {$id}, message: {$errorMsg}, code: {$errorCode}]";
        } else {
            $message
                = "Failed to json_encode()!! [id: {$id}, message: {$errorMsg}, code: {$errorCode}]";
        }
        syslog(LOG_ERR, $message);
    }
}
