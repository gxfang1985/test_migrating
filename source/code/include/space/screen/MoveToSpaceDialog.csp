<?php

namespace grn\space\screen;

use grn\space\common\data\bean\Authority;
use grn\space\data\collection\SpaceCollection;
use grn\space\data\condition\FolderSearchCondition;
use grn\space\data\condition\SpaceSearchCondition;
use grn\space\service\SpaceService;
use grn\space\utility\SpaceUtility;
use grn\space\common\utility\SpaceMemberUtility;

/**
 * Class MoveToSpaceDialog
 *
 */
class MoveToSpaceDialog extends GenericScreenBase
{
    const ARG_OFFSET = "sp";
    const PATH_TEMPLATE_FILE = "space/_space_list_dialog.tpl";
    const PATH_TEMPLATE_ITEM_FILE = "space/_space_list_item_dialog.tpl";

    private $_offset;
    private $_spaceCollection;
    private $_naviInfo;
    private $_listOnly = false;

    /**
     * @return mixed|string|void
     */
    public function fetch()
    {
        require_once("grn/smarty.csp");
        $smarty = new \GRN_Smarty();

        $input = $this->getInput();
        $this->setOffsetFromInput($input);
        $this->setListOnly($input);

        $spid = cb_at($input, 'spid');
        $this->verifySpaceIsNotExpired();
        // Make page navi
        $controllerUtil = new \GRN_ControllerUtil();
        $offset = $this->getOffset();
        $limit = $this->getUserConfig()->getListMax();

        $spaceService = SpaceService::getInstance();

        $spaceSearchCondition = new SpaceSearchCondition();
        $spaceSearchCondition->setSearchParticipantUserId($this->getLoginUserId());
        $spaceSearchCondition->setSearchParticipantGroupIds(SpaceMemberUtility::getLoginUserGroupIds());
        $spaceSearchCondition->setSearchParticipantRoleIds(SpaceMemberUtility::getLoginUserRoleIds());
        $spaceSearchCondition->setOrderSortArray(
            [
                SpaceSearchCondition::SORT_COMPONENT_MODIFY_TIME_DESC,
                SpaceSearchCondition::SORT_ID_DESC
            ]
        );
        $spaceSearchCondition->setLimit($limit + 1);
        $spaceSearchCondition->setLanguageCode($this->getLanguageCode());
        $spaceSearchCondition->setCalcFoundRows(false);
        $spaceSearchCondition->setSearchExcludeSpaceIdArray([$spid]);
        $spaceSearchCondition->setSearchSpaceExpirationDate(SpaceSearchCondition::SEARCH_SPACE_NOT_EXPIRED);
        $spaceCollection = new SpaceCollection();
        do {
            if ($offset < 0) {
                $offset = 0;
                break;
            }

            $spaceSearchCondition->setOffset($offset);

            /** @var \grn\space\data\collection\SpaceCollection $spaceCollection */
            $spaceCollection
                = $spaceService->searchSpaceBySearchConditionWithAccessControl(
                Authority::AUTHORITY_CODE_READ_SUMMARY, $spaceSearchCondition,
                $this->getLoginUserId(),
                SpaceService::CATEGORY_NAME_IS_NECESSARY
            );

            if ($spaceCollection->count() == 0) {
                $offset -= $limit;
            }
        } while ($spaceCollection->count() == 0);

        $hasNextPage = ($spaceCollection->count() > $this->getUserConfig()
                                                         ->getListMax());
        if ($hasNextPage) {
            $spaceCollection->remove($this->getUserConfig()->getListMax());
        }
        SpaceUtility::truncateSpaceUsingUserConfig($spaceCollection,
            $this->getLoginUser());
        $this->setSpaceCollection($spaceCollection);

        $folderList = [];
        for ($i = 0; $i < $spaceCollection->count(); $i++) {
            $space = $spaceCollection->getBean($i);

            $conditions = new FolderSearchCondition();
            $conditions->setSpaceId($space->getId());

            $folderCollection
                = $spaceService->getFolderListByCondition($conditions);

            if ($folderCollection->count() > 0) {
                $folderList[$space->getId()] = $folderCollection;
            }
        }

        $pageNavi = $controllerUtil->makeSimpleNaviInformation(
            $offset, $limit, $spaceCollection->count(), $hasNextPage
        );
        $this->setNaviInfo($pageNavi);

        $smarty->assign("this", $this);
        $smarty->assign('number_on_page', $limit);
        $smarty->assign("folderList", $folderList);

        if ($this->getListOnly()) {
            return $smarty->fetch(self::PATH_TEMPLATE_ITEM_FILE);
        } else {
            return $smarty->fetch(self::PATH_TEMPLATE_FILE);
        }

    }

    /**
     * Get Space list as an array
     *
     * @return array<Space>
     */
    public function getSpaceListArray()
    {
        $result = [];
        $spaceCollection = $this->getSpaceCollection();

        for ($i = 0; $i < $spaceCollection->count(); $i++) {
            $result[] = $spaceCollection->getBean($i);
        }

        return $result;
    }

    /**
     *
     * @return SpaceCollection
     */
    private function getSpaceCollection()
    {
        return $this->_spaceCollection;
    }

    /**
     * Set my Space collection
     *
     * @param SpaceCollection $spaceCollection
     */
    private function setSpaceCollection(SpaceCollection $spaceCollection)
    {
        $this->_spaceCollection = $spaceCollection;
    }

    /**
     * @return mixed
     */
    private function getOffset()
    {
        return $this->_offset;
    }

    /**
     * @param $input
     */
    private function setOffsetFromInput($input)
    {
        if (array_key_exists(self::ARG_OFFSET, $input)
            && is_numeric($input[self::ARG_OFFSET])
        ) {
            $this->_offset = (int)$input[self::ARG_OFFSET];
        } else {
            $this->_offset = 0;
        }
    }

    /**
     * @param $input
     */
    public function setListOnly($input)
    {
        if (cb_at($input, self::ARG_OFFSET) !== null) {
            $this->_listOnly = true;
        }
    }

    /**
     * @return bool
     */
    public function getListOnly()
    {
        return $this->_listOnly;
    }

    /**
     * @param $navi_info
     */
    public function setNaviInfo($navi_info)
    {
        $this->_naviInfo = $navi_info;
    }

    /**
     * @return mixed
     */
    public function getNaviInfo()
    {
        return $this->_naviInfo;
    }
}
