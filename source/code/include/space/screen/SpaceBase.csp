<?php

namespace grn\space\screen;

use grn\grn\MemberLogic;
use grn\space\common\exception\GrnRequiredDataIsNotException;
use grn\space\data\collection\ThreadCollection;
use grn\space\common\exception\GrnDataNotFoundException;
use grn\space\common\utility\SpaceDatetimeUtility;
use grn\space\utility\SpaceMemoUtility;
use grn\space\common\data\collection\CategoryCollection;
use grn\space\common\utility\CategoryUtility;
use grn\space\data\CategoryTreeSession;
use grn\space\common\data\condition\CategorySearchCondition;
use grn\space\service\SpaceService;
use grn\space\common\data\collection\IconCollection;
use grn\space\data\bean\SpaceLocal;
use grn\space\data\collection\SpaceLocalCollection;
use grn\space\common\utility\ValidateUtility;
use grn\space\common\exception\ErrorCode;
use grn\space\data\bean\Space;
use grn\space\common\exception\GrnInvalidArgumentException;
use grn\space\data\bean\SpaceUser;
use grn\space\data\collection\SpaceUserCollection;
use grn\space\data\collection\FolderCollection;
use grn\space\common\utility\SpaceMemberUtility;

/**
 * Class SpaceBase
 *
 */
class SpaceBase extends GenericScreenBase
{
    const ARG_NAME_BASE = "name";
    const ARG_MEMBERS = "sUID";
    const ARG_OPERATOR_SET = "operator-set";
    const ARG_OPERATORS = "sUID_o";
    const ARG_DISCUSSION = "discussion";
    const ARG_FOLDER = "folder";
    const ARG_MEMO = "spacememo";
    const ARG_MEMO_DATA = "data";
    const ARG_IS_RICH_EDIT = "editor";
    const ARG_ICON = "icon";
    const ARG_IS_PUBLIC = "isPublic";
    const ARG_IS_UNLIMITED_EXPIRATION_DATE = "default_expiration_date";
    const ARG_FROM_PARAM = "top";
    const ARG_DAY = "expiration_date_day";
    const ARG_MONTH = "expiration_date_month";
    const ARG_YEAR = "expiration_date_year";
    const ARG_HOUR = "expiration_date_hour";
    const ARG_MINUTE = "expiration_date_minute";

    const URL_TOP = "space/top";
    const URL_CONFIG_VIEW = "space/config_view";

    //Constraint of the space name.
    const MAX_LENGTH_NAME = 100;
    const MIN_LENGTH_NAME = 0;
    CONST ALLOW_UNLIMITED_EXPIRATION_DATE = "1";

    /**
     * space object
     *
     * @var Space
     */
    private $space;

    /**
     * set space operator or not
     *
     * @var bool
     */
    private $openStatus;

    /**
     * Whether the Space is public
     *
     * @var boolean
     */
    private $isPublic;

    /**
     *
     * @var boolean
     */
    private $isUnlimitedExpirationDate;

    /**
     *
     * @var boolean
     */
    private $isExpirationDateSpecifiedTime;
    /**
     * @var int
     */
    private $expirationDateTimestamp;
    /**
     * whether allow you join or leave space by himself
     *
     * @var boolean
     */
    private $allowJoinLeave;

    /**
     * Common name of the space.
     *
     * @var string
     */
    private $commonName;

    /**
     * the members of the space
     *
     * @var SpaceUserCollection
     */
    private $spaceUserCollection;

    /**
     * the operators of the space
     *
     * @var SpaceUserCollection
     */
    private $spaceOperatorCollection;

    /**
     * Icon ID of the Space
     *
     * @var string
     */
    private $iconId;

    /**
     * localized names of the Space
     *
     * @var SpaceLocalCollection
     */
    private $spaceLocalCollection;

    /**
     * space user collection from input
     *
     * @var SpaceUserCollection
     */
    private $inputSpaceUserCollection;

    /**
     * space operator collection from input
     *
     * @var SpaceUserCollection
     */
    private $inputSpaceOperatorCollection;

    /**
     * Selected user array
     *
     * array(
     *   (User ID) => "User Name",
     * )
     *
     * @var array
     */
    private $selectedUserArray;

    /**
     * Array constructed by valid user id.
     *
     * @var array
     */
    private $validUserArray = [];

    private $iconCollection;

    private $categoryCollection;

    private $categoryDataJson;

    private $memo;

    private $inputFolderCollection;
    private $inputThreadCollection;
    private $inputMemo;

    private $editor;

    /**
     * Get Array to give grn_text_multilanguage
     *
     * @return array
     */
    private $multilingualSpaceNameArray;

    /**
     * Category tree array
     *
     * This value will be given to grn/org_tree_26.tpl
     *
     * @var array
     */
    private $categoryTreeArrayForView;

    /**
     * Selected operator array
     *
     * array(
     *   (User ID) => "User Name",
     * )
     *
     * @var array
     */
    private $selectedOperatorArray;

    /**
     * @return Space
     */
    public function getSpace()
    {
        return $this->space;
    }

    /**
     * @param Space $space
     */
    protected function setSpace(Space $space)
    {
        $this->space = $space;
    }

    /**
     * @return bool
     */
    public function getOpenStatus()
    {
        return $this->openStatus;
    }

    /**
     * @param $openStatus
     */
    protected function setOpenStatus($openStatus)
    {
        $this->openStatus = $openStatus;
    }

    /**
     * Get whether the space is public
     *
     * @return boolean
     */
    public function isPublic()
    {
        return $this->isPublic;
    }

    /**
     * Whether the space is unlimited expiration date
     *
     * @return bool
     */
    public function isUnlimitedExpirationDate()
    {
        return $this->isUnlimitedExpirationDate;
    }

    /**
     * Set up isPublic field
     *
     * @param array $input
     *
     * @throws GrnInvalidArgumentException
     */
    protected function setIsPublicFromInput($input)
    {
        if (@$input[self::ARG_IS_PUBLIC]) {
            $this->isPublic = true;
        } else {
            $this->isPublic = false;
        }
    }

    protected function setIsUnlimitedExpirationDate($input)
    {
        $is_unlimited = $input[self::ARG_IS_UNLIMITED_EXPIRATION_DATE] ?? '0';
        if ($is_unlimited === self::ALLOW_UNLIMITED_EXPIRATION_DATE) {
            $this->isUnlimitedExpirationDate = true;
        } else {
            $this->isUnlimitedExpirationDate = false;
        }
    }

    /**
     * @return bool
     */
    public function getExpirationDateSpecifiedTime()
    {
        return $this->isExpirationDateSpecifiedTime;
    }

    /**
     * @param bool $value
     */
    public function setExpirationDateSpecifiedTime(bool $value)
    {
        $this->isExpirationDateSpecifiedTime = $value;
    }

    /**
     * @return int
     */
    protected function getExpirationDateTimestamp()
    {
        return $this->expirationDateTimestamp;
    }

    public function setExpirationDateTimestamp($input)
    {
        $limited_expiration_datetime = new \CB_DateTime();

        $limited_expiration_datetime->year = cb_at($input, self::ARG_YEAR);
        $limited_expiration_datetime->month = cb_at($input, self::ARG_MONTH);
        $limited_expiration_datetime->day = cb_at($input, self::ARG_DAY);

        $hour = cb_at($input, self::ARG_HOUR);
        $minute = cb_at($input, self::ARG_MINUTE);
        $is_hour_minute_invalid = ($hour === '' && $minute !== '')
                                  || ($hour !== ''
                                      && $minute === '');
        if ($is_hour_minute_invalid) {
            throw  new GrnInvalidArgumentException(ErrorCode::GRN_INVALID_EXPIRATION_DATE_TIME);
        }
        if ($hour == '') {
            $hour = 23;
        }

        if ($minute == '') {
            $minute = 59;
        }

        if ($hour == 23 && $minute == 59) {
            $this->setExpirationDateSpecifiedTime(false);
        } else {
            $this->setExpirationDateSpecifiedTime(true);
        }

        $limited_expiration_datetime->hour = $hour;
        $limited_expiration_datetime->minute = $minute;
        $limited_expiration_datetime->second = 0;

        if ( ! $this->isValidExpirationDateTime($limited_expiration_datetime)) {
            throw new GrnInvalidArgumentException(ErrorCode::GRN_INVALID_EXPIRATION_DATE_TIME);
        }

        $expiration_date_time = new \CB_TimeStampEx();
        $expiration_date_time->setDateTime($limited_expiration_datetime);

        $this->expirationDateTimestamp = $expiration_date_time->unix_ts;
    }

    /**
     * @param CB_DateTime $limited_datetime
     *
     * @return bool
     */
    public function isValidExpirationDateTime($limited_datetime)
    {
        if ( ! cb_date_validate_datetime($limited_datetime)) {
            return false;
        }
        $expiration_date_time = new \CB_TimeStampEx();
        $expiration_date_time->setDateTime($limited_datetime);

        $now = new \CB_TimeStampEx();
        if ($expiration_date_time->compare($now) <= 0) {
            return false;
        }

        return true;
    }

    /**
     * Get common name of the Space
     *
     * @return string
     */
    public function getCommonName()
    {
        return $this->commonName;
    }

    /**
     * Set up the common name of the Space
     *
     * @param array $input
     *
     * @throws GrnInvalidArgumentException
     */
    protected function setCommonNameFromInput(array $input)
    {
        //get language values
        require_once('fw/i18n.csp');
        $inputLocalNameArray = \getMultiLanguageText(self::ARG_NAME_BASE,
            $input);

        if ( ! array_key_exists("def", $inputLocalNameArray)) {
            throw new GrnInvalidArgumentException(ErrorCode::GRN_INVALID_SPACE_NAME);
        }
        $inputLocalNameArray["def"] = cb_trim($inputLocalNameArray["def"]);
        if ( ! ValidateUtility::isMultiShorterThan($inputLocalNameArray["def"],
            self::MAX_LENGTH_NAME)
        ) {
            throw new GrnInvalidArgumentException(ErrorCode::GRN_INVALID_SPACE_NAME);
        }
        if ( ! ValidateUtility::isMultiLongerThan($inputLocalNameArray["def"],
            self::MIN_LENGTH_NAME)
        ) {
            throw new GrnInvalidArgumentException(ErrorCode::GRN_INVALID_SPACE_NAME);
        }
        $this->commonName = preg_replace('/\s\s+/', ' ',
            $inputLocalNameArray["def"]);
    }

    /**
     * @return string
     */
    public function getIconId()
    {
        return $this->iconId;
    }

    /**
     * Set up Icon ID with $G_INPUT
     *
     * @param array $input
     *
     * @throws GrnInvalidArgumentException
     */
    protected function setIconIdFromInput($input)
    {
        if ( ! array_key_exists(self::ARG_ICON, $input)) {
            throw new GrnInvalidArgumentException(ErrorCode::GRN_ICON_NOT_FOUND);
        }
        if ( ! ValidateUtility::isNumber($input[self::ARG_ICON],
            ValidateUtility::DISABLE_EMPTY,
            ValidateUtility::EXCEPTION_NOT_THROW)
        ) {
            throw new GrnInvalidArgumentException(ErrorCode::GRN_ICON_NOT_FOUND);
        }
        $this->iconId = $input[self::ARG_ICON];
    }

    /**
     * Get SpaceLocalCollection
     *
     * @return SpaceLocalCollection
     */
    public function getSpaceLocalCollection()
    {
        return $this->spaceLocalCollection;
    }

    /**
     * Set up SpaceLocalCollection with $G_INPUT
     *
     * @param array $input
     */
    protected function setSpaceLocalCollectionFromInput(array $input)
    {
        //get language values
        require_once('fw/i18n.csp');
        $inputLocalNameArray = \getMultiLanguageText(self::ARG_NAME_BASE,
            $input);

        require_once("fw/i18n/locale.csp");
        $languageCodes = \CB_LanguageManager::getAvailableLanguages();

        $this->spaceLocalCollection = new SpaceLocalCollection();
        foreach ($languageCodes as $eachLanguageCode) {
            if (array_key_exists($eachLanguageCode, $inputLocalNameArray)
                && ValidateUtility::isMultiShorterThan(cb_trim($inputLocalNameArray[$eachLanguageCode]),
                    self::MAX_LENGTH_NAME)
                && ValidateUtility::isMultiLongerThan(cb_trim($inputLocalNameArray[$eachLanguageCode]),
                    self::MIN_LENGTH_NAME)
            ) {
                $tmpSpaceLocal = new SpaceLocal();
                $tmpSpaceLocal->setSpaceName(cb_trim($inputLocalNameArray[$eachLanguageCode]));
                $tmpSpaceLocal->setLanguageCode($eachLanguageCode);
                $this->spaceLocalCollection->appendBean($tmpSpaceLocal);
            }
        }
    }

    /**
     * @return SpaceUserCollection
     */
    public function getSpaceUserCollection()
    {
        return $this->spaceUserCollection;
    }

    /**
     * @param SpaceUserCollection $spaceUserCollection
     */
    protected function setSpaceUserCollection(
        SpaceUserCollection $spaceUserCollection
    ) {
        $this->spaceUserCollection = $spaceUserCollection;
    }

    /**
     * @return SpaceUserCollection
     */
    public function getSpaceOperatorCollection()
    {
        return $this->spaceOperatorCollection;
    }

    /**
     * @param SpaceUserCollection $spaceOperatorCollection
     */
    protected function setSpaceOperatorCollection(
        SpaceUserCollection $spaceOperatorCollection
    ) {
        $this->spaceOperatorCollection = $spaceOperatorCollection;
    }

    /**
     * @return SpaceUserCollection
     * @throws GrnInvalidArgumentException
     */
    public function getSpaceUserCollectionFromInput()
    {
        if ($this->inputSpaceUserCollection->count() < 1) {
            throw new GrnInvalidArgumentException(ErrorCode::GRN_INVALID_MEMBER);
        }

        return $this->inputSpaceUserCollection;
    }

    /**
     * Set up SpaceUserCollection
     *
     * @param array $input
     *
     * @throws GrnInvalidArgumentException
     */
    protected function setSpaceUserCollectionFromInput(array $input)
    {
        $this->inputSpaceUserCollection = new SpaceUserCollection();
        if (count($this->getValidUserIdArray()) < 1) {
            $this->setValidUserIdArray($input);
        }
        $validUserIdArr = $this->getValidUserIdArray();
        foreach ($validUserIdArr as $member_info) {
            $eachSpaceUser = new SpaceUser();
            $member_id = $member_info[MemberLogic::MEMBER_ID];
            switch ($member_info[MemberLogic::MEMBER_TYPE]) {
                case MemberLogic::TYPE_USER :
                    $eachSpaceUser->setUser($member_id);
                    break;
                case MemberLogic::TYPE_ORGANIZATION :
                    $eachSpaceUser->setGroup($member_id);
                    break;
                case MemberLogic::TYPE_STATIC_ROLE :
                    $eachSpaceUser->setRole($member_id);
                    break;
                default :
                    throw new GrnInvalidArgumentException();
                    break;
            }
            $this->inputSpaceUserCollection->appendBean($eachSpaceUser);
        }
    }

    /**
     * @return SpaceUserCollection
     */
    public function getSpaceOperatorCollectionFromInput()
    {
        return $this->inputSpaceOperatorCollection;
    }

    /**
     * Set up SpaceOperatorCollection.
     *
     * @param array $input
     *
     * @throws GrnInvalidArgumentException
     * @throws \grn\space\common\exception\GrnArgumentOutOfRangeException
     */
    protected function setSpaceOperatorCollectionFromInput(array $input)
    {
        $this->inputSpaceOperatorCollection = new SpaceUserCollection();
        if ( ! array_key_exists(self::ARG_OPERATOR_SET, $input)) {
            return;
        }
        if ( ! (array_key_exists(self::ARG_OPERATORS, $input)
                && count($input[self::ARG_OPERATORS]) > 0)
        ) {
            throw new GrnInvalidArgumentException(ErrorCode::GRN_INVALID_OPERATOR);
        }
        $operatorIdList = $input[self::ARG_OPERATORS];
        if (count($this->getValidUserIdArray()) < 1) {
            $this->setValidUserIdArray($input);
        }
        $validUserIdArray = $this->getValidUserIdArray();
        foreach ($operatorIdList as $operatorId) {
            $member_info
                = SpaceMemberUtility::getPickoutMemberInfo($operatorId);
            $member_id = $member_info[MemberLogic::MEMBER_ID];
            $member_type = $member_info[MemberLogic::MEMBER_TYPE];
            if ( ! isset($validUserIdArray[$member_type . $member_id])) {
                continue;
            }

            $eachSpaceUser = new SpaceUser();
            $eachSpaceUser->setId($member_id);
            switch ($member_type) {
                case MemberLogic::TYPE_USER :
                    $eachSpaceUser->setUser($member_id);
                    break;
                case MemberLogic::TYPE_ORGANIZATION :
                    $eachSpaceUser->setGroup($member_id);
                    break;
                case MemberLogic::TYPE_STATIC_ROLE :
                    $eachSpaceUser->setRole($member_id);
                    break;
                default :
                    throw new GrnInvalidArgumentException();
                    break;
            }
            $this->inputSpaceOperatorCollection->appendBean($eachSpaceUser);
        }

    }

    /**
     * @return array
     */
    public function getValidUserIdArray()
    {
        return $this->validUserArray;
    }

    /**
     * @param array $input
     *
     * @throws GrnInvalidArgumentException
     */
    protected function setValidUserIdArray(array $input)
    {
        if ( ! array_key_exists(self::ARG_MEMBERS, $input)) {
            throw new GrnInvalidArgumentException(ErrorCode::GRN_INVALID_MEMBER);
        }
        if ( ! is_array($input[self::ARG_MEMBERS])) {
            throw new GrnInvalidArgumentException(ErrorCode::GRN_INVALID_MEMBER);
        }
        $rawIdList = $input[self::ARG_MEMBERS];
        require_once('grn/uum.csp');
        $uum = new \GRN_Uum();
        $userIds = [];
        foreach ($rawIdList as $rawId) {
            $member_info = SpaceMemberUtility::getPickoutMemberInfo($rawId);
            $member_id
                = $member_info[MemberLogic::MEMBER_ID];
            $member_type
                = $member_info[MemberLogic::MEMBER_TYPE];
            $this->validUserArray[$member_type . $member_id] = $member_info;
            switch ($member_type) {
                case MemberLogic::TYPE_USER :
                    $userIds[] = $member_info[MemberLogic::MEMBER_ID];
                    $this->validUserArray[MemberLogic::TYPE_USER . $member_id]
                        = $member_info;
                    break;
                case MemberLogic::TYPE_ORGANIZATION :
                    $this->validUserArray[MemberLogic::TYPE_ORGANIZATION
                                          . $member_id]
                        = $member_info;
                    break;
                case MemberLogic::TYPE_STATIC_ROLE :
                    $this->validUserArray[MemberLogic::TYPE_STATIC_ROLE
                                          . $member_id]
                        = $member_info;
                    break;
                default :
                    throw new GrnInvalidArgumentException();
                    break;
            }
        }
        // check input user ids exists.
        $users_info = $uum->getUsersInfo($userIds, []);

        foreach ($userIds as $id) {
            if ( ! isset($users_info[$id])) {
                unset($this->validUserArray[MemberLogic::TYPE_USER . $id]);
            }
        }

    }

    /**
     * Pick out only the user ID.
     *
     * The user ID from the form may be conbined with the group ID like "(userID):(groupID)".
     *
     * @param string $id
     */
    private function pickoutUserId($id)
    {
        $idList = explode(":", $id);

        return $idList[0];
    }

    /**
     * @param SpaceUserCollection $userCollection
     *
     * @return array
     */
    public function getDisplayInfoByUserCollection(
        SpaceUserCollection $userCollection
    ) {
        return $userCollection->toArrayMembers();
    }

    /**
     * @return array
     */
    public function getSelectedUserArray()
    {
        return $this->selectedUserArray;
    }

    /**
     * @param array $selectedUserArray
     */
    protected function setSelectedUserArray(array $selectedUserArray)
    {
        $this->selectedUserArray = $selectedUserArray;
    }

    /**
     * @return array
     */
    public function getSelectedOperatorArray()
    {
        return $this->selectedOperatorArray;
    }

    /**
     * @param array $selectedOperatorArray
     */
    protected function setSelectedOperatorArray(array $selectedOperatorArray)
    {
        $this->selectedOperatorArray = $selectedOperatorArray;
    }

    /**
     * @return mixed
     */
    public function getIconCollection()
    {
        return $this->iconCollection;
    }

    /**
     * @param IconCollection $iconCollection
     */
    protected function setIconCollection(IconCollection $iconCollection)
    {
        $this->iconCollection = $iconCollection;
    }

    /**
     * Get Array to give grn_text_multilanguage
     *
     * @return array
     */
    public function getMultilingualSpaceNameArray()
    {
        return $this->multilingualSpaceNameArray;
    }

    /**
     * Set Array to give grn_text_multilanguage
     *
     * @param array $multilingualSpaceNameArray
     */
    protected function setMultilingualSpaceNameArray(
        array $multilingualSpaceNameArray
    ) {
        $this->multilingualSpaceNameArray = $multilingualSpaceNameArray;
    }

    /**
     * Get category tree array
     *
     * This value will be given to grn/org_tree_26.tpl
     */
    public function getCategoryTreeArrayForView()
    {
        return $this->categoryTreeArrayForView;
    }

    /**
     * Set category tree array
     *
     * @param array $categoryTreeArrayForView
     */
    protected function setCategoryTreeArrayForView(
        array $categoryTreeArrayForView
    ) {
        $this->categoryTreeArrayForView = $categoryTreeArrayForView;
    }

    /**
     * @param Space                $space
     * @param SpaceLocalCollection $spaceLocalCollection
     *
     * @return array
     */
    protected function makeMultilingualSpaceNameArray(
        Space $space,
        SpaceLocalCollection $spaceLocalCollection
    ) {
        $result = [
            "element_name" => "name",
            "form_name"    => "space/modify",
            "values"       => [],
        ];
        $result["values"]["def"] = $space->getSpaceName();
        /** @var \grn\space\data\bean\SpaceLocal $eachSpaceLocal */
        foreach ($spaceLocalCollection as $eachSpaceLocal) {
            $result["values"][$eachSpaceLocal->getLanguageCode()]
                = $eachSpaceLocal->getSpaceName();
        }

        return $result;
    }

    /**
     * @param CategoryCollection $categoryCollection
     * @param                    $sessionKey
     */
    protected function makeTreeInfo(
        CategoryCollection $categoryCollection,
        $sessionKey
    ) {
        // Make tree info
        $categoryTreeSession = $this->loadCategoryTreeSession($sessionKey);
        $categoryTreeSession->update($categoryCollection,
            $this->getSpace()->getCategoryId());
        $this->saveCategoryTreeSession($categoryTreeSession, $sessionKey);
        $treeJson
            = CategoryUtility::buildJsonCategoryTreeInfo($categoryCollection,
            $categoryTreeSession);
        $this->setCategoryTreeArrayForView($this->makeCategoryTreeArray($sessionKey,
            $treeJson));
    }

    /**
     * @return mixed
     */
    public function getCategoryCollection()
    {
        return $this->categoryCollection;
    }

    /**
     * @param SpaceService $spaceService
     */
    protected function setCategoryCollection(SpaceService $spaceService)
    {
        $spaceRootCategory
            = $spaceService->getSpaceRootCategory($this->getLoginUserId(),
            $this->getLanguageCode());
        $categorySearchCondition = new CategorySearchCondition();
        $categorySearchCondition->setSearchCategoryId($spaceRootCategory->getId());
        $categorySearchCondition->setSearchScopeType(CategorySearchCondition::SEARCH_SCOPE_CATEGORY_DESCENDANT);
        $this->categoryCollection
            = $spaceService->searchSpaceCategoryBySearchCondition($categorySearchCondition,
            $this->getLoginUserId(), $this->getLanguageCode());
    }

    /**
     * Load CategoryTreeSession from the session.
     *
     * @param string $sessionKey
     *
     * @return CategoryTreeSession
     */
    private function loadCategoryTreeSession($sessionKey)
    {
        require_once('fw/session_manager.csp');
        $sm = \CB_SessionManager::getInstance();
        $session = $sm->getSession($sessionKey);

        return CategoryTreeSession::loadFromSession($session);
    }

    /**
     * Save the tree data stored in the session.
     *
     * @param CategoryTreeSession $categoryTreeSession
     * @param string              $sessionKey
     */
    private function saveCategoryTreeSession(
        CategoryTreeSession $categoryTreeSession,
        $sessionKey
    ) {
        require_once('fw/session_manager.csp');
        $sm = \CB_SessionManager::getInstance();
        $session = $sm->getSession($sessionKey);
        $categoryTreeSession->saveToSession($session);
    }

    /**
     * Get an array to show category tree.
     * This value is going to be given to grn/org_tree26.js
     *
     * @param string $sessionKey
     * @param string $treeJson
     *
     * @return array
     */
    protected function makeCategoryTreeArray($sessionKey, $treeJson)
    {
        return [
            "tree_name"        => "category_tree",
            "async_url"        => "space/command_category_tree",
            "link_url"         => "space/list",
            "link_url_params"  => [],
            "page_name"        => $sessionKey,
            "selected_oid"     => $this->getSpace()->getCategoryId(),
            "oid_key"          => "cid",
            "json_template"    => "space/encoded_json.tpl",
            "root_caption"     => null,
            "root_subscribed"  => false,
            "no_root"          => false,
            "on_select"        => "grn.page.space.create.onClickCategoryTree",
            "tree_view_ele_id" => "tree-view",
            "view_part_ele_id" => "view_part",
            "set_tree_height"  => true,
            "root"             => $treeJson
        ];
    }

    /**
     * @return mixed
     */
    public function getCategoryDataJson()
    {
        return $this->categoryDataJson;
    }

    /**
     * @param SpaceService $spaceService
     * @param              $session_key
     */
    protected function setCategoryDataJson(
        SpaceService $spaceService,
        $session_key
    ) {
        $spaceRootCategory
            = $spaceService->getSpaceRootCategory($this->getLoginUserId(),
            $this->getLanguageCode());
        $categorySearchCondition = new CategorySearchCondition();
        $categorySearchCondition->setSearchCategoryId($spaceRootCategory->getId());
        $categorySearchCondition->setSearchScopeType(CategorySearchCondition::SEARCH_SCOPE_CATEGORY_DESCENDANT);
        $categorySearchCondition->setOrderSortArray([CategorySearchCondition::SORT_DISPLAY_ORDER_ASC]);
        $categoryCollection
            = $spaceService->searchSpaceCategoryBySearchCondition($categorySearchCondition,
            $this->getLoginUserId(), $this->getLanguageCode());
        $this->makeTreeInfo($categoryCollection, $session_key);

        $result = [];
        foreach ($categoryCollection->getIterator() as $eachCategory) {
            $result[$eachCategory->getId()] = [
                "name" => $eachCategory->getCategoryName()
            ];
        }
        $this->categoryDataJson = json_encode($result);
    }

    /**
     * Get Selected Icon Number
     */
    public function getSelectedIconNumber()
    {
        return $this->getSpace()->getBuiltinIconId();
    }

    /**
     *
     * @return boolean
     */
    public function isSpacePublic()
    {
        return $this->getSpace()->isPublic();
    }

    /**
     *
     * @return boolean
     */
    public function isSpacePrivate()
    {
        return ! $this->isSpacePublic();
    }

    /**
     * @return mixed
     */
    public function getSpaceMemo()
    {
        return $this->memo;
    }

    /**
     * @param SpaceService $spaceService
     *
     * @throws GrnDataNotFoundException
     * @throws \Exception
     */
    protected function setSpaceMemo(SpaceService $spaceService)
    {
        try {
            $spaceMemo = $spaceService->getSpaceMemo($this->getSpaceId(),
                $this->getLoginUserId());
            $spaceService->addInspectionUserInfo($spaceMemo,
                $this->getLoginUserId(), $this->isSystemUseEnglish(),
                $this->isEnglishDisplayAfterName(),
                $this->isOrganizationDisplayAfterName(),
                $this->getLanguageCode());
            SpaceMemoUtility::constructDisplayMemo($spaceMemo);
            SpaceDatetimeUtility::constructDisplayDatetimeOfInspection($spaceMemo,
                $this->getDatetimeFormat(),
                SpaceDatetimeUtility::DISPLAY_TYPE_LONGDATE_AND_TIME,
                $this->getLanguageCode(), $this->getTimezoneName());
            $this->memo = $spaceMemo;
        } catch (GrnDataNotFoundException $e) {
            $e->setErrorCode(ErrorCode::GRN_INVALID_SPACE_ID);
            throw $e;
        }
    }

    /**
     * @return mixed
     */
    public function getDiscCollectionFromInput()
    {
        return $this->inputThreadCollection;
    }

    /**
     * @return mixed
     */
    public function getFolderCollectionFromInput()
    {
        return $this->inputFolderCollection;
    }

    /**
     * @param       $input
     * @param array $oldDataCollection
     */
    protected function setFolderAndDiscussionCollectionFromInput(
        $input,
        array $oldDataCollection
    ) {
        $allFolder = $oldDataCollection[self::ARG_FOLDER];
        $allDiscussion = $oldDataCollection[self::ARG_DISCUSSION];

        $this->inputThreadCollection = new ThreadCollection();
        $this->inputFolderCollection = new FolderCollection();

        $folderIdListInput = cb_at($input, self::ARG_FOLDER, []);
        $discussionIdListInput = cb_at($input, self::ARG_DISCUSSION, []);

        if ( ! array_key_exists(self::ARG_DISCUSSION, $input)
             && ! array_key_exists(self::ARG_FOLDER, $input)
        ) {
            return;
        }

        if (count($discussionIdListInput) < 1
            && count($folderIdListInput) < 1
        ) {
            return;
        }

        foreach ($discussionIdListInput as $discId) {
            /** @var \grn\space\data\bean\Thread $discussion */
            foreach ($allDiscussion as $discussion) {
                if ($discId == $discussion->getId()) {
                    $this->inputThreadCollection->appendBean($discussion);
                    continue 2;
                }
            }
        }

        foreach ($folderIdListInput as $folderId) {
            /** @var \grn\space\data\bean\Folder $folder */
            foreach ($allFolder as $folder) {
                if ($folderId == $folder->getId()) {
                    $this->inputFolderCollection->appendBean($folder);
                    continue 2;
                }
            }
        }
    }

    /**
     * @return mixed
     */
    public function getMemoDataFromInput()
    {
        return $this->inputMemo;
    }

    /**
     * Set Memo data
     *
     * @param array $input
     *
     * @throws GrnRequiredDataIsNotException
     */
    protected function setMemoDataFromInput($input)
    {
        if ( ! array_key_exists(self::ARG_MEMO_DATA, $input)) {
            throw new GrnRequiredDataIsNotException(ErrorCode::GRN_MEMO_CONTENT_IS_NOT_FOUND);
        }
        $this->inputMemo = $input[self::ARG_MEMO_DATA];

    }

    /**
     *
     * @return string
     */
    public function getEditorFromInput()
    {
        return $this->editor;
    }

    /**
     *
     * Set Editor
     *
     * @param array $input
     *
     * @throws GrnRequiredDataIsNotException
     */
    protected function setEditorFromInput($input)
    {
        if ( ! array_key_exists(self::ARG_IS_RICH_EDIT, $input)) {
            throw new GrnRequiredDataIsNotException(ErrorCode::GRN_RICH_EDITOR_FLAG_IS_NOT_FOUND);
        }
        $this->editor = $this->convertToBoolean($input[self::ARG_IS_RICH_EDIT]);
    }

    /**
     * @param $arg
     *
     * @return bool
     */
    private function convertToBoolean($arg)
    {
        if ($arg) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * @param SpaceService $service
     * @param Space        $space
     *
     * @return bool
     */
    protected function checkSpaceReuseAuth(SpaceService $service, Space $space)
    {
        $userId = $this->getLoginUserId();
        $isPublic = $space->isPublic();
        $isMember = $service->isSpaceMember($userId, $space->getId(),
            $userId);
        $isSysAdmin = $this->isSpaceAdmin($service, $userId);

        return $isPublic || $isMember || $isSysAdmin;
    }

    /**
     * @param $input
     */
    protected function setInput($input)
    {
        require_once('grn/multi_select_utility.csp');
        $input = grn_deploy_selected_users('selected_users_sUID', 'sUID',
            $input);
        $input = grn_deploy_selected_users('selected_users_sUID_o', 'sUID_o',
            $input);
        parent::setInput($input);
    }

    /**
     * Get whether allow user join or leave space by himself
     *
     * @return bool
     */
    public function isAllowJoinLeave()
    {
        return $this->allowJoinLeave;
    }

    /**
     * @param array $input
     */
    protected function setAllowJoinLeave($input)
    {
        $this->allowJoinLeave = false;

        if (cb_at($input, "join_leave")) {
            $this->allowJoinLeave = true;
        }
    }

    /**
     * @return bool
     */
    public function isSpaceAllowJoinLeave()
    {
        return $this->getSpace()->isAllowJoinLeave();
    }

    /**
     * @return boolean
     */
    public function isMember()
    {
        $space_user_ids = $this->getSpaceUserCollection()->getSpaceUsersArray();

        return SpaceMemberUtility::isMember($this->getLoginUserId(),
            $space_user_ids);
    }

    /**
     * To determine whether login user is unique member of the space
     *
     * @return boolean
     */
    public function isUniqueSpaceMember()
    {
        return (count($this->getSpaceUserCollection()) < 2);
    }

    /**
     * To determine whether login user is unique administrator of the space
     * The administrator of the space not include the administrator of the space application and super administrator.
     *
     * @return bool
     */
    public function isUniqueSpaceOperatorWithCurrentUser()
    {
        $space_service = SpaceService::getInstance();
        $operators = $this->getSpaceOperatorCollection();

        if ($operators->count() == 1
            && $this->isSpaceOperator($space_service, $this->getSpaceId(),
                $this->getLoginUserId())
        ) {
            return true;
        }

        return false;
    }
}
