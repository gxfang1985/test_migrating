<?php

namespace grn\space\service;

require_once('fw/uum_core.csp');

use grn\grn\MemberLogic;
use grn\notification\bean\CategorizedNotificationUsers;
use grn\space\common\data\bean\Category;
use grn\space\common\data\collection\SpaceMemberCollection;
use grn\space\common\exception\GrnInvalidArgumentException;
use grn\space\common\utility\SpaceMemberUtility;
use grn\space\data\bean\Folder;
use grn\space\data\bean\log\MoveThreadLog;
use grn\space\data\bean\Space;
use grn\space\data\bean\SpaceUser;
use grn\space\data\bean\Todo;
use grn\space\data\collection\SpaceUserCollection;
use grn\favour\service\FavourService;
use grn\space\data\condition\TodoSearchCondition;
use grn\space\logic\TodoLogic;
use grn\space\common\data\bean\Authority;
use grn\space\common\data\bean\Comment;
use grn\space\common\data\bean\LanguageStatus;
use grn\space\common\data\bean\SpaceFile;
use grn\space\common\data\bean\SpaceMember;
use grn\space\common\data\bean\Application;
use grn\space\common\data\collection\CommentCollection;
use grn\space\common\data\collection\SpaceFileCollection;
use grn\space\common\data\condition\CommentSearchCondition;
use grn\space\common\data\condition\SpaceFileSearchCondition;
use grn\space\common\exception\ErrorCode;
use grn\space\common\exception\GrnDataNotFoundException;
use grn\space\common\exception\GrnIllegalOperationException;
use grn\space\common\logic\CategoryLogic;
use grn\space\common\logic\CommentLogic;
use grn\space\common\logic\SpaceFileLogic;
use grn\space\common\service\InternalApplicationServiceAbstract;
use grn\space\common\utility\ValidateUtility;
use grn\space\data\bean\log\DeleteThreadFollowFileLog;
use grn\space\data\bean\log\DeleteThreadFollowLog;
use grn\space\data\bean\log\DeleteThreadLog;
use grn\space\data\bean\log\ModifyThreadLog;
use grn\space\data\bean\log\DeleteThreadFileLog;
use grn\space\data\bean\log\CreateThreadFileLog;
use grn\space\data\bean\log\CreateThreadFollowFileLog;
use grn\space\data\bean\log\CreateThreadFollowLog;
use grn\space\data\bean\log\CreateThreadLog;
use grn\space\data\bean\SynthesisThreadComment;
use grn\space\data\bean\Thread;
use grn\space\data\collection\SynthesisThreadCommentCollection;
use grn\space\data\collection\ThreadCollection;
use grn\space\data\condition\ThreadSearchCondition;
use grn\space\data\condition\SynthesisThreadCommentSearchCondition;
use grn\space\data\condition\SpaceUserSearchCondition;
use grn\space\logic\SpaceAccessControlListLogic;
use grn\space\logic\SpaceLogic;
use grn\space\logic\SpaceNotificationLogic;
use grn\space\logic\ThreadLogic;
use grn\fts\Application as FtsApplication;
use grn\fts\space\IndexService;
use grn\space\logic\FolderLogic;
use grn\space\data\bean\log\BrowseThreadLog;
use grn\space\common\db\dao\SpaceMentionDAO;

/**
 * アプリケーションサービス層
 * この層は、クライアント層からの要求を、ビジネスロジック層を利用して実現する
 *
 * ディスカッションサービスクラス
 * クライアント層からのディスカッションアプリケーションに対する全ての要求を引き受ける
 */
class DiscussionService extends InternalApplicationServiceAbstract
{
    private static $_instance = null;

    /**
     * コンストラクタ
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Get Instance(Singleton pattern)
     *
     * @return DiscussionService $_instance
     */
    public static function getInstance()
    {
        if (is_null(self::$_instance)) {
            $c = __CLASS__;
            self::$_instance = new $c;
        }

        return self::$_instance;
    }

    //***************************************************************************************************************
    //**********************************             relation              ******************************************
    //***************************************************************************************************************
    /**
     * Does a specified argument has the relation?
     *
     * Access control is not used.
     *
     * @param     string $spaceId          space sequence id
     * @param     string $threadCategoryId category sequence id
     *
     * @throws    \grn\space\common\exception\GrnDatabaseException  Any error in the database.
     * @return    boolean       TRUE:has relation    FALSE:do not has a relation
     */
    private function _hasRelationSpaceThreadCategory(
        $spaceId,
        $threadCategoryId
    ) {
        try {
            $categoryLogic = CategoryLogic::getInstance();
            $categoryLogic->getCategoryBySpaceIdThreadCategoryId($spaceId,
                $threadCategoryId, LanguageStatus::STANDARD_LANGUAGE_CODE);
        } catch (GrnDataNotFoundException $exception) {
            return false;
        }

        return true;
    }

    /**
     * Does a specified argument has the relation?
     *
     * Access control is not used.
     *
     * @param     string $spaceId  space sequence id
     * @param     string $threadId thread sequence id
     *
     * @throws    \grn\space\common\exception\GrnDatabaseException  Any error in the database.
     * @return    boolean       TRUE:has relation    FALSE:do not has a relation
     */
    private function _hasRelationSpaceThread($spaceId, $threadId)
    {
        try {
            $threadLogic = ThreadLogic::getInstance();
            $threadLogic->getThreadBySpaceIdThreadId($spaceId, $threadId);
        } catch (GrnDataNotFoundException $exception) {
            return false;
        }

        return true;
    }

    /**
     * Does a specified argument has the relation?
     *
     * Access control is not used.
     *
     * @param     string $spaceId   space sequence id
     * @param     string $threadId  thread sequence id
     * @param     string $commentId comment sequence id
     *
     * @throws    \grn\space\common\exception\GrnDatabaseException  Any error in the database.
     * @return    boolean       TRUE:has relation    FALSE:do not has a relation
     */
    private function _hasRelationSpaceThreadComment(
        $spaceId,
        $threadId,
        $commentId
    ) {
        $commentLogic = CommentLogic::getInstance();

        return $commentLogic->isExistsCommentBySpaceIdThreadIdCommentId($spaceId,
            $threadId, $commentId);
    }


    //****************************************************************************************************************
    //**********************************             authority              ******************************************
    //****************************************************************************************************************
    /**
     * As for target THREAD-CATEGORY, is access control possible on the condition of arguments?
     *
     * @param     string $authorityCode    The constant has been defined in Authority class
     * @param     string $spaceId          space sequence id
     * @param     string $threadCategoryId category sequence id
     * @param     string $operationUserId  user sequence id
     *
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       authorityCode is not constant. or spaceId is not number. or threadCategoryId is not number. or operationUserId is not number.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     * @return    boolean       TRUE:It has the access control.     FALSE:It doesn't have the access control.
     */
    public function hasThreadCategoryAccessControl(
        $authorityCode,
        $spaceId,
        $threadCategoryId,
        $operationUserId
    ) {
        //input check
        ValidateUtility::isIn($authorityCode
            , [
                Authority::AUTHORITY_CODE_READ_SUMMARY
                ,
                Authority::AUTHORITY_CODE_READ_DETAIL
                ,
                Authority::AUTHORITY_CODE_WRITE
                ,
                Authority::AUTHORITY_CODE_SYSTEM_PRIVILEGE
                ,
                Authority::AUTHORITY_CODE_OPERATION_PRIVILEGE
            ]
            , ValidateUtility::DISABLE_EMPTY);
        ValidateUtility::isNumber($spaceId);
        ValidateUtility::isNumber($threadCategoryId);
        ValidateUtility::isNumber($operationUserId);

        if ($this->_hasRelationSpaceThreadCategory($spaceId, $threadCategoryId)
            === false
        ) {
            return false;
        }

        $spaceAclLogic = SpaceAccessControlListLogic::getInstance();
        $hasSpaceAccessControl
            = $spaceAclLogic->hasSpaceAccessControl($authorityCode,
            $spaceId, $operationUserId);

        if ($hasSpaceAccessControl === false) {
            if (($authorityCode == Authority::AUTHORITY_CODE_READ_DETAIL)
                || ($authorityCode
                    == Authority::AUTHORITY_CODE_SYSTEM_PRIVILEGE)
            ) {
                $hasSpaceAccessControl
                    = $this->_isSpaceAdministrator($operationUserId);
            }
        }

        //今後カテゴリにアクセス権が含まれた場合は、
        //ここで、スペースカテゴリ、スペース、スレッドカテゴリの各アクセス権を個別にチェック後に、
        //それぞれのアクセス権の論理積の結果を返す。

        return $hasSpaceAccessControl;
    }


    /**
     * As for target THREAD, is access control possible on the condition of arguments?
     *
     * @param     string $authorityCode   The constant has been defined in Authority class
     * @param     string $spaceId         space sequence id
     * @param     string $threadId        thread sequence id
     * @param     string $operationUserId user sequence id
     *
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       authorityCode is not constant. or spaceId is not number. or threadId is not number. or operationUserId is not number.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     * @return    boolean       TRUE:It has the access control.     FALSE:It doesn't have the access control.
     */
    public function hasThreadAccessControl(
        $authorityCode,
        $spaceId,
        $threadId,
        $operationUserId
    ) {
        //input check
        ValidateUtility::isIn($authorityCode
            , [
                Authority::AUTHORITY_CODE_READ_SUMMARY
                ,
                Authority::AUTHORITY_CODE_READ_DETAIL
                ,
                Authority::AUTHORITY_CODE_WRITE
                ,
                Authority::AUTHORITY_CODE_SYSTEM_PRIVILEGE
                ,
                Authority::AUTHORITY_CODE_OPERATION_PRIVILEGE
            ]
            , ValidateUtility::DISABLE_EMPTY);
        ValidateUtility::isNumber($spaceId);
        ValidateUtility::isNumber($threadId);
        ValidateUtility::isNumber($operationUserId);

        if ($this->_hasRelationSpaceThread($spaceId, $threadId) === false) {
            return false;
        }

        $spaceAclLogic = SpaceAccessControlListLogic::getInstance();
        $hasSpaceAccessControl
            = $spaceAclLogic->hasSpaceAccessControl($authorityCode,
            $spaceId, $operationUserId);

        if ($hasSpaceAccessControl === false) {
            if (($authorityCode == Authority::AUTHORITY_CODE_READ_DETAIL)
                || ($authorityCode
                    == Authority::AUTHORITY_CODE_SYSTEM_PRIVILEGE)
            ) {
                $hasSpaceAccessControl
                    = $this->_isSpaceAdministrator($operationUserId);
            }
        }

        //今後カテゴリにアクセス権が含まれた場合は、
        //ここで、スペースカテゴリ、スペース、スレッドカテゴリ、スレッド(登録者か？くらいだが必要かどうか要確認)の各アクセス権を個別にチェック後に、
        //それぞれのアクセス権の論理積の結果を返す。

        return $hasSpaceAccessControl;
    }


    /**
     * As for target COMMENT, is access control possible on the condition of arguments?
     *
     * @param     string $authorityCode   The constant has been defined in Authority class
     * @param     string $spaceId         space sequence id
     * @param     string $threadId        thread sequence id
     * @param     string $commentId       comment sequence id
     * @param     string $operationUserId user sequence id
     *
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       authorityCode is not constant. or spaceId is not number. or threadId is not number. or commentId is not number. or operationUserId is not number.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     * @return    boolean       TRUE:It has the access control.     FALSE:It doesn't have the access control.
     */
    public function hasThreadCommentAccessControl(
        $authorityCode,
        $spaceId,
        $threadId,
        $commentId,
        $operationUserId
    ) {
        //input check
        ValidateUtility::isIn($authorityCode
            , [
                Authority::AUTHORITY_CODE_READ_SUMMARY
                ,
                Authority::AUTHORITY_CODE_READ_DETAIL
                ,
                Authority::AUTHORITY_CODE_WRITE
                ,
                Authority::AUTHORITY_CODE_SYSTEM_PRIVILEGE
                ,
                Authority::AUTHORITY_CODE_OPERATION_PRIVILEGE
            ]
            , ValidateUtility::DISABLE_EMPTY);
        ValidateUtility::isNumber($spaceId);
        ValidateUtility::isNumber($threadId);
        ValidateUtility::isNumber($commentId);
        ValidateUtility::isNumber($operationUserId);

        if ($this->_hasRelationSpaceThreadComment($spaceId, $threadId,
                $commentId) === false
        ) {
            return false;
        }

        //コメントの仕様は「閲覧権限があれば書込が可能」。
        //この仕様を実現するために、以下の制御を行っている。
        //READ権限チェック時    閲覧、登録が出来る
        //WRITE権限チェック時   自分が登録したものだけが削除が出来る
        $spaceAuthorityCode = ($authorityCode
                               == Authority::AUTHORITY_CODE_WRITE)
            ? Authority::AUTHORITY_CODE_READ_DETAIL : $authorityCode;
        $spaceAclLogic = SpaceAccessControlListLogic::getInstance();
        $hasSpaceAccessControl
            = $spaceAclLogic->hasSpaceAccessControl($spaceAuthorityCode,
            $spaceId, $operationUserId);

        if ($hasSpaceAccessControl === false) {
            if (($spaceAuthorityCode == Authority::AUTHORITY_CODE_READ_DETAIL)
                || ($spaceAuthorityCode
                    == Authority::AUTHORITY_CODE_SYSTEM_PRIVILEGE)
            ) {
                $hasSpaceAccessControl
                    = $this->_isSpaceAdministrator($operationUserId);
            }
        }

        //今後カテゴリにアクセス権が含まれた場合は、
        //ここで、スペースカテゴリ、スペース、スレッドカテゴリの各アクセス権を個別にチェック後に、
        //それぞれのアクセス権の論理積の結果を返す。


        //引数が書込の場合、登録者でない時は無効
        if ((Authority::AUTHORITY_CODE_WRITE == $authorityCode)
            && $hasSpaceAccessControl
        ) {
            //対象コメントを取得
            try {
                $commentLogic = CommentLogic::getInstance();
                $comment = $commentLogic->getComment($commentId);

                if ($comment->getCreatorId() != $operationUserId) {
                    $hasSpaceAccessControl = false;
                }
            } catch (GrnDataNotFoundException $e) {
                $hasSpaceAccessControl = false;
            }
        }

        return $hasSpaceAccessControl;
    }





    //****************************************************************************************************************
    //**********************************             other              **********************************************
    //****************************************************************************************************************
    /**
     * * * * * * * * * * * *
     * Non-recommendation(非推奨)
     *
     * A new program is not recommended to be made by using this method.
     * * * * * * * * * * * *
     *
     * Searches for the thread, and thread comment.
     *
     * TRHEAD that exceeds SPACE cannot be retrieved.
     *
     * @param     string                                                          $authorityCode   The constant has been defined in Authority class
     * @param     \grn\space\data\condition\SynthesisThreadCommentSearchCondition $searchCondition SynthesisThreadCommentSearchCondition
     * @param     string                                                          $operationUserId user sequence id
     *
     * @throws    \grn\space\common\exception\GrnRequiredDataIsNotException     There is no information necessary for searchCondition.
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       authorityCode not a constant. or operationUserId is not number.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     * @return    SynthesisThreadCommentCollection
     */
    public function searchSynthesisThreadCommentBySearchConditionWithAccessControl(
        $authorityCode,
        SynthesisThreadCommentSearchCondition $searchCondition,
        $operationUserId
    ) {
        //input data check
        ValidateUtility::isIn($authorityCode
            , [
                Authority::AUTHORITY_CODE_READ_SUMMARY
                ,
                Authority::AUTHORITY_CODE_READ_DETAIL
                ,
                Authority::AUTHORITY_CODE_WRITE
                ,
                Authority::AUTHORITY_CODE_SYSTEM_PRIVILEGE
                ,
                Authority::AUTHORITY_CODE_OPERATION_PRIVILEGE
            ]
            , ValidateUtility::DISABLE_EMPTY);
        $searchCondition->isValidData(ThreadSearchCondition::VALID_TYPE_SELECT);
        ValidateUtility::isNumber($operationUserId);

        $spaceLogic = SpaceLogic::getInstance();
        $space
            = $spaceLogic->getSpaceByApplicationCategoryId($searchCondition->getSearchCategoryId(),
            LanguageStatus::STANDARD_LANGUAGE_CODE);
        $spaceAclLogic = SpaceAccessControlListLogic::getInstance();
        $hasSpaceAccessControl
            = $spaceAclLogic->hasSpaceAccessControl($authorityCode,
            $space->getId(), $operationUserId);

        if ($hasSpaceAccessControl === false) {
            if (($authorityCode == Authority::AUTHORITY_CODE_READ_DETAIL)
                || ($authorityCode
                    == Authority::AUTHORITY_CODE_SYSTEM_PRIVILEGE)
            ) {
                $hasSpaceAccessControl
                    = $this->_isSpaceAdministrator($operationUserId);
            }
        }

        if ($hasSpaceAccessControl) {
            $threadLogic = ThreadLogic::getInstance();
            $resultSynthesisThreadCommentCollection
                = $threadLogic->searchSynthesisThreadComment($searchCondition);

            /** @var \grn\space\data\bean\SynthesisThreadComment $synthesisThreadComment */
            //Array with SpaceFileCollection of each threadId
            if (count($resultSynthesisThreadCommentCollection) > 0) {
                $fileLogic = SpaceFileLogic::getInstance();
                $fileCollectionArray
                    = $fileLogic->getSpaceFileCollectionsArrayBySynthesisThreadCommentCollection($resultSynthesisThreadCommentCollection);

                //set fileCollection
                foreach ($fileCollectionArray as $threadId => $fileCollection) {
                    foreach (
                        $resultSynthesisThreadCommentCollection as
                        $synthesisThreadComment
                    ) {
                        if ($synthesisThreadComment->getId() == $threadId) {
                            $synthesisThreadComment->setSpaceFileCollection($fileCollection);
                        }
                    }
                }
            }

            //read process
            if (count($resultSynthesisThreadCommentCollection) > 0) {
                $threadCollection = new ThreadCollection();
                $commentCollection = new CommentCollection();

                foreach (
                    $resultSynthesisThreadCommentCollection as
                    $synthesisThreadComment
                ) {
                    if (SynthesisThreadComment::OBJECT_TYPE_COMMENT
                        == $synthesisThreadComment->getObjectType()
                    ) {
                        $comment = new Comment();
                        $comment->setId($synthesisThreadComment->getCommentId());
                        $commentCollection->appendBean($comment);
                    } else {
                        $thread = new Thread();
                        $thread->setId($synthesisThreadComment->getId());
                        $threadCollection->appendBean($thread);
                    }
                }

                //thread-read process
                if (count($threadCollection) > 0) {
                    $resultThreadReadStatusCollection
                        = $threadLogic->getThreadReadStatusCollection($threadCollection,
                        $operationUserId);
                    /** @var \grn\space\data\bean\ThreadReadStatus $threadReadStatus */
                    foreach (
                        $resultThreadReadStatusCollection as $threadReadStatus
                    ) {
                        foreach (
                            $resultSynthesisThreadCommentCollection as
                            $synthesisThreadComment
                        ) {
                            if (SynthesisThreadComment::OBJECT_TYPE_THREAD
                                == $synthesisThreadComment->getObjectType()
                                && $threadReadStatus->getThreadId()
                                   == $synthesisThreadComment->getId()
                            ) {
                                $synthesisThreadComment->setUnRead(false);
                                continue 2;
                            }
                        }
                    }
                }

                //comment-read process
                if (count($commentCollection) > 0) {
                    $commentLogic = CommentLogic::getInstance();
                    $resultCommentReadStatusCollection
                        = $commentLogic->getCommentReadStatusCollection($commentCollection,
                        $operationUserId);
                    /** @var \grn\space\common\data\bean\CommentReadStatus $commentReadStatus */
                    foreach (
                        $resultCommentReadStatusCollection as $commentReadStatus
                    ) {
                        foreach (
                            $resultSynthesisThreadCommentCollection as
                            $synthesisThreadComment
                        ) {
                            if (SynthesisThreadComment::OBJECT_TYPE_COMMENT
                                == $synthesisThreadComment->getObjectType()
                                && $commentReadStatus->getCommentId()
                                   == $synthesisThreadComment->getCommentId()
                            ) {
                                $synthesisThreadComment->setUnRead(false);
                                continue 2;
                            }
                        }
                    }
                }
            }
        } else {
            $resultSynthesisThreadCommentCollection
                = new SynthesisThreadCommentCollection();
        }

        return $resultSynthesisThreadCommentCollection;
    }



    //****************************************************************************************************************
    //**********************************            thread              **********************************************
    //****************************************************************************************************************
    /**
     * search THREAD by condition with access control
     *
     * TRHEAD that exceeds SPACE cannot be retrieved.
     *
     * @param     string                                          $authorityCode   The constant has been defined in Authority class
     * @param     \grn\space\data\condition\ThreadSearchCondition $searchCondition ThreadSearchCondition
     * @param     string                                          $operationUserId user sequence id
     *
     * @throws    \grn\space\common\exception\GrnRequiredDataIsNotException     There is no information necessary for searchCondition.
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       authorityCode not a constant. or operationUserId is not number.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     * @return    ThreadCollection
     */
    public function searchThreadBySearchConditionWithAccessControl(
        $authorityCode,
        ThreadSearchCondition $searchCondition,
        $operationUserId
    ) {
        //input data check
        ValidateUtility::isIn($authorityCode
            , [
                Authority::AUTHORITY_CODE_READ_SUMMARY
                ,
                Authority::AUTHORITY_CODE_READ_DETAIL
                ,
                Authority::AUTHORITY_CODE_WRITE
                ,
                Authority::AUTHORITY_CODE_SYSTEM_PRIVILEGE
                ,
                Authority::AUTHORITY_CODE_OPERATION_PRIVILEGE
            ]
            , ValidateUtility::DISABLE_EMPTY);
        ValidateUtility::isNumber($operationUserId);
        $searchCondition->isValidData(ThreadSearchCondition::VALID_TYPE_SELECT);

        $spaceLogic = SpaceLogic::getInstance();
        $space
            = $spaceLogic->getSpaceByApplicationCategoryId($searchCondition->getSearchCategoryId(),
            LanguageStatus::STANDARD_LANGUAGE_CODE);
        $spaceAclLogic = SpaceAccessControlListLogic::getInstance();
        $hasSpaceAccessControl
            = $spaceAclLogic->hasSpaceAccessControl($authorityCode,
            $space->getId(), $operationUserId);

        if ($hasSpaceAccessControl === false) {
            if (($authorityCode == Authority::AUTHORITY_CODE_READ_DETAIL)
                || ($authorityCode
                    == Authority::AUTHORITY_CODE_SYSTEM_PRIVILEGE)
            ) {
                $hasSpaceAccessControl
                    = $this->_isSpaceAdministrator($operationUserId);
            }
        }

        if ($hasSpaceAccessControl) {
            $threadLogic = ThreadLogic::getInstance();
            $resultThreadCollection
                = $threadLogic->searchThread($searchCondition);

            //read process
            if (count($resultThreadCollection) > 0) {
                $resultThreadReadStatusCollection
                    = $threadLogic->getThreadReadStatusCollection($resultThreadCollection,
                    $operationUserId);
                /** @var \grn\space\data\bean\ThreadReadStatus $threadReadStatus */
                foreach ($resultThreadReadStatusCollection as $threadReadStatus) {
                    /** @var \grn\space\data\bean\Thread $thread */
                    foreach ($resultThreadCollection as $thread) {
                        if ($threadReadStatus->getThreadId()
                            == $thread->getId()
                        ) {
                            $thread->setUnRead(false);
                            $thread->setUnreadUnder(false);
                            continue 2;
                        }
                    }
                }

                $resultThreadUnreadStatusCollection
                    = $threadLogic->getThreadUnreadStatusCollectionUnderThreThreads($resultThreadCollection,
                    $operationUserId);
                /** @var \grn\space\data\bean\ThreadUnreadStatus $threadUnreadStatus */
                foreach (
                    $resultThreadUnreadStatusCollection as $threadUnreadStatus
                ) {
                    foreach ($resultThreadCollection as $thread) {
                        if ($threadUnreadStatus->getThreadId()
                            == $thread->getId()
                        ) {
                            $thread->setUnreadUnder(true);
                            continue 2;
                        }
                    }
                }
            }
        } else {
            $resultThreadCollection = new ThreadCollection();
        }


        return $resultThreadCollection;
    }


    /**
     * Refer to the thread.
     *
     * Attention: Use the method of checking the authority because it doesn't check the authority internally beforehand.
     *
     * @param     string  $threadId          thread sequence id
     * @param     string  $operationUserId   user sequence id
     * @param     boolean $need_html_content TRUE: need html contnet, FALSE: don't need html content. This parameter is valid only when thread is a RichText.
     *
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       threadId is not number. or operationUserId is not number.
     * @throws    GrnDataNotFoundException          There is no thread.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     * @return    Thread        Thread(get thread object.)
     */
    public function getThread(
        $threadId,
        $operationUserId,
        $need_html_content = true
    ) {
        ValidateUtility::isNumber($threadId);
        ValidateUtility::isNumber($operationUserId);

        //スレッド参照
        $threadLogic = ThreadLogic::getInstance();
        $resultThread = $threadLogic->getThread($threadId, $need_html_content);

        //添付ファイル参照
        $searchCondition = new SpaceFileSearchCondition();
        $searchCondition->setSearchScopeType(SpaceFileSearchCondition::SEARCH_SCOPE_TYPE_THREAD);
        $searchCondition->setSearchScopeValue($resultThread->getId());
        $fileLogic = SpaceFileLogic::getInstance();
        $resultFileCollection
            = $fileLogic->getSpaceFileCollection($searchCondition);

        $resultThread->setSpaceFileCollection($resultFileCollection);

        //read process
        $threadCollection = new ThreadCollection();
        $threadCollection->appendBean($resultThread);
        $resultThreadReadStatusCollection
            = $threadLogic->getThreadReadStatusCollection($threadCollection,
            $operationUserId);
        $resultThread->setUnRead((count($resultThreadReadStatusCollection) > 0)
            ? false : true);

        return $resultThread;
    }

    /**
     * query whether a thread has any unread comments or not
     *
     * @param     string $threadId        thread sequence id
     * @param     string $operationUserId user sequence id
     *
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       threadId is not number. or operationUserId is not number.
     * @throws    GrnDataNotFoundException          There is no thread.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     * @return    boolean       true of false
     */
    public function isUnreadUnder($threadId, $operationUserId)
    {
        ValidateUtility::isNumber($threadId);
        ValidateUtility::isNumber($operationUserId);

        //スレッド参照
        $threadLogic = ThreadLogic::getInstance();
        $resultThread = $threadLogic->getThread($threadId);

        $threadCollection = new ThreadCollection();
        $threadCollection->appendBean($resultThread);
        $resultThreadReadStatusCollection
            = $threadLogic->getThreadReadStatusCollection($threadCollection,
            $operationUserId);
        $resultThread->setUnRead((count($resultThreadReadStatusCollection) > 0)
            ? false : true);

        $resultThreadUnreadStatusCollection
            = $threadLogic->getThreadUnreadStatusCollectionUnderThreThreads($threadCollection,
            $operationUserId);
        $resultThread->setUnreadUnder($resultThread->isUnread());
        if (count($resultThreadUnreadStatusCollection) > 0) {
            $resultThread->setUnreadUnder(true);
        }

        return $resultThread->isUnreadUnder();
    }

    /**
     * Refer to the thread.
     *
     * Attention: Use the method of checking the authority because it doesn't check the authority internally beforehand.
     *
     * @param     string $todoId          todo sequence id
     * @param     string $operationUserId user sequence id
     *
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       todoId is not number. or operationUserId is not number.
     * @throws    GrnDataNotFoundException          There is no thread.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     * @return    Thread(get thread object.)
     */
    public function getThreadByTodoId($todoId, $operationUserId)
    {
        ValidateUtility::isNumber($todoId);
        ValidateUtility::isNumber($operationUserId);

        //スレッド参照
        $threadLogic = ThreadLogic::getInstance();
        $resultThread = $threadLogic->getThreadByTodoId($todoId);

        //添付ファイル参照
        $searchCondition = new SpaceFileSearchCondition();
        $searchCondition->setSearchScopeType(SpaceFileSearchCondition::SEARCH_SCOPE_TYPE_THREAD);
        $searchCondition->setSearchScopeValue($resultThread->getId());
        $fileLogic = SpaceFileLogic::getInstance();
        $resultFileCollection
            = $fileLogic->getSpaceFileCollection($searchCondition);

        $resultThread->setSpaceFileCollection($resultFileCollection);

        //read process
        $threadCollection = new ThreadCollection();
        $threadCollection->appendBean($resultThread);
        $resultThreadReadStatusCollection
            = $threadLogic->getThreadReadStatusCollection($threadCollection,
            $operationUserId);
        $resultThread->setUnRead((count($resultThreadReadStatusCollection) > 0)
            ? false : true);

        return $resultThread;
    }


    /**
     * Create a thread
     *
     * Attention: Use the method of checking the authority because it doesn't check the authority internally beforehand.
     *
     * @param     \grn\space\data\bean\Thread $thread        Thread
     * @param     \CB_User                    $operationUser \CB_User
     * @param     array                       $fileArray     Optional    \GRN_File, or \GRN_ServerFile, or an element of $_FILES, or a path string of a file.
     *
     * @return    \grn\space\data\bean\Thread
     * @throws    \grn\space\common\exception\GrnRequiredDataIsNotException     There is no information necessary for thread.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     */
    public function createThread(
        Thread $thread,
        \CB_User $operationUser,
        array $fileArray = []
    ) {
        //input check
        $thread->isValidData(Thread::VALID_TYPE_CREATE);

        //Completion Information(情報の補完)
        $thread->setModifierId($thread->getCreatorId());
        $thread->setModifierName($thread->getCreatorName());

        $threadLogic = ThreadLogic::getInstance();
        $spaceLogic = SpaceLogic::getInstance();

        //create thread
        $resultThread = $threadLogic->createThread($thread);

        //get a space
        $space = $spaceLogic->getSpaceByThreadId($resultThread->getId(),
            LanguageStatus::STANDARD_LANGUAGE_CODE);

        //attached files
        $resultFileCollection = new SpaceFileCollection();
        $fileLogic = SpaceFileLogic::getInstance();
        foreach ($fileArray as $grnMixedFile) {
            $resultSpaceFile = $fileLogic->createSpaceFile($grnMixedFile,
                $operationUser);

            if (is_object($resultSpaceFile)) {
                //スレッドと添付ファイルの関連付けを登録
                $threadLogic->createThreadFileReletion($resultThread->getId(),
                    $resultSpaceFile->getId());
                $resultSpaceFile->setParentApplicationType(SpaceFile::PARENT_APPLICATION_TYPE_THREAD);
                $resultSpaceFile->setParentApplicationId($resultThread->getId());

                //Log CreateThreadFileLog
                $createThreadFileLog = new CreateThreadFileLog();
                $createThreadFileLog->setSpaceId($space->getId());
                $createThreadFileLog->setSpaceName($space->getSpaceName());
                $createThreadFileLog->setFileId($resultSpaceFile->getId());
                $createThreadFileLog->setFileName($resultSpaceFile->getGrnSpaceFileObject()
                                                                  ->getCurrentBody()
                                                                  ->get('name'));
                $createThreadFileLog->setThreadId($thread->getId());
                $createThreadFileLog->setThreadName($thread->getTitle());
                $this->getSpaceLogLogic()->info($createThreadFileLog);

                $resultFileCollection->appendBean($resultSpaceFile);
            }
        }
        $resultThread->setSpaceFileCollection($resultFileCollection);

        //space component modify timestamp update
        $space = $spaceLogic->modifySpaceComponentModifyTimestamp($space);

        //read process
        $threadLogic->createThreadReadStatus($thread->getId(),
            $operationUser->getOID());
        $resultThread->setUnRead(false);

        $spaceUserSearchCondition = new SpaceUserSearchCondition();
        $spaceUserSearchCondition->setSearchSpaceId($space->getId());
        $userCollection
            = $spaceLogic->searchSpaceUsers($spaceUserSearchCondition,
            $operationUser->getOID());
        $notification_user_ids
            = $spaceLogic->getSpaceUserMemberIds($userCollection,
            $space->getId());

        //通知処理
        $action = 'create';
        $notificationLogic = SpaceNotificationLogic::getInstance();
        $notificationLogic->sendThreadNotification($operationUser->getOID(),
            $action, $thread, $space, $notification_user_ids);

        // Log CreateThreadLog
        $createThreadLog = new CreateThreadLog();
        $createThreadLog->setSpaceId($space->getId());
        $createThreadLog->setSpaceName($space->getSpaceName());
        $createThreadLog->setThreadId($thread->getId());
        $createThreadLog->setThreadName($thread->getTitle());

        $folderId = $thread->getFolderId();

        if ($folderId > 0) {
            $folderLogic = new FolderLogic();

            $folder = $folderLogic->getFolder($folderId);

            if ($folder->getId() > 0) {
                $createThreadLog->setFolderId($folder->getId());
                $createThreadLog->setFolderName($folder->getFolderName());
            }
        }

        $this->getSpaceLogLogic()->info($createThreadLog);

        //Full Text Search
        if (FtsApplication::isAvailable()) {
            $searchService = new IndexService();
            $searchService->updateSpaceIndex($space, $operationUser->getOID());
            $searchService->createDiscussionIndex($space, $thread);
            foreach ($resultFileCollection as $spaceFile) {
                $searchService->createFileIndex($space, $spaceFile, $thread);
            }
        }

        return $resultThread;
    }


    /**
     * Modify the thread
     *
     * Attention: Use the method of checking the authority because it doesn't check the authority internally beforehand.
     *
     * @param     \grn\space\data\bean\Thread $thread    Thread
     * @param     \CB_User                    $operationUser
     * @param     array                       $fileArray Optional    \GRN_File, or \GRN_ServerFile, or an element of $_FILES, or a path string of a file.
     * @param     bool                        $sendNotification
     *
     * @throws    \grn\space\common\exception\GrnRequiredDataIsNotException         There is no information necessary for thread.
     * @throws    GrnDataNotFoundException              There is no thread.
     * @throws    \grn\space\common\exception\GrnDatabaseException                  Any error in the database.
     * @return    Thread(modified thread object.)
     */
    public function modifyThread(
        Thread $thread,
        \CB_User $operationUser,
        array $fileArray = [],
        $sendNotification = false
    ) {
        //input check
        $thread->isValidData(Thread::VALID_TYPE_MODIFY);

        //modifiy thread
        $threadLogic = ThreadLogic::getInstance();
        $resultThread = $threadLogic->modifyThread($thread);

        //This is for logging
        $spaceLogic = SpaceLogic::getInstance();
        $space = $spaceLogic->getSpaceByThreadId($thread->getId(),
            LanguageStatus::STANDARD_LANGUAGE_CODE);

        //### modifiy attached files ### start
        $searchCondition = new SpaceFileSearchCondition();
        $searchCondition->setSearchScopeType(SpaceFileSearchCondition::SEARCH_SCOPE_TYPE_THREAD);
        $searchCondition->setSearchScopeValue($resultThread->getId());
        $fileLogic = SpaceFileLogic::getInstance();

        //An unnecessary file is deleted.
        $beforeFileCollection
            = $fileLogic->getSpaceFileCollection($searchCondition);
        /** @var \grn\space\common\data\bean\SpaceFile $spaceFile */
        foreach ($beforeFileCollection as $spaceFile) {
            $key = $spaceFile->getId();
            if (array_key_exists($key, $fileArray)) {
                unset($fileArray[$key]);
            } else {
                //Create Log object
                $deleteThreadFileLog = new DeleteThreadFileLog();
                $deleteThreadFileLog->setFileId($spaceFile->getId());
                $deleteThreadFileLog->setFileName($spaceFile->getGrnSpaceFileObject()
                                                            ->getCurrentBody()
                                                            ->get('name'));
                $deleteThreadFileLog->setThreadId($thread->getId());
                $deleteThreadFileLog->setThreadName($thread->getTitle());
                $deleteThreadFileLog->setSpaceId($space->getId());
                $deleteThreadFileLog->setSpaceName($space->getSpaceName());

                //Delete the file actucally
                $fileLogic->deleteSpaceFile($spaceFile);

                //Write log
                $this->getSpaceLogLogic()->info($deleteThreadFileLog);
            }
        }

        //The file newly added is registered. 
        foreach ($fileArray as $grnMixedFile) {
            $resultSpaceFile = $fileLogic->createSpaceFile($grnMixedFile,
                $operationUser);

            //スレッド添付登録ログ出力　要確認::更新の場合は更新ログじゃないと駄目かも？
            //Log CreateThreadFileLog
            $createThreadFileLog = new CreateThreadFileLog();
            $createThreadFileLog->setFileId($resultSpaceFile->getid());
            $createThreadFileLog->setFileName($resultSpaceFile->getGrnSpaceFileObject()
                                                              ->getCurrentBody()
                                                              ->get('name'));
            $createThreadFileLog->setThreadId($thread->getId());
            $createThreadFileLog->setThreadName($thread->getTitle());
            $createThreadFileLog->setSpaceId($space->getId());
            $createThreadFileLog->setSpaceName($space->getSpaceName());
            $this->getSpaceLogLogic()->info($createThreadFileLog);

            if (is_object($resultSpaceFile)) {
                //スレッドと添付ファイルの関連付けを登録
                $threadLogic->createThreadFileReletion($resultThread->getId(),
                    $resultSpaceFile->getId());
            }
        }

        $afterFileCollection
            = $fileLogic->getSpaceFileCollection($searchCondition);
        $resultThread->setSpaceFileCollection($afterFileCollection);
        //### modifiy attached files ### end

        //space component modify timestamp update
        $space = $spaceLogic->modifySpaceComponentModifyTimestamp($space);

        //read process
        $threadLogic->deleteThreadReadStatusByThreadId($thread->getId());
        $threadLogic->createThreadReadStatus($thread->getId(),
            $operationUser->getOID());
        $resultThread->setUnRead(false);

        if ($sendNotification) {
            // Get Notification destination
            $spaceUserSearchCondition = new SpaceUserSearchCondition();
            $spaceUserSearchCondition->setSearchSpaceId($space->getId());
            $spaceUserSearchCondition->setOrderSortArray([SpaceUserSearchCondition::SORT_DISPLAY_ORDER_ASC]);
            $spaceUserCollection
                = $spaceLogic->searchSpaceUsers($spaceUserSearchCondition,
                $operationUser->getOID());
            $space_user_ids
                = $spaceLogic->getSpaceUserMemberIds($spaceUserCollection,
                $space->getId());
            $notification_user_ids
                = $threadLogic->getDiscussionNotificationUserCollection($space_user_ids,
                $resultThread->getId(), $operationUser->getOID());

            //通知処理
            $action = 'update';
            $notificationLogic = SpaceNotificationLogic::getInstance();
            $notificationLogic->sendThreadNotification($operationUser->getOID(),
                $action, $thread, $space, $notification_user_ids);
        }

        //スレッド更新ログ出力
        //Log ModifyThreadLog
        $modifyThreadLog = new ModifyThreadLog();
        $modifyThreadLog->setThreadId($thread->getId());
        $modifyThreadLog->setThreadName($thread->getTitle());
        $modifyThreadLog->setSpaceId($space->getId());
        $modifyThreadLog->setSpaceName($space->getSpaceName());
        $folderId = $thread->getFolderId();

        if ($folderId > 0) {
            $folderLogic = new FolderLogic();

            $folder = $folderLogic->getFolder($folderId);

            if ($folder->getId() > 0) {
                $modifyThreadLog->setFolderId($folder->getId());
                $modifyThreadLog->setFolderName($folder->getFolderName());
            }
        }
        $modifyThreadLog->setNotifyCheck($sendNotification ? "ON" : "OFF");

        $this->getSpaceLogLogic()->info($modifyThreadLog);

        //Full Text Search
        if (FtsApplication::isAvailable()) {
            $searchService = new IndexService();
            $searchService->updateSpaceIndex($space, $operationUser->getOID());
            $searchService->updateDiscussionIndex($space, $thread);
            foreach ($afterFileCollection as $spaceFile) {
                $searchService->createFileIndex($space, $spaceFile, $thread);
            }
        }

        return $resultThread;
    }


    /**
     * Delete the thread
     *
     * Attention: Use the method of checking the authority because it doesn't check the authority internally beforehand.
     *
     * @param     string $threadId        thread sequence id
     * @param     string $operationUserId user sequence id
     *
     * @throws    GrnIllegalOperationException         The system thread cannot be deleted.
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       threadId is not number. or operationUserId is not number
     * @throws    GrnDataNotFoundException          There is no thread or commentSequenceNo.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     * @return    Thread(deleted thread object.)
     */
    public function deleteThread($threadId, $operationUserId)
    {
        //input check
        ValidateUtility::isNumber($threadId);
        ValidateUtility::isNumber($operationUserId);

        //make logics
        $threadLogic = ThreadLogic::getInstance();
        $todoLogic = TodoLogic::getInstance();
        $spaceLogic = SpaceLogic::getInstance();
        $spaceFileLogic = SpaceFileLogic::getInstance();
        $commentLogic = CommentLogic::getInstance();


        //削除対象スレッドを取得
        $thread = $threadLogic->getThread($threadId);

        if ($thread->isSystemUse()) {
            throw new GrnIllegalOperationException(ErrorCode::GRN_THREAD_NO_DELETE_THREAD);
        }

        //This is for logging
        $space = $spaceLogic->getSpaceByThreadId($thread->getId(),
            LanguageStatus::STANDARD_LANGUAGE_CODE);

        $this->delAllFavourInDiscussion([$threadId]);
        //Delete all the files on this Thread and on the Comments and the Todos which are related to the Thread.
        $searchCondition = new SpaceFileSearchCondition();
        $searchCondition->setSearchScopeType(SpaceFileSearchCondition::SEARCH_SCOPE_TYPE_THREAD_ALL);
        $searchCondition->setSearchScopeValue($threadId);
        $resultFileCollection
            = $spaceFileLogic->getSpaceFileCollection($searchCondition);
        foreach ($resultFileCollection as $spaceFile) {
            //If you want to write logs marking that the files related to the thread/todo/comment are also removed,
            //you need to write the logic here.
            //But at now, such a log is not required.
            $spaceFileLogic->deleteSpaceFile($spaceFile);
        }

        //Delete Comments attached to Thread and Todo.
        $commentLogic->deleteThreadCommentByThreadId([$thread->getId()]);
        $commentLogic->deleteTodoCommentByThreadId([$thread->getId()]);

        //Delete Todos
        $todoLogic->deleteTodoByThreadId([$thread->getId()]);

        //Delete Thread and CommentSequenceNo
        $resultThread = $threadLogic->deleteThread($thread);

        //通知処理

        //スレッド削除ログ出力
        //Log DeleteThreadLog
        $deleteThreadLog = new DeleteThreadLog();
        $deleteThreadLog->setSpaceId($space->getId());
        $deleteThreadLog->setSpaceName($space->getSpaceName());
        $deleteThreadLog->setThreadId($thread->getId());
        $deleteThreadLog->setThreadName($thread->getTitle());
        $this->getSpaceLogLogic()->info($deleteThreadLog);

        //Full Text Search
        if (FtsApplication::isAvailable()) {
            $searchService = new IndexService();
            $searchService->deleteIndexByDiscussionId($threadId);
        }

        return $resultThread;
    }

    /**
     * Register to the read thread.
     *
     * Attention: Use the method of checking the authority because it doesn't check the authority internally beforehand.
     *
     * @param     string $threadId        thread sequence id
     * @param     string $operationUserId user sequence id
     *
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       threadId is not number. or operationUserId is not number.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     */
    public function registerReadThread($threadId, $operationUserId)
    {
        ValidateUtility::isNumber($threadId, ValidateUtility::DISABLE_EMPTY);
        ValidateUtility::isNumber($operationUserId,
            ValidateUtility::DISABLE_EMPTY);

        //スレッド既読処理
        $threadLogic = ThreadLogic::getInstance();
        $threadLogic->createOrModifyThreadReadStatus($threadId,
            $operationUserId);
    }

    //****************************************************************************************************************
    //**********************************            comment             **********************************************
    //****************************************************************************************************************
    /**
     * Create a thread comment.
     *
     * Attention: Use the method of checking the authority because it doesn't check the authority internally beforehand.
     *
     * @param     \grn\space\common\data\bean\Comment $comment
     * @param     string                              $threadId  Relationship thread sequence id
     * @param     \CB_User                            $operationUser
     * @param     array                               $fileArray Optional    \GRN_File, or \GRN_ServerFile, or an element of $_FILES, or a path string of a file.
     *
     * @throws    \grn\space\common\exception\GrnRequiredDataIsNotException     There is no information necessary for comment.
     * @throws    GrnInvalidArgumentException       threadId is not number
     * @throws    GrnDataNotFoundException          When the specified Space or Thread or ParentComment is not found.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     * @return    Comment(Added comment object.)
     */
    public function createThreadComment(
        Comment $comment,
        $threadId,
        \CB_User $operationUser,
        array $fileArray = []
    ) {
        //input check
        if (count($fileArray) == 0
            && ValidateUtility::isNull($comment->getContent())
        ) {
            throw new GrnInvalidArgumentException();
        }
        ValidateUtility::isNumber($threadId);

        $threadLogic = ThreadLogic::getInstance();
        $spaceLogic = SpaceLogic::getInstance();

        //#####   Completion Information(情報の補完)  ##### start
        $thread = $threadLogic->getThread($threadId);
        $commentLogic = CommentLogic::getInstance();
        $newCommentNo
            = $commentLogic->incrementCommentSequenceNo($thread->getCommentSequenceNoId());
        $comment->setCommentNo($newCommentNo->getLastNo());

        $comment->setModifierId($comment->getCreatorId());
        $comment->setModifierName($comment->getCreatorName());
        //#####   Completion Information(情報の補完)  ##### end

        // This object is used for logging 
        $space = $spaceLogic->getSpaceByThreadId($thread->getId(),
            LanguageStatus::STANDARD_LANGUAGE_CODE);

        //create comment
        $resultComment = $this->createComment($comment,
            $operationUser->getOID());

        //attached files
        $resultFileCollection = new SpaceFileCollection();
        $fileLogic = SpaceFileLogic::getInstance();
        $commentLogic = CommentLogic::getInstance();
        foreach ($fileArray as $grnMixedFile) {
            $resultSpaceFile = $fileLogic->createSpaceFile($grnMixedFile,
                $operationUser);

            if (is_object($resultSpaceFile)) {
                //コメントと添付ファイルの関連付けを登録
                $commentLogic->createCommentFileReletion($resultComment->getId(),
                    $resultSpaceFile->getId());
                $resultSpaceFile->setParentApplicationType(SpaceFile::PARENT_APPLICATION_TYPE_THREAD_COMMENT);
                $resultSpaceFile->setParentApplicationId($resultComment->getId());

                //スレッドコメント添付登録ログ出力
                //Log CreateThreadFollowFileLog
                $createThreadFollowFileLog = new CreateThreadFollowFileLog();
                $createThreadFollowFileLog->setSpaceId($space->getId());
                $createThreadFollowFileLog->setSpaceName($space->getSpaceName());
                $createThreadFollowFileLog->setThreadId($thread->getId());
                $createThreadFollowFileLog->setThreadName($thread->getTitle());
                $createThreadFollowFileLog->setFollowId($resultComment->getId());
                $createThreadFollowFileLog->setFileId($resultSpaceFile->getId());
                $createThreadFollowFileLog->setFileName($resultSpaceFile->getGrnSpaceFileObject()
                                                                        ->getCurrentBody()
                                                                        ->get('name'));
                $this->getSpaceLogLogic()->info($createThreadFollowFileLog);

                $resultFileCollection->appendBean($resultSpaceFile);
            }
        }
        $resultComment->setSpaceFileCollection($resultFileCollection);

        //スレッドとコメントの関連付けを登録
        $threadLogic->createThreadCommentReletion($threadId,
            $resultComment->getId());

        //space and thread component modify timestamp update
        $space = $spaceLogic->modifySpaceComponentModifyTimestamp($space);
        $thread = $threadLogic->modifyThreadComponentModifyTimestamp($thread);

        //通知先取得
        $categorized_ntf_users
            = $this->getDiscussionCategorizedNotificationUsers(
            $space->getId(), $threadId, $operationUser->getOID(),
            $comment->getMention()->getUserIds());

        //通知処理
        $action = 'update';
        $notificationLogic = SpaceNotificationLogic::getInstance();
        $notificationLogic->sendThreadNotification($operationUser->getOID(),
            $action, $thread, $space,
            $categorized_ntf_users->getAll(), $comment,
            $categorized_ntf_users->getToMe());

        //ログ出力
        //Log CreateThreadFollowLog
        $createThreadFollowLog = new CreateThreadFollowLog();
        $createThreadFollowLog->setFollowId($resultComment->getId());
        $createThreadFollowLog->setSpaceId($space->getId());
        $createThreadFollowLog->setSpacename($space->getSpaceName());
        $createThreadFollowLog->setThreadId($thread->getId());
        $createThreadFollowLog->setThreadName($thread->getTitle());
        $this->getSpaceLogLogic()->info($createThreadFollowLog);

        //Full Text Search
        if (FtsApplication::isAvailable()) {
            $searchService = new IndexService();
            $searchService->updateSpaceIndex($space, $operationUser->getOID());
            $searchService->updateDiscussionIndex($space, $thread);
            $searchService->createDiscussionCommentIndex($space, $thread,
                $resultComment);
            foreach ($resultFileCollection as $spaceFile) {
                $searchService->createFileIndex($space, $spaceFile, $thread,
                    null, $comment);
            }
        }

        return $resultComment;
    }

    /**
     * Delete the thread comment.
     *
     * Attention: Use the method of checking the authority because it doesn't check the authority internally beforehand.
     *
     * @param     string                                  $commentId comment sequence id
     * @param     string                                  $threadId  thread sequence id
     * @param     \grn\space\common\data\bean\SpaceMember $operationUser
     *
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       commentId is not number. or threadId is not number.
     * @throws    GrnDataNotFoundException          There is no commnent.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     * @return    Comment(deleted comment object.)
     */
    public function deleteThreadComment(
        $commentId,
        $threadId,
        SpaceMember $operationUser
    ) {
        //input check
        ValidateUtility::isNumber($commentId);
        ValidateUtility::isNumber($threadId);

        //This is for logging
        $spaceLogic = SpaceLogic::getInstance();
        $threadLogic = ThreadLogic::getInstance();
        $space = $spaceLogic->getSpaceByThreadId($threadId,
            LanguageStatus::STANDARD_LANGUAGE_CODE);
        $thread = $threadLogic->getThread($threadId);

        $this->delFavourInComment([$commentId]);
        //スレッドコメント添付ファイル削除
        $searchCondition = new SpaceFileSearchCondition();
        $searchCondition->setSearchScopeType(SpaceFileSearchCondition::SEARCH_SCOPE_TYPE_COMMENT);
        $searchCondition->setSearchScopeValue($commentId);
        $fileLogic = SpaceFileLogic::getInstance();
        $resultFileCollection
            = $fileLogic->getSpaceFileCollection($searchCondition);
        foreach ($resultFileCollection as $spaceFile) {
            //スレッドコメント添付ファイル削除ログ出力
            //If you want to write logs marking that the files related to this comment are also removed,
            //you need to write the logic here.
            //But at now, such a log is not required.

            $fileLogic->deleteSpaceFile($spaceFile);
        }

        //delete comment
        $resultComment = $this->deleteComment($commentId, $operationUser);

        //通知処理（スレッドの通知設定者が対象）

        //コメント削除ログ出力
        //Log DeleteThreadCommentLog
        $deleteThreadCommentLog = new DeleteThreadFollowLog();
        $deleteThreadCommentLog->setFollowId($commentId);
        $deleteThreadCommentLog->setSpaceId($space->getId());
        $deleteThreadCommentLog->setSpaceName($space->getSpaceName());
        $deleteThreadCommentLog->setThreadId($threadId);
        $deleteThreadCommentLog->setThreadName($thread->getTitle());
        $this->getSpaceLogLogic()->info($deleteThreadCommentLog);

        //Full Text Search
        if (FtsApplication::isAvailable()) {
            $searchService = new IndexService();
            $searchService->deleteIndexByCommentId($commentId);
        }

        return $resultComment;
    }

    /**
     * The number of comments that are newer than the condition of specifying it by the argument is counted.
     *
     * Attention: Use the method of checking the authority because it doesn't check the authority internally beforehand.
     *
     * @param string $commentNo       comment number
     * @param string $threadId        thread sequence id
     * @param string $operationUserId user sequence id
     *
     * @throws \grn\space\common\exception\GrnInvalidArgumentException  threadId is not number. or commentNo is not number. or operationUserId is not number
     * @throws \grn\space\common\exception\GrnDatabaseException         Any error in the database.
     * @return number of newer comments
     */
    public function getNewerComments($commentNo, $threadId, $operationUserId)
    {
        //input check
        ValidateUtility::isNumber($commentNo);
        ValidateUtility::isNumber($threadId);
        ValidateUtility::isNumber($operationUserId);

        $commentLogic = CommentLogic::getInstance();
        $resultCountNeverComments
            = $commentLogic->countNewerCommentsOfThreadAndTodo($commentNo,
            $threadId);

        return $resultCountNeverComments;
    }

    /**
     * Retrieve the last comment number of the thread
     *
     * Attention: Use the method of checking the authority because it doesn't check the authority internally beforehand.
     *
     * @param string $threadId        thread sequence id
     * @param string $operationUserId user sequence id
     *
     * @throws \grn\space\common\exception\GrnInvalidArgumentException  threadId is not number. or commentId is not number. or operationUserId is not number
     * @throws \grn\space\common\exception\GrnDatabaseException         Any error in the database.
     * @return int    last comment number of the thread
     */
    public function getLastCommentNo($threadId, $operationUserId)
    {
        //input check
        ValidateUtility::isNumber($threadId);
        ValidateUtility::isNumber($operationUserId);

        $threadLogic = ThreadLogic::getInstance();
        $thread = $threadLogic->getThread($threadId);
        $commentLogic = CommentLogic::getInstance();
        $commentNo
            = $commentLogic->getCommentSequenceNo($thread->getCommentSequenceNoId());

        return $commentNo->getLastNo();
    }




    //***************************************************************************************************************
    //**********************************           space file             *******************************************
    //***************************************************************************************************************
    /**
     * Get all THREAD-SPACE_FILE with read authority
     *
     * SPACE-FILE that exceeds SPACE cannot be retrieved.
     *
     * @param     string $threadId        thread sequence id
     * @param     string $operationUserId user sequence id
     *
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       threadId is not number. or operationUserId is not number.
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     * @return    SpaceFileCollection
     */
    public function getAllThreadFileWithReadAuthority(
        $threadId,
        $operationUserId
    ) {
        //input data check
        ValidateUtility::isNumber($threadId);
        ValidateUtility::isNumber($operationUserId);


        $spaceLogic = SpaceLogic::getInstance();
        $space = $spaceLogic->getSpaceByThreadId($threadId,
            LanguageStatus::STANDARD_LANGUAGE_CODE);
        $spaceAclLogic = SpaceAccessControlListLogic::getInstance();
        $hasSpaceAccessControl
            = $spaceAclLogic->hasSpaceAccessControl(Authority::AUTHORITY_CODE_READ_DETAIL,
            $space->getId(), $operationUserId);

        if ($hasSpaceAccessControl === false) {
            $hasSpaceAccessControl
                = $this->_isSpaceAdministrator($operationUserId);
        }

        //今後カテゴリやスレッドにアクセス権が含まれた場合は、アクセス権チェック処理を再考する必要がある
        if ($hasSpaceAccessControl) {
            $searchCondition = new SpaceFileSearchCondition();
            $searchCondition->setSearchScopeType(SpaceFileSearchCondition::SEARCH_SCOPE_TYPE_THREAD_ALL);
            $searchCondition->setSearchScopeValue($threadId);
            $searchCondition->setOrderSortArray([
                SpaceFileSearchCondition::SORT_MODIFY_TIME_DESC,
                SpaceFileSearchCondition::SORT_ID_ASC
            ]);

            $fileLogic = SpaceFileLogic::getInstance();
            $resultFileCollection
                = $fileLogic->getSpaceFileCollection($searchCondition);
        } else {
            $resultFileCollection = new SpaceFileCollection();
        }

        return $resultFileCollection;
    }

    /**
     * Delete the thread file
     *
     * Attention: Use the method of checking the authority because it doesn't check the authority internally beforehand.
     *
     * @param     string   $threadId thread sequence id
     * @param     string   $fileId   file sequence id
     * @param     \CB_User $operationUser
     *
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       threadId is not number. or fileId is not number
     * @throws    GrnDataNotFoundException          There is no thread. or There is no space-file
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     */
    public function deleteThreadFile(
        $threadId,
        $fileId,
        \CB_User $operationUser
    ) {
        //input check
        ValidateUtility::isNumber($threadId);
        ValidateUtility::isNumber($fileId);


        //スペースファイルを取得
        $fileLogic = SpaceFileLogic::getInstance();
        $spaceFile = $fileLogic->getSpaceFile($fileId);

        //対象スレッドを取得
        $threadLogic = ThreadLogic::getInstance();
        $thread = $threadLogic->getThread($threadId);

        //Completion Information(情報の補完)
        $thread->setModifierId($operationUser->getOID());
        $thread->setModifierName($operationUser->get('display_name'));

        //対象スレッドを更新
        $threadLogic = ThreadLogic::getInstance();
        $threadLogic->modifyThread($thread);

        //This is for logging
        $spaceLogic = SpaceLogic::getInstance();
        $space = $spaceLogic->getSpaceByThreadId($threadId,
            LanguageStatus::STANDARD_LANGUAGE_CODE);

        //Log DeleteThreadFileLog
        $deleteThreadFileLog = new DeleteThreadFileLog();
        $deleteThreadFileLog->setFileId($spaceFile->getId());
        $deleteThreadFileLog->setFileName($spaceFile->getGrnSpaceFileObject()
                                                    ->getCurrentBody()
                                                    ->get('name'));
        $deleteThreadFileLog->setSpaceId($space->getId());
        $deleteThreadFileLog->setSpaceName($space->getSpaceName());
        $deleteThreadFileLog->setThreadId($threadId);
        $deleteThreadFileLog->setThreadName($thread->getTitle());

        //スレッド添付ファイル削除
        $fileLogic->deleteSpaceFile($spaceFile);

        //Write log when all the logic finish successfully.
        $this->getSpaceLogLogic()->info($deleteThreadFileLog);
    }


    /**
     * Delete the comment file
     *
     * Attention: Use the method of checking the authority because it doesn't check the authority internally beforehand.
     *
     * @param     string $commentId comment sequence id
     * @param     string $fileId    file sequence id
     *
     * @throws    \grn\space\common\exception\GrnInvalidArgumentException       commentId is not number. or fileId is not number
     * @throws    GrnDataNotFoundException          There is no space-file
     * @throws    \grn\space\common\exception\GrnDatabaseException              Any error in the database.
     */
    public function deleteThreadCommentFile($commentId, $fileId)
    {
        //input check
        ValidateUtility::isNumber($commentId);
        ValidateUtility::isNumber($fileId);

        //This is for logging
        $spaceLogic = SpaceLogic::getInstance();
        $threadLogic = ThreadLogic::getInstance();
        $thread = $threadLogic->getThreadByCommentId($commentId);
        $space = $spaceLogic->getSpaceByThreadId($thread->getId(),
            LanguageStatus::STANDARD_LANGUAGE_CODE);

        //スペースファイルを取得
        $fileLogic = SpaceFileLogic::getInstance();
        $spaceFile = $fileLogic->getSpaceFile($fileId);

        //Log DeleteThreadFollowFileLog
        $deleteThreadFollowFileLog = new DeleteThreadFollowFileLog();
        $deleteThreadFollowFileLog->setFileId($spaceFile->getId());
        $deleteThreadFollowFileLog->setFileName($spaceFile->getGrnSpaceFileObject()
                                                          ->getCurrentBody()
                                                          ->get('name'));
        $deleteThreadFollowFileLog->setFollowId($commentId);
        $deleteThreadFollowFileLog->setSpaceId($space->getId());
        $deleteThreadFollowFileLog->setSpaceName($space->getSpaceName());
        $deleteThreadFollowFileLog->setThreadId($thread->getId());
        $deleteThreadFollowFileLog->setThreadName($thread->getTitle());

        //コメント添付ファイル削除
        $fileLogic->deleteSpaceFile($spaceFile);

        //write log when all the logic finish successfully.
        $this->getSpaceLogLogic()->info($deleteThreadFollowFileLog);

    }

    /**
     * check whether the notification is confirmed.
     *
     * @param   string $userId
     * @param   string $threadId
     *
     * @return   boolean
     */
    public function isNotConfirmedDiscussionNotification($userId, $threadId)
    {
        return $this->isNotConfirmedNotification($userId,
            \GrnSpaceApplication::GRN_DISCUSSION_SUB_MODULE_ID, $threadId);
    }

    /**
     * confirm notification
     *
     * @param   string                             $userId
     * @param   \grn\space\data\bean\Thread|object $thread
     *
     */
    public function confirmDiscussionNotification($userId, Thread $thread)
    {
        $timestamp = new \CB_Timestamp();
        $timestamp->unix_ts = time();

        $sub_module_id = \GrnSpaceApplication::GRN_DISCUSSION_SUB_MODULE_ID;

        $spaceNotificationLogic = SpaceNotificationLogic::getInstance();
        $spaceNotificationLogic->confirmNotification($userId, $thread->getId(),
            $timestamp, $sub_module_id);
    }

    /**
     * Get all users who follow the specific discussion.
     *
     * @param  int     $spaceId
     * @param  int     $discussionId
     * @param  int     $operationUserId
     * @param  boolean $is_user_only
     *
     * @return \grn\space\data\collection\SpaceUserCollection
     * @throws \grn\space\common\exception\GrnInvalidArgumentException
     */
    public function getNotificationUserCollection(
        $spaceId,
        $discussionId,
        $operationUserId,
        $is_user_only = true
    ) {
        ValidateUtility::isNumber($spaceId);
        ValidateUtility::isNumber($discussionId);
        ValidateUtility::isNumber($operationUserId);

        $spaceUserSearchCondition = new SpaceUserSearchCondition();
        $spaceUserSearchCondition->setSearchSpaceId($spaceId);
        $spaceUserSearchCondition->setOrderSortArray([SpaceUserSearchCondition::SORT_DISPLAY_ORDER_ASC]);
        $spaceLogic = new SpaceLogic();
        $spaceUserCollection
            = $spaceLogic->searchSpaceUsers($spaceUserSearchCondition,
            $operationUserId);

        if ($is_user_only) {
            return $this->getNotificationUserCollectionByUserOnly($spaceUserCollection,
                $spaceId, $discussionId,
                $operationUserId);
        } else {
            return $this->getNotificationMemberCollection($spaceUserCollection,
                $spaceId, $discussionId);
        }
    }

    /**
     * @param SpaceUserCollection $spaceUserCollection
     * @param string              $spaceId
     * @param string              $discussionId
     * @param string              $operationUserId
     *
     * @return SpaceUserCollection
     */
    private function getNotificationUserCollectionByUserOnly(
        $spaceUserCollection,
        $spaceId,
        $discussionId,
        $operationUserId
    ) {
        $spaceLogic = new SpaceLogic();
        $space_user_ids
            = $spaceLogic->getSpaceUserMemberIds($spaceUserCollection,
            $spaceId);

        $discussionLogic = new ThreadLogic();
        $notification_user_ids
            = $discussionLogic->getDiscussionNotificationUserCollection($space_user_ids,
            $discussionId,
            $operationUserId);

        $result = new SpaceUserCollection();
        foreach ($notification_user_ids as $user_id) {
            $result->appendBean(new SpaceUser([
                SpaceUser::SPACE_ID => $spaceId,
                SpaceUser::USER     => $user_id
            ],
                SpaceUser::NOT_CHECK_INPUT));
        }

        return $result;
    }

    /**
     * @param SpaceUserCollection $spaceUserCollection
     * @param string              $spaceId
     * @param string              $discussionId
     *
     * @return SpaceUserCollection
     */
    private function getNotificationMemberCollection(
        $spaceUserCollection,
        $spaceId,
        $discussionId
    ) {
        $discussionLogic = new ThreadLogic();
        $notification_member_ids
            = $discussionLogic->getNotificationMemberCollection($spaceUserCollection,
            $discussionId);

        $result = new SpaceUserCollection();
        foreach ($notification_member_ids as $notification_member_id) {
            $member_info
                = SpaceMemberUtility::getPickoutMemberInfo($notification_member_id);
            $member_id = $member_info[MemberLogic::MEMBER_ID];
            $member_type = $member_info[MemberLogic::MEMBER_TYPE];
            switch ($member_type) {
                case MemberLogic::TYPE_USER:
                    $data_array = [
                        SpaceUser::SPACE_ID => $spaceId,
                        SpaceUser::USER     => $member_id
                    ];
                    break;
                case MemberLogic::TYPE_ORGANIZATION:
                    $data_array = [
                        SpaceUser::SPACE_ID => $spaceId,
                        SpaceUser::GROUP    => $member_id
                    ];
                    break;
                case MemberLogic::TYPE_STATIC_ROLE:
                    $data_array = [
                        SpaceUser::SPACE_ID => $spaceId,
                        SpaceUser::ROLE     => $member_id
                    ];
                    break;
            }
            $result->appendBean(new SpaceUser($data_array,
                SpaceUser::NOT_CHECK_INPUT));
        }

        return $result;
    }

    /**
     * Check whether user followed the specific discussion.
     *
     * @param  int $discussionId
     * @param  int $userId
     * @param  int $spaceId
     * @param  int $operationUserId
     *
     * @return boolean
     */
    public function isNotificationUser(
        $discussionId,
        $userId,
        $spaceId,
        $operationUserId
    ) {
        ValidateUtility::isNumber($discussionId);
        ValidateUtility::isNumber($userId);
        ValidateUtility::isNumber($spaceId);
        ValidateUtility::isNumber($operationUserId);

        $discussionLogic = ThreadLogic::getInstance();
        $non_notification
            = $discussionLogic->selectDiscussionNonNotification($discussionId,
            $userId);
        if ($non_notification->getUserId() == $userId) {
            return false;
        }

        $spaceUserSearchCondition = new SpaceUserSearchCondition();
        $spaceUserSearchCondition->setSearchSpaceId($spaceId);
        $spaceUserSearchCondition->setIsSearchUsersOnly(true);
        $spaceLogic = SpaceLogic::getInstance();
        $userCollection
            = $spaceLogic->searchSpaceUsers($spaceUserSearchCondition,
            $operationUserId);
        /** @var \grn\space\data\bean\SpaceUser $user */
        foreach ($userCollection as $user) {
            if ($user->getMemberID() == $userId) {
                return true;
            }
        }

        return false;
    }

    /**
     * Remove a user from notification user list
     *
     * @param int $discussionId
     * @param int $userId
     */
    public function removeNotificationUser($discussionId, $userId)
    {
        ValidateUtility::isNumber($discussionId);
        ValidateUtility::isNumber($userId);

        $discussionLogic = ThreadLogic::getInstance();
        $discussionLogic->insertOnDuplicateUpdateDiscussionNonNotification($discussionId,
            $userId);
    }

    /**
     * Add a user to notification user list
     *
     * @param int $discussionId
     * @param int $userId
     */
    public function addNotificationUser($discussionId, $userId)
    {
        ValidateUtility::isNumber($discussionId);
        ValidateUtility::isNumber($userId);

        $discussionLogic = ThreadLogic::getInstance();
        $discussionLogic->deleteDiscussionNonNotification($discussionId,
            $userId);
    }

    /**
     * @param int $spaceId
     *
     * @return array
     */
    public function getAllDiscussionIdBySpaceId($spaceId)
    {
        ValidateUtility::isNumber($spaceId);
        $logic = ThreadLogic::getInstance();

        return $logic->getAllDiscussionIdBySpaceId($spaceId);
    }

    /**
     * Delete favours in discussion,todo and comments in both.
     *
     * @param  array $discussionIds
     */
    public function delAllFavourInDiscussion(array $discussionIds)
    {
        $favourService = new FavourService();
        $favourService->deleteMultiFavour(\GrnSpaceApplication::GRN_SPACE_MODULE_ID,
            \GrnSpaceApplication::FAVOUR_DISCUSSION_BODY,
            $discussionIds,
            \GrnSpaceApplication::GRN_DISCUSSION_SUB_MODULE_ID);

        $logic = ThreadLogic::getInstance();
        $disCmtIds
            = $logic->getDiscussionCommentIdByDiscussionId($discussionIds);
        $this->delFavourInComment($disCmtIds);

        $todoService = TodoService::getInstance();
        $todoIds = $todoService->getTodoIdByDiscussionId($discussionIds);
        $todoService->delAllFavourInTodo($todoIds);
    }

    /**
     * Delete favour in comment.
     *
     * @param  array $commentIds
     */
    public function delFavourInComment(array $commentIds)
    {
        $favourService = new FavourService();
        $favourService->deleteMultiFavour(\GrnSpaceApplication::GRN_SPACE_MODULE_ID,
            \GrnSpaceApplication::FAVOUR_DISCUSSION_COMMENT,
            $commentIds,
            \GrnSpaceApplication::GRN_DISCUSSION_SUB_MODULE_ID);
    }

    /**
     * @param SpaceUserCollection $collection
     * @param int                 $discussionId
     *
     * @return SpaceUserCollection
     */
    private function addNonSpaceUserToNotify(
        SpaceUserCollection $collection,
        $discussionId
    ) {
        $nonSpaceUserIds
            = $this->getDiscussionNotificationUserId($discussionId);
        if (count($nonSpaceUserIds) > 0) {
            foreach ($nonSpaceUserIds as $id) {
                $spaceUser = new SpaceUser([SpaceUser::ID => $id]);
                $collection->appendBean($spaceUser);
            }
        }

        return $collection;
    }

    /**
     * @param int $discussionId
     * @param int $userId
     *
     * @return bool
     * @throws \grn\space\common\exception\GrnInvalidArgumentException
     */
    public function isDiscussionNotificationUser($discussionId, $userId)
    {
        ValidateUtility::isNumber($discussionId);
        ValidateUtility::isNumber($userId);
        $discussionLogic = ThreadLogic::getInstance();
        $notification
            = $discussionLogic->selectDiscussionNotification($discussionId,
            $userId);
        if ($notification->getUserId() == $userId) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * @param int $discussionId
     * @param int $userId
     *
     * @throws \grn\space\common\exception\GrnInvalidArgumentException
     */
    public function addDiscussionNotificationUser($discussionId, $userId)
    {
        ValidateUtility::isNumber($discussionId);
        ValidateUtility::isNumber($userId);
        $discussionLogic = ThreadLogic::getInstance();
        $discussionLogic->insertOnDuplicateUpdateDiscussionNotification($discussionId,
            $userId);
    }

    /**
     * @param int $discussionId
     * @param int $userId
     *
     * @throws \grn\space\common\exception\GrnInvalidArgumentException
     */
    public function deleteDiscussionNotificationUser($discussionId, $userId)
    {
        ValidateUtility::isNumber($discussionId);
        ValidateUtility::isNumber($userId);
        $discussionLogic = ThreadLogic::getInstance();
        $discussionLogic->deleteDiscussionNotification($discussionId, $userId);
    }

    /**
     * @param int $discussionId
     *
     * @return array
     * @throws \grn\space\common\exception\GrnInvalidArgumentException
     */
    public function getDiscussionNotificationUserId($discussionId)
    {
        ValidateUtility::isNumber($discussionId);
        $discussionLogic = ThreadLogic::getInstance();

        return $discussionLogic->getDiscussionNotificationUserId($discussionId);
    }

    /**
     * @param ThreadCollection $threadCollection
     * @param                  $source_space_id
     * @param Folder           $sourceFolder
     * @param                  $target_space_id
     * @param Folder           $targetFolder
     * @param bool             $sendNotification
     *
     * @throws \grn\space\common\exception\GrnArgumentOutOfRangeException
     * @throws \grn\space\common\exception\GrnInvalidArgumentException
     */
    public function moveThreadList(
        ThreadCollection $threadCollection,
        $source_space_id,
        Folder $sourceFolder,
        $target_space_id,
        Folder $targetFolder,
        $sendNotification = false
    ) {
        $login = cb_get_login_user();
        $loginId = $login->getOID();

        $spaceLogic = SpaceLogic::getInstance();
        $sourceSpace = $spaceLogic->getSpace($source_space_id,
            \CB_I18N::getInstance()->getCurrentLanguage());
        $targetSpace = $spaceLogic->getSpace($target_space_id,
            \CB_I18N::getInstance()->getCurrentLanguage());

        $todoService = TodoService::getInstance();
        $targetTodoRootCategory = $todoService->getApplicationRootCategory(
            $targetSpace->getId(), Application::APPLICATION_CODE_TODO,
            \CB_I18N::getInstance()->getCurrentLanguage()
        );

        $sourceSpaceUserCollection = new SpaceUserCollection();
        $targetSpaceUserCollection = new SpaceUserCollection();
        if ($source_space_id != $target_space_id) {
            $spaceUserSearchCondition = new SpaceUserSearchCondition();

            $spaceUserSearchCondition->setSearchSpaceId($sourceSpace->getId());
            $sourceSpaceUserCollection
                = $spaceLogic->searchSpaceUsers($spaceUserSearchCondition,
                $loginId);

            $spaceUserSearchCondition->setSearchSpaceId($targetSpace->getId());
            $targetSpaceUserCollection
                = $spaceLogic->searchSpaceUsers($spaceUserSearchCondition,
                $loginId);

            $this->_deleteRelatedDiscussionNotification(
                $threadCollection, $targetSpace, $sourceSpaceUserCollection,
                $targetSpaceUserCollection
            );
        }

        // move thread to target
        $threadLogic = ThreadLogic::getInstance();
        $threadRootCategory = $this->getApplicationRootCategory(
            $target_space_id, Application::APPLICATION_CODE_DISCUSSION,
            \CB_I18N::getInstance()->getCurrentLanguage()
        );
        $threadLogic->moveThreadList($threadCollection,
            $threadRootCategory->getId(), $targetFolder->getId());

        // move todo to target
        if ($source_space_id != $target_space_id) {
            $this->_moveTodoList(
                $threadCollection, $sourceSpace, $sourceSpaceUserCollection,
                $targetSpaceUserCollection,
                $targetTodoRootCategory
            );
        }

        // update space component modify timestamp
        $targetSpace
            = $spaceLogic->modifySpaceComponentModifyTimestamp($targetSpace);

        // update read status and send notification
        foreach ($threadCollection as $thread) {
            /** @var \grn\space\data\bean\Thread $thread */
            $thread->setCategoryId($threadRootCategory->getId());
            $thread->setFolderId($targetFolder->getId());

            //read process
            $threadLogic->deleteThreadReadStatusByThreadId($thread->getId());
            $threadLogic->createThreadReadStatus($thread->getId(), $loginId);
            $thread->setUnRead(false);

            if ($sendNotification) {
                $notificationLogic = SpaceNotificationLogic::getInstance();
                $userCollection
                    = $this->getDiscussionNotificationUserCollection(
                    $targetSpace->getId(), $thread->getId(), $loginId
                );

                if ($source_space_id != $target_space_id) {
                    // send create notify
                    /** @var \grn\space\data\collection\SpaceUserCollection $userNotifyCreateCollection */
                    $userNotifyCreateCollection
                        = $userCollection->getNotIn($sourceSpaceUserCollection);

                    $actionCreate = 'create';
                    $notificationLogic->sendThreadNotification(
                        $login->getOID(), $actionCreate, $thread, $targetSpace,
                        $userNotifyCreateCollection->toArray()
                    );

                    // send update notify
                    /** @var \grn\space\data\collection\SpaceUserCollection $userNotifyUpdateCollection */
                    $userNotifyUpdateCollection
                        = $userCollection->getNotIn($userNotifyCreateCollection);
                    $userNotifyUpdateCollection
                        = $this->addNonSpaceUserToNotify(
                        $userNotifyUpdateCollection, $thread->getId()
                    );

                    $actionUpdate = 'update';
                    $notificationLogic->sendThreadNotification(
                        $login->getOID(), $actionUpdate, $thread, $targetSpace,
                        $userNotifyUpdateCollection->toArray()
                    );
                } else {
                    // send update notify
                    $userCollection
                        = $this->addNonSpaceUserToNotify($userCollection,
                        $thread->getId());

                    $action = 'update';
                    $notificationLogic->sendThreadNotification(
                        $login->getOID(), $action, $thread, $targetSpace,
                        $userCollection->toArray()
                    );
                }
            }
        }

        // export log MoveThreadLog
        $moveThreadLog = new MoveThreadLog();
        foreach ($threadCollection as $thread) {
            /** @var \grn\space\data\bean\Thread $thread */
            $moveThreadLog->setSpaceId($sourceSpace->getId());
            $moveThreadLog->setSpaceName($sourceSpace->getSpaceName());
            $moveThreadLog->setThreadId($thread->getId());
            $moveThreadLog->setThreadName($thread->getTitle());
            $moveThreadLog->setFolderId($sourceFolder->getId());
            $moveThreadLog->setFolderName($sourceFolder->getFolderName());
            $moveThreadLog->setDestinationSpaceId($targetSpace->getId());
            $moveThreadLog->setDestinationSpaceName($targetSpace->getSpaceName());
            $moveThreadLog->setDestinationFolderId($targetFolder->getId());
            $moveThreadLog->setDestinationFolderName($targetFolder->getFolderName());
            $moveThreadLog->setNotifyCheck($sendNotification ? "ON" : "OFF");
            $this->getSpaceLogLogic()->info($moveThreadLog);
        }

        //Full Text Search
        if (FtsApplication::isAvailable()
            && ($source_space_id != $target_space_id)
        ) {
            $searchService = new IndexService();
            $commentSearchCondition = new CommentSearchCondition();
            $todoSearchCondition = new TodoSearchCondition();

            // update index for space
            $searchService->updateSpaceIndex($targetSpace, $loginId);

            foreach ($threadCollection as $thread) {
                /** @var \grn\space\data\bean\Thread $thread */
                // delete old index related to thread
                $searchService->deleteIndexByDiscussionId($thread->getId());

                // create index for discussion
                $this->_createDiscussionIndex($searchService, $targetSpace,
                    $thread);

                // create index for discussion comment
                $this->_createDiscussionCommentIndex($searchService,
                    $targetSpace, $thread, $commentSearchCondition);

                // create index for todo
                $this->_createTodoIndex(
                    $searchService, $targetSpace, $thread,
                    $commentSearchCondition, $targetTodoRootCategory,
                    $todoSearchCondition
                );
            }
        }
    }

    /**
     * @param ThreadCollection    $threadCollection
     * @param Space               $targetSpace
     * @param SpaceUserCollection $sourceSpaceUserCollection
     * @param SpaceUserCollection $targetSpaceUserCollection
     *
     * @throws \grn\space\common\exception\GrnInvalidArgumentException
     */
    private function _deleteRelatedDiscussionNotification(
        ThreadCollection $threadCollection,
        Space $targetSpace,
        SpaceUserCollection $sourceSpaceUserCollection,
        SpaceUserCollection $targetSpaceUserCollection
    ) {
        $threadLogic = ThreadLogic::getInstance();

        //remove DiscussionNonNotificationUser of source space
        /** @var \grn\space\data\collection\SpaceUserCollection $diffUserSourceCollection */
        $diffUserSourceCollection
            = $sourceSpaceUserCollection->getNotIn($targetSpaceUserCollection);
        if (count($diffUserSourceCollection) > 0) {
            $threadLogic->deleteAllDiscussionNonNotification($threadCollection,
                $diffUserSourceCollection->toArray());
        }

        // remove non space member for user who is member of space target
        /** @var \grn\space\data\collection\SpaceUserCollection $diffUserTargetCollection */
        $diffUserTargetCollection
            = $targetSpaceUserCollection->getNotIn($sourceSpaceUserCollection);
        if (count($diffUserTargetCollection) > 0) {
            $threadLogic->deleteMultiDiscussionNotification($threadCollection,
                $diffUserTargetCollection);
        }

        //remove non-space user following discussion when space target is private
        if ( ! $targetSpace->isPublic()) {
            $discussionIds = [];
            foreach ($threadCollection as $thread) {
                /** @var \grn\space\data\bean\Thread $thread */
                $discussionIds[] = $thread->getId();
            }
            $threadLogic->deleteDiscussionNotificationByDiscussionId($discussionIds);
        }
    }

    /**
     * @param ThreadCollection      $threadCollection
     * @param Space                 $sourceSpace
     * @param SpaceMemberCollection $sourceSpaceUserCollection
     * @param SpaceMemberCollection $targetSpaceUserCollection
     * @param Category              $todoRootCategory
     *
     * @throws \grn\space\common\exception\GrnInvalidArgumentException
     */
    private function _moveTodoList(
        ThreadCollection $threadCollection,
        Space $sourceSpace,
        SpaceMemberCollection $sourceSpaceUserCollection,
        SpaceMemberCollection $targetSpaceUserCollection,
        Category $todoRootCategory
    ) {
        //remove TodoUser who is not member of space target
        /** @var \grn\space\common\data\collection\SpaceMemberCollection $diffUserSourceCollection */
        $diffUserSourceCollection
            = $sourceSpaceUserCollection->getNotIn($targetSpaceUserCollection);
        $todoLogic = TodoLogic::getInstance();
        if (count($diffUserSourceCollection) > 0) {
            $todoLogic->deleteTodoUsersBySpaceIdSpaceMemberCollection(
                $sourceSpace->getId(),
                $diffUserSourceCollection->getSpaceUserIdsOfOnlyUser()
            );
        }

        // move todo
        $discussionIds = [];
        foreach ($threadCollection as $thread) {
            /** @var \grn\space\data\bean\Thread $thread */
            $discussionIds[] = $thread->getId();
        }

        $todoService = TodoService::getInstance();
        $todo_id_list = $todoService->getTodoIdByDiscussionId($discussionIds);
        $todoService->moveTodoList($todo_id_list, $todoRootCategory->getId());
    }

    /**
     * @param IndexService $searchService
     * @param Space        $space
     * @param Thread       $thread
     */
    private function _createDiscussionIndex(
        IndexService $searchService,
        Space $space,
        Thread $thread
    ) {
        $searchService->createDiscussionIndex($space, $thread);

        // search thread file collection
        $spaceFileSearchCondition = new SpaceFileSearchCondition();
        $spaceFileSearchCondition->setSearchScopeType(SpaceFileSearchCondition::SEARCH_SCOPE_TYPE_THREAD);
        $spaceFileSearchCondition->setSearchScopeValue($thread->getId());

        $fileLogic = SpaceFileLogic::getInstance();
        $threadFileCollection
            = $fileLogic->getSpaceFileCollection($spaceFileSearchCondition);

        // create index for file of discussion
        foreach ($threadFileCollection as $threadFile) {
            $searchService->createFileIndex($space, $threadFile, $thread);
        }
    }

    /**
     * @param IndexService           $searchService
     * @param Space                  $space
     * @param Thread                 $thread
     * @param CommentSearchCondition $commentSearchCondition
     */
    private function _createDiscussionCommentIndex(
        IndexService $searchService,
        Space $space,
        Thread $thread,
        CommentSearchCondition $commentSearchCondition
    ) {
        // search comment collection
        $commentSearchCondition->setSearchScopeType(CommentSearchCondition::SEARCH_SCOPE_TYPE_THREAD);
        $commentSearchCondition->setSearchScopeValue($thread->getId());

        $commentLogic = CommentLogic::getInstance();
        $commentCollection
            = $commentLogic->searchComment($commentSearchCondition);

        // search file of comment
        if (count($commentCollection) > 0) {
            $this->_getCommentFileCollection($commentCollection);
        }

        foreach ($commentCollection as $comment) {
            /** @var \grn\space\common\data\bean\Comment $comment */
            // create index for comment
            $searchService->createDiscussionCommentIndex($space, $thread,
                $comment);

            // create index for file of comment
            $commentFileCollection = $comment->getSpaceFileCollection();
            foreach ($commentFileCollection as $commentFile) {
                $searchService->createFileIndex($space, $commentFile, $thread,
                    null, $comment);
            }
        }
    }

    /**
     * @param IndexService           $searchService
     * @param Space                  $space
     * @param Thread                 $thread
     * @param CommentSearchCondition $commentSearchCondition
     * @param Category               $todoRootCategory
     * @param TodoSearchCondition    $todoSearchCondition
     */
    private function _createTodoIndex(
        IndexService $searchService,
        Space $space,
        Thread $thread,
        CommentSearchCondition $commentSearchCondition,
        Category $todoRootCategory,
        TodoSearchCondition $todoSearchCondition
    ) {
        $login = cb_get_login_user();

        // search todo
        $todoSearchCondition->setSearchCategoryId($todoRootCategory->getId());
        $todoSearchCondition->setSearchThreadId($thread->getId());

        $todoService = TodoService::getInstance();
        $todoCollection
            = $todoService->searchTodoBySearchCondition($todoSearchCondition,
            $login->getOID());

        $spaceFileSearchCondition = new SpaceFileSearchCondition();
        $spaceFileSearchCondition->setSearchScopeType(SpaceFileSearchCondition::SEARCH_SCOPE_TYPE_TODO);

        foreach ($todoCollection as $todo) {
            /** @var \grn\space\data\bean\Todo $todo */
            // create index for todo
            $searchService->createTodoIndex($space, $thread, $todo);

            // search file of todo
            $spaceFileSearchCondition->setSearchScopeValue($todo->getId());

            $fileLogic = SpaceFileLogic::getInstance();
            $todoFileCollection
                = $fileLogic->getSpaceFileCollection($spaceFileSearchCondition);

            // create index for file of todo
            foreach ($todoFileCollection as $todoFile) {
                $searchService->createFileIndex($space, $todoFile, $thread,
                    $todo, null);
            }

            // create index for todo comment
            $this->_createTodoCommentIndex($searchService, $space, $thread,
                $todo, $commentSearchCondition);
        }
    }

    /**
     * @param IndexService           $searchService
     * @param Space                  $space
     * @param Thread                 $thread
     * @param Todo                   $todo
     * @param CommentSearchCondition $commentSearchCondition
     */
    private function _createTodoCommentIndex(
        IndexService $searchService,
        Space $space,
        Thread $thread,
        Todo $todo,
        CommentSearchCondition $commentSearchCondition
    ) {
        // search todo comment
        $commentSearchCondition->setSearchScopeType(CommentSearchCondition::SEARCH_SCOPE_TYPE_TODO);
        $commentSearchCondition->setSearchScopeValue($todo->getId());

        $commentLogic = CommentLogic::getInstance();
        $commentTodoCollection
            = $commentLogic->searchComment($commentSearchCondition);

        // search file of comment
        if (count($commentTodoCollection) > 0) {
            $this->_getCommentFileCollection($commentTodoCollection);
        }

        foreach ($commentTodoCollection as $commentTodo) {
            /** @var \grn\space\common\data\bean\Comment $commentTodo */
            // create index for comment todo
            $searchService->createTodoCommentIndex($space, $thread, $todo,
                $commentTodo);

            // create index for file of comment todo
            $commentTodoFileCollection = $commentTodo->getSpaceFileCollection();
            foreach ($commentTodoFileCollection as $commentTodoFile) {
                $searchService->createFileIndex($space, $commentTodoFile,
                    $thread, $todo, $commentTodo);
            }
        }
    }

    /**
     * @param CommentCollection $commentCollection
     */
    private function _getCommentFileCollection(
        CommentCollection $commentCollection
    ) {
        $fileLogic = SpaceFileLogic::getInstance();
        $fileCollectionArray
            = $fileLogic->getSpaceFileCollectionsArray($commentCollection);

        //set fileCollection
        foreach ($fileCollectionArray as $commentId => $fileCollection) {
            foreach ($commentCollection as $comment) {
                /** @var \grn\space\common\data\bean\Comment $comment */
                if ($comment->getId() == $commentId) {
                    $comment->setSpaceFileCollection($fileCollection);
                    continue 2;
                }
            }
        }
    }

    /**
     * @param Category $rootCategory
     * @param          $folder_id
     * @param array    $thread_id_list
     *
     * @return ThreadCollection
     */
    public function verifyThreadListWithFolderId(
        Category $rootCategory,
        $folder_id,
        array $thread_id_list
    ) {
        $discussionLogic = ThreadLogic::getInstance();

        return $discussionLogic->selectThreadListByFolderIdThreadIdList($rootCategory,
            $folder_id, $thread_id_list);
    }

    /**
     * @param                       $authorityCode
     * @param ThreadSearchCondition $searchCondition
     * @param                       $operationUserId
     *
     * @return ThreadCollection
     * @throws \grn\space\common\exception\GrnArgumentOutOfRangeException
     * @throws \grn\space\common\exception\GrnInvalidArgumentException
     * @throws \grn\space\common\exception\GrnRequiredDataIsNotException
     */
    public function selectThreadListByConditionWithAccessControl(
        $authorityCode,
        ThreadSearchCondition $searchCondition,
        $operationUserId
    ) {
        //input data check
        ValidateUtility::isIn($authorityCode
            , [
                Authority::AUTHORITY_CODE_READ_SUMMARY
                ,
                Authority::AUTHORITY_CODE_READ_DETAIL
                ,
                Authority::AUTHORITY_CODE_WRITE
                ,
                Authority::AUTHORITY_CODE_SYSTEM_PRIVILEGE
                ,
                Authority::AUTHORITY_CODE_OPERATION_PRIVILEGE
            ]
            , ValidateUtility::DISABLE_EMPTY);
        ValidateUtility::isNumber($operationUserId);
        $searchCondition->isValidData(ThreadSearchCondition::VALID_TYPE_SELECT);

        $spaceLogic = SpaceLogic::getInstance();
        $space
            = $spaceLogic->getSpaceByApplicationCategoryId($searchCondition->getSearchCategoryId(),
            LanguageStatus::STANDARD_LANGUAGE_CODE);
        $spaceAclLogic = SpaceAccessControlListLogic::getInstance();
        $hasSpaceAccessControl
            = $spaceAclLogic->hasSpaceAccessControl($authorityCode,
            $space->getId(), $operationUserId);

        if ($hasSpaceAccessControl === false) {
            if (($authorityCode == Authority::AUTHORITY_CODE_READ_DETAIL)
                || ($authorityCode
                    == Authority::AUTHORITY_CODE_SYSTEM_PRIVILEGE)
            ) {
                $hasSpaceAccessControl
                    = $this->_isSpaceAdministrator($operationUserId);
            }
        }

        if ($hasSpaceAccessControl) {
            $threadLogic = ThreadLogic::getInstance();
            $resultThreadCollection
                = $threadLogic->selectThreadListByCondition($searchCondition);
        } else {
            $resultThreadCollection = new ThreadCollection();
        }

        return $resultThreadCollection;
    }

    /**
     * @param $browse_log
     */
    public function addBrowseThreadLog($browse_log)
    {
        $browseThreadLog = new BrowseThreadLog();
        $browseThreadLog->setSpaceId($browse_log['space_id']);
        $browseThreadLog->setCategoryId($browse_log['category_id']);
        $browseThreadLog->setSpaceName($browse_log['space_name']);
        if (isset($browse_log['directory_id'])) {
            $browseThreadLog->setDirectoryId($browse_log['directory_id']);
        }
        $browseThreadLog->setThreadId($browse_log['thread_id']);
        $browseThreadLog->setThreadName($browse_log['thread_name']);
        $this->getSpaceLogLogic()->info($browseThreadLog);
    }

    /**
     * @param                         $space_id
     * @param                         $thread_id
     * @param                         $operation_user_id
     * @param array                   $to_me_user_ids
     *
     * @return CategorizedNotificationUsers
     */
    private function getDiscussionCategorizedNotificationUsers(
        $space_id,
        $thread_id,
        $operation_user_id,
        array $to_me_user_ids
    ): CategorizedNotificationUsers {
        $space_user_search_condition = new SpaceUserSearchCondition();
        $space_user_search_condition->setSearchSpaceId($space_id);
        $space_user_search_condition->setOrderSortArray([SpaceUserSearchCondition::SORT_DISPLAY_ORDER_ASC]);

        $space_logic = SpaceLogic::getInstance();
        $space = $space_logic->getSpace($space_id,
            LanguageStatus::STANDARD_LANGUAGE_CODE);
        $space_user_collection
            = $space_logic->searchSpaceUsers($space_user_search_condition,
            $operation_user_id);
        $space_user_ids
            = $space_logic->getSpaceUserMemberIds($space_user_collection,
            $space_id);

        $thread_logic = ThreadLogic::getInstance();
        $categorized_ntf_users
            = $thread_logic->getDiscussionCategorizedNotificationUsers(
            $space, $space_user_ids, $thread_id, $to_me_user_ids);

        return $categorized_ntf_users;
    }

    /**
     * @param $space_id
     * @param $thread_id
     * @param $operation_user_id
     *
     * @return SpaceUserCollection
     */
    private function getDiscussionNotificationUserCollection(
        $space_id,
        $thread_id,
        $operation_user_id
    ) {
        $space_user_search_condition = new SpaceUserSearchCondition();
        $space_user_search_condition->setSearchSpaceId($space_id);
        $space_user_search_condition->setOrderSortArray([SpaceUserSearchCondition::SORT_DISPLAY_ORDER_ASC]);

        $space_logic = SpaceLogic::getInstance();
        $space_user_collection
            = $space_logic->searchSpaceUsers($space_user_search_condition,
            $operation_user_id);
        $space_user_ids
            = $space_logic->getSpaceUserMemberIds($space_user_collection,
            $space_id);

        $thread_logic = ThreadLogic::getInstance();
        $notification_user_ids
            = $thread_logic->getDiscussionNotificationUserCollection($space_user_ids,
            $thread_id, $operation_user_id);

        $result = new SpaceUserCollection();
        foreach ($notification_user_ids as $notification_user_id) {
            // @codingStandardsIgnoreStart
            $result->appendBean( new SpaceUser( array( SpaceUser::ID       => $notification_user_id,
                                                       SpaceUser::SPACE_ID => $space_id,
                                                       SpaceUser::USER     => $notification_user_id ),
                                                       SpaceUser::NOT_CHECK_INPUT ) );
            // @codingStandardsIgnoreEnd
        }

        return $result;
    }

    /**
     * @param CommentCollection $comment_collection
     *
     * @return CommentCollection
     */
    public function addMentionInfo($comment_collection)
    {
        $comment_id_list = [];
        foreach ($comment_collection as $comment) {
            $comment_id_list[] = $comment->getId();
        }
        $mention_DAO = new SpaceMentionDAO();
        $mention_collections
            = $mention_DAO->getByCommentIdList($comment_id_list);
        foreach ($comment_collection as $comment) {
            if (array_key_exists($comment->getId(), $mention_collections)) {
                $comment->setMention($mention_collections[$comment->getId()]);
            }
        }

        return $comment_collection;
    }
}
