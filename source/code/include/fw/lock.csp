<?php

/**
 * Lock API.
 *
 * @author    Yamamoto, Hirotaka    2004/07
 * @version   1.0
 * @package   fw.persistent
 */

require_once('fw/persistent.csp');
require_once('fw/uum_core.csp');

/**
 * Abstract base class for lockable DB objects.
 *
 * Before you write to columns of a lockable object, you should
 * acquire the exclusive lock by {@link CB_Lockable::acquireLock}, or
 * "set()" method will fail and return FALSE.
 *
 * @abstract
 * @package fw.persistent
 */
class CB_Lockable extends CB_PersistentBase
{
    var $col_lock_owner = ['type' => 'weak_relation', 'to' => 'CB_User'];
    var $col_lock_timeout = ['type' => 'int'];

    /**
     * @access private
     */
    var $__login = false;

    /**
     * @access private
     */
    var $__locked = false;

    function __construct($row)
    {
        parent::__construct($row);

        global $G_container_base;
        /** @var GRN_Uum $uum */
        $uum = $G_container_base->getInstance('uum');
        $this->__login = $uum->getLoginUser();
    }

    /**
     * Acquire the exclusive, persistent lock for the row.
     * Persistent locks survive the request where they are acquired.
     *
     * Note that the session need to have a login user to lock a row.
     *
     * If $lifetime === 0, the lock will be held until
     * {@link CB_Lockable::unlock} will be called.
     *
     * @param int $lifetime Lock lifetime in minutes.
     *
     * @return bool           TRUE if obtained the lock; otherwise FALSE.
     */
    function acquireLock($lifetime)
    {
        if ($this->__login === false) {
            return false;
        }

        // acquire exclusive lock
        $this->lock();

        $owner = $this->get('lock_owner');
        $now = time();
        if ( ! is_null($owner)) {
            $endtime = $this->get('lock_timeout');
            if (($endtime == -1) || ($now < $endtime)) {
                $this->__locked = ($owner->getOID()
                                   === $this->__login->getOID());

                return $this->__locked;
            }
        }

        $timeout = ($lifetime === 0) ? -1 : ($now + $lifetime * 60);
        parent::set('lock_owner', $this->__login);
        parent::set('lock_timeout', $timeout);
        $this->__locked = true;

        return true;
    }

    /**
     * Unlock previously held lock.
     *
     * @param bool $force TRUE to force unlock.
     *
     * @return bool       TRUE if unlock succeeds;
     *                    FALSE if lock has been held by another one.
     */
    function releaseLock($force = false)
    {
        $this->__locked = false;

        // acquire exclusive lock
        $this->lock();

        $owner = $this->get('lock_owner');
        if (( ! $force) && (is_null($owner) || ($this->__login === false))) {
            return false;
        }

        if ($force || ($owner->getOID() === $this->__login->getOID())) {
            parent::set('lock_owner', null);
            parent::set('lock_timeout', null);

            return true;
        }

        return false;
    }

    /**
     * Test if the lock is held by some other one.
     * To know the current lock onwer, see "$this->get( 'lock_owner' )" .
     *
     * @return bool    TRUE if someone keeps lock; otherwise FALSE.
     */
    function testLock($user)
    {
        $owner = $this->get('lock_owner');
        if (is_null($owner)) {
            return false;
        }

        if ($this->__login === false) {
            return true;
        }

        if ($owner->getOID() === $this->__login->getOID()) {
            return false;
        }

        $endtime = $this->get('lock_timeout');
        if ($endtime == -1) {
            return true;
        }

        return (time() < $endtime);
    }

    /**
     * Override setter method to test if the lock has been held.
     *
     * @return bool   FALSE if lock has not been acquired, or expired.
     */
    function set($name, $value)
    {
        if (( ! $this->getTempId()) && ( ! $this->__locked)) {
            if ($this->__login === false) {
                return false;
            }

            $owner = $this->get('lock_owner');
            if (is_null($owner)) {
                return false;
            }

            if ($owner->getOID() !== $this->__login->getOID()) {
                return false;
            }

            $endtime = $this->get('lock_timeout');
            if (($endtime != -1) && ($endtime < time())) {
                return false;
            }
        }
        $this->__locked = true;

        return parent::set($name, $value);
    }
}


