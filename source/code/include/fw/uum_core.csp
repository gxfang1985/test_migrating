<?php

/**
 * Unified User Management (UUM) Core modules.
 *
 * @package fw.uum.core
 */

use grn\system\sandbox\SandboxConstants;

require_once('fw/persistent.csp');
require_once('fw/module.csp');
require_once('fw/FwFacade.csp');
require_once('fw/i18n.csp');

/**
 * Read-only core information table for users.
 *
 * @package fw.uum.core
 */
class CB_User extends CB_ReadOnlyBase
{
    function __construct($row)
    {
        parent::__construct($row);
    }

    // persistent columns

    var $col_display_name = ['type' => 'char', 'notnull' => true];
    var $col_given_name = ['type' => 'char', 'lazy' => true];
    var $col_family_name = ['type' => 'char', 'lazy' => true];
    var $col_initials = ['type' => 'char', 'lazy' => true];

    // deleted flag
    var $col_deleted = ['type' => 'timestamp'];
    var $idx_deleted = ['cols' => 'deleted'];

    // foreign key (login name, account)
    var $col_foreign_key
        = [
            'type'    => 'char',
            'length'  => CB_DATABASE_MAX_STRINDEX,
            'notnull' => true
        ];
    var $idx_foreign_key = ['cols' => 'foreign_key', 'unique' => true];

    // sort key (in Japanese, YOMI)
    var $col_sort_key = ['type' => 'char', 'lazy' => true];
    // hidden column that stores normalized sort key
    var $col_normalized_sort_key = ['type' => 'char', 'lazy' => true];
    var $idx_normalized_sort_key1
        = [
            'cols' => [
                'normalized_sort_key',
                'position',
                null
            ]
        ];
    var $idx_normalized_sort_key2
        = [
            'cols' => [
                'normalized_sort_key',
                'list_index',
                null
            ]
        ];

    // list index (list of all users)
    var $col_list_index = ['type' => 'list_index', 'lazy' => true];
    var $idx_list_index = ['cols' => ['list_index', null]];

    // authentication information.
    // $col_salt provides the salt string used to calculate SHA1
    // sum of the password.  $col_password provides the SHA1 sum
    // of the plain password (represented in hexadecimal text).
    var $col_salt = ['type' => 'blob', 'length' => 4, 'lazy' => true];
    var $col_password = ['type' => 'char', 'length' => 40, 'lazy' => true];

    // NULL means this account is valid permanently;
    // past date means this account has been invalidated;
    // future date means this account will be valid until the date comes.
    // The date should be dertermined by the system local date.
    var $col_valid = ['type' => 'date', 'lazy' => true];


    var $col_nickname = ['type' => 'char', 'notnull' => true];
    var $col_display_name_language = ['type' => 'int', "sqltype" => 'BIGINT'];
    // This column is altered soon after this table is created.
    // See the method named "execAfterCreateTable"


    // contact information
    var $col_email_address = ['type' => 'char'];
    var $col_physical_address
        = [
            'type'   => 'char',
            'length' => 4095,
            'lazy'   => true
        ];
    var $col_telephone_number = ['type' => 'char', 'lazy' => false];
    var $col_facsimile_number = ['type' => 'char', 'lazy' => true];
    var $col_url
        = [
            'type'   => 'char',
            'length' => CB_DATABASE_MAX_STRINDEX,
            'lazy'   => false
        ];
    var $col_room_number = ['type' => 'char', 'lazy' => true];

    // miscellaneous properties
    var $col_employee_number = ['type' => 'char', 'lazy' => true];
    var $col_position = ['type' => 'int', 'unsigned' => true, 'lazy' => true];
    var $idx_position = ['cols' => ['position', null]];
    var $col_birthdate = ['type' => 'date', 'lazy' => true];
    var $col_ctime = ['type' => 'timestamp', 'lazy' => true];
    var $col_mtime = ['type' => 'timestamp', 'lazy' => true];

    // free text description
    var $col_description
        = [
            'type'   => 'char',
            'length' => 65535,
            'lazy'   => true
        ];

    // reserved columns
    var $col_reserve_text1 = ['type' => 'char', 'lazy' => true];
    var $col_reserve_text2 = ['type' => 'char', 'lazy' => true];
    var $col_reserve_text3 = ['type' => 'char', 'lazy' => true];
    var $col_reserve_int1 = ['type' => 'int', 'lazy' => true];
    var $col_reserve_int2 = ['type' => 'int', 'lazy' => true];
    var $col_reserve_int3 = ['type' => 'int', 'lazy' => true];
    var $col_reserve_blob1 = ['type' => 'blob', 'lazy' => true];
    var $col_reserve_blob2 = ['type' => 'blob', 'lazy' => true];
    var $col_reserve_blob3 = ['type' => 'blob', 'lazy' => true];

    var $col_timezone = ['type' => 'char', 'length' => 100, 'lazy' => true];

    var $col_slash = ['type' => 'int', 'length' => 20, 'lazy' => false];
    var $col_slash_password
        = [
            'type'   => 'char',
            'length' => 65535,
            'lazy'   => true
        ];
    var $col_slash_salt = ['type' => 'char', 'length' => 64, 'lazy' => true];

    /**
     * @var array
     * @see GRN_Uum_Sandbox::getUser
     */
    public $sandbox_values = []; // for col_valid, col_position

    /**
     * Return user profile object for the named module.
     *
     * @param string $module_name Module name.
     *
     * @return object CB_Profile   A profile object for this user.
     */
    function getProfile($module_name)
    {
        require_once('fw/profile.csp');
        $profile = cb_get_user_profile($this, $module_name);

        return $profile;
    }


    public function execAfterCreateTable(CB_TableInfo $table_info)
    {
        $dbconn = $table_info->getDBConnection();
        $dbconn->query(
            "ALTER TABLE tab_cb_user "
            . "MODIFY col_display_name_language BIGINT(20) DEFAULT NULL, "
            . "ADD CONSTRAINT cns_cb_user_display_name_language FOREIGN KEY (col_display_name_language) REFERENCES tab_cb_language_status (_id) ON DELETE SET NULL;"
        );
        $dbconn->query(
            "UPDATE _table_info SET "
            . "col_columns=\"birthdate type=date lazy=1,ctime type=timestamp lazy=1,deleted type=timestamp,description type=char length=65535 lazy=1,display_name type=char notnull=1,display_name_language type=int sqltype=BIGINT,email_address type=char,employee_number type=char lazy=1,facsimile_number type=char lazy=1,family_name type=char lazy=1,foreign_key type=char length=255 notnull=1,given_name type=char lazy=1,initials type=char lazy=1,list_index type=list_index lazy=1,mtime type=timestamp lazy=1,nickname type=char notnull=1,normalized_sort_key type=char lazy=1,password type=char length=40 lazy=1,physical_address type=char length=4095 lazy=1,position type=int unsigned=1 lazy=1,reserve_blob1 type=blob lazy=1,reserve_blob2 type=blob lazy=1,reserve_blob3 type=blob lazy=1,reserve_int1 type=int lazy=1,reserve_int2 type=int lazy=1,reserve_int3 type=int lazy=1,reserve_text1 type=char lazy=1,reserve_text2 type=char lazy=1,reserve_text3 type=char lazy=1,room_number type=char lazy=1,salt type=blob length=4 lazy=1,sort_key type=char lazy=1,telephone_number type=char lazy=1,url type=char length=255 lazy=1,valid type=date lazy=1\", "
            . "col_indices=\"deleted cols=deleted,foreign_key cols=foreign_key unique=1,list_index cols=list_index cols=,normalized_sort_key1 cols=normalized_sort_key cols=position cols=,normalized_sort_key2 cols=normalized_sort_key cols=list_index cols=,position cols=position cols=\" "
            . "WHERE col_name=\"cb_user\";"
        );
    }

    /**
     * @param string $col_name
     *
     * @return CB_Row|string|mixed
     */
    public function get($col_name)
    {
        $ret = null;
        if (array_key_exists($col_name, $this->sandbox_values)) {
            $ret = $this->sandbox_values[$col_name];
        } else {
            $ret = parent::get($col_name);
        }

        return $ret;
    }

    /**
     * @return bool
     */
    public function isActive()
    {
        $valid = $this->get('valid');
        if ( ! is_null($valid)) {
            $today = getdate();
            if (($valid->year < $today['year'])
                || ($valid->year == $today['year']
                    && $valid->month < $today['mon'])
                || ($valid->year == $today['year']
                    && $valid->month == $today['mon']
                    && $valid->day < $today['mday'])
            ) {
                return false;
            }
        }

        return true;
    }
}

/**
 * Read-only core information table for groups.
 *
 * @package fw.uum.core
 */
class CB_Group extends CB_ReadOnlyBase
{
    public $sandbox = SandboxConstants::NO_SANDBOX_MODE;

    function __construct($row)
    {
        parent::__construct($row);
    }

    // persistent columns
    var $col_name = ['type' => 'char', 'notnull' => true];

    /** unique external identifiers (first appeared in Garoon). */
    var $col_foreign_key
        = [
            'type'    => 'char',
            'length'  => CB_DATABASE_MAX_STRINDEX,
            'notnull' => true
        ];
    var $idx_foreign_key = ['cols' => ['foreign_key'], 'unique' => true];

    /** The OID of the parent group, or NULL */
    var $col_parent = ['type' => 'relation', 'to' => 'CB_Group'];

    /** list index */
    var $col_list_index = ['type' => 'list_index'];
    var $idx_list_index1 = ['cols' => ['list_index', null]];
    var $idx_list_index2 = ['cols' => ['parent', 'list_index', null]];

    // contact information
    var $col_email_address = ['type' => 'char'];
    var $col_physical_address
        = [
            'type'   => 'char',
            'length' => 4095,
            'lazy'   => true
        ];
    var $col_telephone_number = ['type' => 'char', 'lazy' => true];
    var $col_facsimile_number = ['type' => 'char', 'lazy' => true];
    var $col_url = ['type' => 'char', 'length' => 4095, 'lazy' => true];
    var $col_room_number = ['type' => 'char', 'lazy' => true];

    // miscellaneous properties
    var $col_ctime = ['type' => 'timestamp', 'lazy' => true];
    var $col_mtime = ['type' => 'timestamp', 'lazy' => true];

    // free text description
    var $col_description
        = [
            'type'   => 'char',
            'length' => 65535,
            'lazy'   => true
        ];

    // reserved columns
    var $col_reserve_text1 = ['type' => 'char', 'lazy' => true];
    var $col_reserve_text2 = ['type' => 'char', 'lazy' => true];
    var $col_reserve_int1 = ['type' => 'int', 'lazy' => true];
    var $col_reserve_int2 = ['type' => 'int', 'lazy' => true];
    var $col_reserve_blob1 = ['type' => 'blob', 'lazy' => true];
    var $col_reserve_blob2 = ['type' => 'blob', 'lazy' => true];

    var $col_slash = ['type' => 'int', 'length' => 20, 'lazy' => false];

    // methods
    function applyToChildren($func)
    {
        $rowset = new CB_RowSet($this->getTableInfo());
        $rowset->addCondition('col_parent=' . $this->getOID());
        while ( ! is_null($row = $rowset->iterate())) {
            call_user_func($func, $row);
            $row->applyToChildren($func);
        }
    }

    function getParent()
    {

        $isKeyExists = array_key_exists(CB_DATABASE_COLUMN_PREFIX
                                        . 'parent',
            $this->__row->_rawdata);
        $id = $isKeyExists
            ? $this->__row->_rawdata[CB_DATABASE_COLUMN_PREFIX . 'parent']
            : null;
        $i18n = CB_I18N::getInstance();
        $table_info = $this->getTableInfo();
        $tableManager = $table_info->getTableManager();
        $col_info = $table_info->getColumnInfo('parent');
        $relationTableName = $col_info['to'];
        $relationTableInfo = $tableManager->getTableInfo($relationTableName);
        $relationTableLock = $relationTableInfo->_lock;
        $dao = new FwFacade($this->sandbox);
        $dataObj = [];
        $dataObj['lock'] = $relationTableLock;
        $dataObj['language'] = $i18n->getCurrentLanguage();

        if ( ! is_null($id)) {
            $groupData = $dao->referGroupById($dataObj, $id);
            $result = $relationTableInfo->getRow($groupData->getId(),
                $groupData->convertArray());
            /** @var $result CB_Group */
            $result->sandbox = $this->sandbox;
        } else {
            $groupData = $dao->referParentGroupById($dataObj, $this->getOID());
            if ($groupData) {
                /** @var $result CB_Group */
                $result = $relationTableInfo->getRow($groupData->getId(),
                    $groupData->convertArray());
                $result->sandbox = $this->sandbox;
            } else {
                $result = null;
            }
        }

        return $result;
    }

    function isRoot()
    {
        return is_null($this->getParent());
    }

    /**
     * @param string $col_name
     *
     * @return CB_Row|mixed
     */
    public function get($col_name)
    {
        $result = false;

        $table_info = $this->getTableInfo();
        $col_info = $table_info->getColumnInfo($col_name);
        if (is_null($col_info)) {
            return $result;
        }

        return ($col_name == 'parent') ? $this->getParent()
            : parent::get($col_name);
    }
}

/**
 * Read-only core information table for static roles.
 *
 * @package fw.uum.core
 */
class CB_Role extends CB_ReadOnlyBase
{
    function __construct($row)
    {
        parent::__construct($row);
    }

    // persistent columns

    /** unique external identifiers */
    var $col_foreign_key
        = [
            'type'    => 'char',
            'length'  => CB_DATABASE_MAX_STRINDEX,
            'notnull' => true
        ];
    var $idx_foreign_key = ['cols' => 'foreign_key', 'unique' => true];

    var $col_list_index = ['type' => 'list_index'];
    var $idx_list_index = ['cols' => ['list_index', null]];

    // miscellaneous properties
    var $col_ctime = ['type' => 'timestamp', 'lazy' => true];
    var $col_mtime = ['type' => 'timestamp', 'lazy' => true];

    // free text description
    var $col_description
        = [
            'type'   => 'char',
            'length' => 65535,
            'lazy'   => true
        ];

    var $col_slash = ['type' => 'int', 'length' => 20, 'lazy' => false];

    // reserved columns
    var $col_reserve_text1 = ['type' => 'char', 'lazy' => true];
    var $col_reserve_text2 = ['type' => 'char', 'lazy' => true];
    var $col_reserve_int1 = ['type' => 'int', 'lazy' => true];
    var $col_reserve_int2 = ['type' => 'int', 'lazy' => true];
    var $col_reserve_blob1 = ['type' => 'blob', 'lazy' => true];
    var $col_reserve_blob2 = ['type' => 'blob', 'lazy' => true];
}

/**
 * Read-only core relation table between users and groups.
 *
 * @package fw.uum.core
 */
class CB_UserGroupRelation extends CB_ReadOnlyBase
{
    function __construct($row)
    {
        parent::__construct($row);
    }

    // persistent columns
    var $col_user = ['type' => 'relation', 'to' => 'CB_User'];
    /** indices of user list (for a group). */
    var $col_user_list = ['type' => 'list_index'];
    var $col_group = ['type' => 'relation', 'to' => 'CB_Group'];
    /** indices of group list (for a user). */
    var $col_group_list = ['type' => 'list_index'];

    // indices ( user list for a group, group list for a user)
    var $idx_users = ['cols' => ['group', 'user_list', null]];
    var $idx_groups = ['cols' => ['user', 'group_list', null]];
    var $idx_usergroup = ['cols' => ['user', 'group'], 'unique' => 'TRUE'];

    /**
     * @param string $col_name
     *
     * @return bool|CB_Row|mixed
     */
    public function get($col_name)
    {
        $result = false;

        $table_info = $this->getTableInfo();
        $col_info = $table_info->getColumnInfo($col_name);
        if (is_null($col_info)) {
            return $result;
        }


        if ($col_name == 'group') {
            $isKeyExists = array_key_exists(CB_DATABASE_COLUMN_PREFIX
                                            . $col_name,
                $this->__row->_rawdata);
            $id = $isKeyExists
                ? $this->__row->_rawdata[CB_DATABASE_COLUMN_PREFIX . $col_name]
                : null;

            if ( ! is_null($id)) {
                $i18n = CB_I18N::getInstance();
                $table_info = $this->getTableInfo();
                $tableManager = $table_info->getTableManager();
                $relationTableName = $col_info['to'];
                $relationTableInfo
                    = $tableManager->getTableInfo($relationTableName);
                $relationTableLock = $relationTableInfo->_lock;

                $dao = new FwFacade();
                $dataObj = [];
                $dataObj['lock'] = $relationTableLock;
                $dataObj['language'] = $i18n->getCurrentLanguage();

                $groupData = $dao->referGroupById($dataObj, $id);
                $result = $relationTableInfo->getRow($groupData->getId(),
                    $groupData->convertArray());
            } else {
                $result = parent::get($col_name);
            }
        } else {
            $result = parent::get($col_name);
        }

        return $result;
    }
}

/**
 * Read-only core relation table between users and roles.
 *
 * @package fw.uum.core
 */
class CB_UserRoleRelation extends CB_ReadOnlyBase
{
    function __construct($row)
    {
        parent::__construct($row);
    }

    // persistent columns
    var $col_user = ['type' => 'relation', 'to' => 'CB_User'];
    var $col_role = ['type' => 'relation', 'to' => 'CB_Role'];

    /** indices of role list (for a user). */
    var $col_role_list = ['type' => 'list_index'];
    var $col_user_list = ['type' => 'list_index'];

    // indices ( user list for a role, role list for a user)
    var $idx_role = ['cols' => ['role', 'user_list', null]];
    var $idx_user = ['cols' => ['user', 'role_list', null]];
    var $idx_userrole = ['cols' => ['user', 'role'], 'unique' => 'TRUE'];
}


// Core API for Service Providers (SP)

/**
 * Provides Core access API for service providers.  UUM Service
 * providers may modify core data structures through methods of
 * the singleton instance of this class.
 *
 * @package fw.uum.core
 */
class CB_UumCoreAPI extends CB_ModuleBase
{
    protected $sandbox = SandboxConstants::NO_SANDBOX_MODE;

    /**
     * @return CB_UumCoreAPI
     */
    public static function getInstance()
    {
        static $_instance = null;
        if (is_null($_instance)) {
            $_instance = new CB_UumCoreAPI();
        }

        return $_instance;
    }

    // cached table objects

    /**
     * @access private
     * @var CB_TableManager
     */
    var $_tm;

    /**
     * @access private
     */
    var $_user_table = null;
    /**
     * @access private
     */
    var $_group_table = null;
    /**
     * @access private
     */
    var $_role_table = null;
    /**
     * @access private
     */
    var $_usergroup_table = null;
    /**
     * @access private
     */
    var $_userrole_table = null;

    /**
     * @access private
     */
    function _loadHook($func, $prefix = null)
    {
        static $_loaded;
        if (isset($_loaded[$func][$prefix])) {
            return;
        }

        $loader = $this->getPluginLoader();

        foreach ($loader->loadHooks($prefix) as $hook) {
            call_user_func([$this, $func], $hook);
        }
        $_loaded[$func][$prefix] = true;
    }

    /**
     * @access private
     */
    function _runHook($triggers, $object)
    {
        foreach (array_keys($triggers) as $trigger) {
            call_user_func($trigger, $object);
        }
    }

    /**
     * @access private
     */
    function __construct()
    {
        parent::__construct('fw.uum.core');

        global $G_container_base;
        $this->_tm = $G_container_base->getInstance('table_manager');
    }

    /**
     * @return CB_TableInfo
     */
    function getUserTable()
    {
        if (is_null($this->_user_table)) {
            $this->_user_table = $this->_tm->getTableInfo('CB_User');
        }

        return $this->_user_table;
    }

    /**
     * @return CB_TableInfo
     */
    public function getGroupTable()
    {
        if (is_null($this->_group_table)) {
            $this->_group_table = $this->_tm->getTableInfo('CB_Group');
        }

        return $this->_group_table;
    }

    function getRoleTable()
    {
        if (is_null($this->_role_table)) {
            $this->_role_table = $this->_tm->getTableInfo('CB_Role');
        }

        return $this->_role_table;
    }

    /**
     * @access protected
     */
    function _getUserGroupTable()
    {
        if (is_null($this->_usergroup_table)) {
            $this->_usergroup_table
                = $this->_tm->getTableInfo('CB_UserGroupRelation');
        }

        return $this->_usergroup_table;
    }

    /**
     * @access protected
     */
    function _getUserRoleTable()
    {
        if (is_null($this->_userrole_table)) {
            $this->_userrole_table
                = $this->_tm->getTableInfo('CB_UserRoleRelation');
        }

        return $this->_userrole_table;
    }


    //// Trigger function holders ////

    /**
     * @access private
     */
    var $_add_user_triggers = [];
    /**
     * @access private
     */
    var $_remove_user_triggers = [];
    /**
     * @access private
     */
    var $_add_group_triggers = [];
    /**
     * @access private
     */
    var $_remove_group_triggers = [];
    /**
     * @access private
     */
    var $_add_role_triggers = [];
    /**
     * @access private
     */
    var $_remove_role_triggers = [];


    static private $_user_cache = [];


    function addTriggerOnAddUser($func)
    {
        // to uniquify triggers, we use array KEYS instead of
        // VALUES to store trigger function names.
        $this->_add_user_triggers[$func] = 1;
    }

    function addTriggerOnRemoveUser($func)
    {
        // to uniquify triggers, we use array KEYS instead of
        // VALUES to store trigger function names.
        $this->_remove_user_triggers[$func] = 1;
    }

    function addTriggerOnAddGroup($func)
    {
        // to uniquify triggers, we use array KEYS instead of
        // VALUES to store trigger function names.
        $this->_add_group_triggers[$func] = 1;
    }

    function addTriggerOnRemoveGroup($func)
    {
        // to uniquify triggers, we use array KEYS instead of
        // VALUES to store trigger function names.
        $this->_remove_group_triggers[$func] = 1;
    }

    function addTriggerOnAddStaticRole($func)
    {
        // to uniquify triggers, we use array KEYS instead of
        // VALUES to store trigger function names.
        $this->_add_role_triggers[$func] = 1;
    }

    function addTriggerOnRemoveStaticRole($func)
    {
        // to uniquify triggers, we use array KEYS instead of
        // VALUES to store trigger function names.
        $this->_remove_role_triggers[$func] = 1;
    }

    //// Core Management API for service providers ////

    // Users

    /**
     * Return an instance of CB_User specified by <var>$id</var>, or
     * <var>FALSE</var> if no such user exists.
     *
     * @param string $id
     *  An object ID or 'foreign_key' column value for the user.
     * @param bool   $include_deleted
     *
     * @return CB_User
     *  An instance of CB_User, or <var>FALSE</var>.
     */
    function getUser($id, $include_deleted = false)
    {
        if (array_key_exists($id, self::$_user_cache)) {
            return self::$_user_cache[$id];
        }

        $table = $this->getUserTable();
        $table->setLock(CB_DATABASE_NO_LOCK);
        $user = $table->getRow($id);
        if ( ! $include_deleted && $user && ! is_null($user->get('deleted'))) {
            $ret = false;

            return $ret;
        }
        self::$_user_cache[$id] = $user;

        return $user;
    }

    function loadAndCache($user_id_list)
    {
        if ( ! is_array($user_id_list)) {
            return;
        }

        foreach (array_keys($user_id_list) as $key) {
            if ( ! is_numeric($user_id_list[$key])) {
                unset($user_id_list[$key]);
            }
        }

        if (count($user_id_list) === 0) {
            return;
        }

        $table = $this->getUserTable();
        $table->setLock(CB_DATABASE_NO_LOCK);
        $table->clearCache();
        $table->setIgnoreLazy(true);
        $rowset = new CB_RowSet($table);
        $rowset->addCondition(cb_queryf($table->getDBConnection(),
            "_id IN (@S)", implode(',', $user_id_list)));
        $rowset->addCondition("col_deleted IS NULL");

        while ($row = $rowset->iterate()) {
            self::$_user_cache[$row->getOID()] = $row;
        }
    }

    public function resetCache()
    {
        self::$_user_cache = [];
    }

    function getUserByForeignKey($key)
    {
        $user = $this->_getByForeignKey($this->getUserTable(), $key);

        return $user;
    }

    /**
     * @param string $key
     *
     * @return CB_User  return FALSE if not exist
     */
    public function getUserBySlashID($key)
    {
        $user = $this->getBySlashID($this->getUserTable(), $key);

        return $user;
    }

    /**
     * @param array
     *
     * @return array [$userId]['uid']       UserId
     *                         ['_id']       GroupId
     *                         ['col_name']  GroupName
     */
    public function &getUserPrimaryGroupListByIds($inUserArray)
    {
        $i18n = CB_I18N::getInstance();

        $dataObj = [];
        $dataObj['language'] = $i18n->getCurrentLanguage();

        $userObjList = $this->getFwFacade()
                            ->getUserPrimaryGroupListByIds($dataObj,
                                $inUserArray);

        $resultList = [];
        foreach ($userObjList as $userObj) {
            $userId = $userObj->getId();

            $resultInfo = [];
            $resultInfo['uid'] = $userId;
            $resultInfo['_id'] = $userObj->getGroupId();
            $resultInfo['col_name'] = $userObj->getGroupName();

            $resultList[$userId] = $resultInfo;
        }

        return $resultList;
    }

    function addUser($properties, $id = null)
    {
        require_once('fw/string_util.csp');

        // unset foreign_key since it has a unique index therefore
        // we need to avoid giving it an empty string.
        if (array_key_exists('foreign_key', $properties)
            && (strlen($properties['foreign_key']) == 0)
        ) {
            unset($properties['foreign_key']);
        }

        if (( ! array_key_exists('display_name', $properties))
            || (strlen(cb_trim($properties['display_name'])) == 0)
        ) {
            cb_throw_error(E_COMMON_MISSING_MANDATORY);
        }

        $user = $this->_add($this->getUserTable(), $properties, $id);

        // run triggers
        $this->_loadHook('addTriggerOnAddUser', 'add_user_');
        $this->_runHook($this->_add_user_triggers, $user);

        return $user;
    }

    function setUserProperties($id, $properties)
    {
        require_once('fw/string_util.csp');

        // unset foreign_key since it has a unique index therefore
        // we need to avoid giving it an empty string.
        if (array_key_exists('foreign_key', $properties)
            && (strlen($properties['foreign_key']) == 0)
        ) {
            unset($properties['foreign_key']);
        }

        if (array_key_exists('display_name', $properties)
            && (strlen(cb_trim($properties['display_name'])) == 0)
        ) {
            cb_throw_error(E_COMMON_MISSING_MANDATORY);
        }

        return $this->_setProperties($this->getUserTable(), $id, $properties);
    }

    function changeUserPassword($id, $password)
    {
        $user = $this->getUser($id);
        if ( ! $user) {
            return false;
        }

        require_once('fw/passwd_util.csp');
        $hashed = CB_PasswordUtil::hashPassword($password);

        $user->_setPrivately('salt', $hashed['salt']);
        $user->_setPrivately('password', $hashed['hash']);
        $user->updateNow();

        return true;
    }

    function setUserHashedPassword($id, $password_salt, $password_hashed)
    {
        $user = $this->getUser($id);
        if ( ! $user) {
            return false;
        }

        require_once('fw/passwd_util.csp');

        $user->_setPrivately('salt', $password_salt);
        $user->_setPrivately('password', $password_hashed);
        $user->updateNow();

        return true;
    }

    function deleteActualUserData($id)
    {
        $user = $this->getUser($id, true);
        if ( ! $user) {
            return E_GRN_USER_NOT_FOUND;
        }

        $user->_deletePrivately();

        return GRN_UUM_DELETE_SUCCESS;
    }

    function removeUser($id)
    {
        $user = $this->getUser($id);
        if ( ! $user) {
            return false;
        }

        $timestamp = new CB_TimeStamp();
        $timestamp->unix_ts = time();

        $this->_setProperties($this->getUserTable(), $id,
            ['deleted' => $timestamp]);

        return true;
    }

    function restoreUser($id)
    {
        $user = $this->getUser($id, true);
        if ( ! $user) {
            return false;
        }

        $this->_setProperties($this->getUserTable(), $id, ['deleted' => null]);

        return true;
    }

    function orderUsers($ids)
    {
        $i = 0;
        foreach ($ids as $id) {
            $user = $this->getUser($id);
            if ($user === false) {
                continue;
            }

            $i = $i + 1;
            $user->_setPrivately('list_index', $i);
            $user->updateNow();
        }

        return true;
    }

    public function getFwFacade()
    {
        return new FwFacade($this->sandbox);
    }

    // Groups

    /**
     * @param  string $id
     * @param  bool   $isUseLocal
     *
     * @return bool|CB_Group|mixed
     */
    public function getGroup($id, $isUseLocal = true)
    {
        $groupTableInfo = $this->getGroupTable();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        if ($isUseLocal) {
            $i18n = CB_I18N::getInstance();
            $dataObj['language'] = $i18n->getCurrentLanguage();
        }

        $groupObj = $this->getFwFacade()->referGroupById($dataObj, $id);

        if ($groupObj == false) {
            return false;
        }

        $row = $groupTableInfo->getRow($groupObj->getId(),
            $groupObj->convertArray());

        return $row;
    }

    public function getGroupByForeignKey($key)
    {
        $i18n = CB_I18N::getInstance();
        $groupTableInfo = $this->getGroupTable();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();

        $dao = new FwFacade();
        $groupObj = $dao->referGroupByForeignKey($dataObj, $key);

        if ($groupObj == false) {
            return false;
        }

        $row = $groupTableInfo->getRow($groupObj->getId(),
            $groupObj->convertArray());

        return $row;
    }

    /**
     * @param string $key
     *
     * @return CB_Group  return FALSE if not exist
     */
    public function getGroupBySlashID($key)
    {
        return $this->getBySlashID($this->getGroupTable(), $key);
    }

    public function getGroupLocalListByGroupId_LanguageCodes(
        $inGroupId,
        $inExportLanguageCodeArray
    ) {
        $dao = new FwFacade();
        $dataObj = [];
        $resultList = $dao->getGroupLocalListByGroupId_LanguageCodes($dataObj,
            $inGroupId, $inExportLanguageCodeArray);

        return $resultList;
    }

    public function createMultiLanguageValuesArray($inGid)
    {
        $resultArray = [];

        $dao = $this->getFwFacade();

        $dataObj = [];
        $groupObj
            = $dao->referGroupById($dataObj,
            $inGid);
        $resultArray[CB_I18N_DEFUALT_LANGUAGE_CODE] = $groupObj->getName();

        $dataObj = [];
        $groupLocalList = $dao->getGroupLocalListByGroupId($dataObj, $inGid);
        foreach ($groupLocalList as $groupLocal) {
            $resultArray[$groupLocal->getLanguageCode()]
                = $groupLocal->getName();
        }

        return $resultArray;
    }

    /**
     * @param null $parentId
     * @param bool $isUseLocal
     *
     * @return CB_Group[]
     */
    public function getGroupListByParentId($parentId = null, $isUseLocal = true)
    {
        $i18n = CB_I18N::getInstance();
        $groupTableInfo = $this->getGroupTable();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();

        $dao = $this->getFwFacade();
        $groupObjList = ($isUseLocal) ? $dao->getGroupListByParentId($dataObj,
            $parentId)
            : $dao->getGroupListWithNonLocalByParentId($dataObj, $parentId);

        $results = [];
        foreach ($groupObjList as $groupObj) {
            /** @var CB_Group $row */
            $row = $groupTableInfo->getRow($groupObj->getId(),
                $groupObj->convertArray());
            $row->sandbox = $this->sandbox;
            $groupId = $row->getOID();

            $results[$groupId] = $row;
        }

        return $results;
    }

    /**
     * @param $user_id_list
     *
     * @return CbGroup[]
     */
    public function getGroupListByUserIds($user_id_list)
    {
        $i18n = CB_I18N::getInstance();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();

        return $this->getFwFacade()
                    ->getGroupListByUserIds($dataObj, $user_id_list);
    }

    public function getGroupList($inOffset, $inLimit)
    {
        $i18n = CB_I18N::getInstance();
        $groupTableInfo = $this->getGroupTable();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();
        $dataObj['offset'] = $inOffset;
        $dataObj['limit'] = $inLimit;

        $dao = new FwFacade();
        $groupObjList = $dao->getGroupList($dataObj);

        $results = [];
        foreach ($groupObjList as $groupObj) {
            $row = $groupTableInfo->getRow($groupObj->getId(),
                $groupObj->convertArray());
            $groupId = $row->getOID();

            $results[$groupId] = $row;
        }

        return $results;
    }

    public function getGroupListByIds($inGroupIdArray, $inOffset, $inLimit)
    {
        $i18n = CB_I18N::getInstance();
        $groupTableInfo = $this->getGroupTable();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();
        $dataObj['offset'] = $inOffset;
        $dataObj['limit'] = $inLimit;

        $dao = new FwFacade();
        $groupObjList = $dao->getGroupListByIds($dataObj, $inGroupIdArray);

        $results = [];
        foreach ($groupObjList as $groupObj) {
            $row = $groupTableInfo->getRow($groupObj->getId(),
                $groupObj->convertArray());
            $groupId = $row->getOID();

            $results[$groupId] = $row;
        }

        return $results;
    }

    /**
     * @param string[] $inGroupForeignKeyArray
     * @param bool     $inIsIn
     * @param int      $inOffset
     * @param int      $inLimit
     *
     * @return CB_Group[]
     */
    public function getGroupListByForeignKeys(
        $inGroupForeignKeyArray,
        $inIsIn,
        $inOffset,
        $inLimit
    ) {
        $i18n = CB_I18N::getInstance();
        $groupTableInfo = $this->getGroupTable();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();
        $dataObj['isIn'] = $inIsIn;
        $dataObj['offset'] = $inOffset;
        $dataObj['limit'] = $inLimit;

        $dao = new FwFacade();
        $groupObjList = $dao->getGroupListByForeignKeys($dataObj,
            $inGroupForeignKeyArray);

        $results = [];
        foreach ($groupObjList as $groupObj) {
            $row = $groupTableInfo->getRow($groupObj->getId(),
                $groupObj->convertArray());
            $groupId = $row->getOID();

            $results[$groupId] = $row;
        }

        return $results;
    }

    public function getGroupListByNames(
        $inGroupNameArray,
        $inIsAnd,
        $inOffset,
        $inLimit
    ) {
        $i18n = CB_I18N::getInstance();
        $groupTableInfo = $this->getGroupTable();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();
        $dataObj['isAnd'] = $inIsAnd;
        $dataObj['offset'] = $inOffset;
        $dataObj['limit'] = $inLimit;

        $dao = new FwFacade();
        $groupObjList = $dao->getGroupListByNames($dataObj, $inGroupNameArray);

        $results = [];
        foreach ($groupObjList as $groupObj) {
            $row = $groupTableInfo->getRow($groupObj->getId(),
                $groupObj->convertArray());
            $groupId = $row->getOID();

            $results[$groupId] = $row;
        }

        return $results;
    }

    public function getGroupInfo($id)
    {
        $i18n = CB_I18N::getInstance();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();

        $dao = $this->getFwFacade();
        $groupObj = $dao->referGroupById($dataObj, $id);

        if ($groupObj == false) {
            return false;
        }

        $result = [];
        $result['_id'] = $groupObj->getId();
        $result['col_foreign_key'] = $groupObj->getForeignKey();
        $result['col_name'] = $groupObj->getName();
        $result['col_parent'] = $groupObj->getParent();
        $result['col_mtime'] = $groupObj->getMtime();
        $result['col_description'] = $groupObj->getDescription();
        $result['col_list_index'] = $groupObj->getListIndex();

        return $result;
    }

    public function getGroupInfoByForeignKey($key)
    {
        $i18n = CB_I18N::getInstance();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();

        $groupObj = $this->getFwFacade()
                         ->referGroupByForeignKey($dataObj, $key);

        if ($groupObj == false) {
            return false;
        }

        $result = [];
        $result['_id'] = $groupObj->getId();
        $result['col_foreign_key'] = $groupObj->getForeignKey();
        $result['col_name'] = $groupObj->getName();
        $result['col_parent'] = $groupObj->getParent();
        $result['col_mtime'] = $groupObj->getMtime();
        $result['col_description'] = $groupObj->getDescription();
        $result['col_list_index'] = $groupObj->getListIndex();

        return $result;
    }

    public function getGroupInfoListByParentId(
        $parentId = null,
        $offset = 0,
        $limit = -1
    ) {
        $i18n = CB_I18N::getInstance();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();
        $dataObj['offset'] = $offset;
        $dataObj['limit'] = $limit;

        $dao = $this->getFwFacade();
        $groupObjList = $dao->getGroupListByParentId($dataObj, $parentId);

        $results = [];
        foreach ($groupObjList as $groupObj) {
            $groupId = $groupObj->getId();

            $dataArray = [];
            $dataArray['_id'] = $groupId;
            $dataArray['col_foreign_key'] = $groupObj->getForeignKey();
            $dataArray['col_name'] = $groupObj->getName();
            $dataArray['col_parent'] = $groupObj->getParent();
            $dataArray['col_mtime'] = $groupObj->getMtime();
            $dataArray['col_description'] = $groupObj->getDescription();
            $dataArray['col_list_index'] = $groupObj->getListIndex();

            $results[$groupId] = $dataArray;
        }

        return $results;
    }

    public function getGroupInfoList($inOffset, $inLimit)
    {
        $i18n = CB_I18N::getInstance();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();
        $dataObj['offset'] = $inOffset;
        $dataObj['limit'] = $inLimit;

        $groupObjList = $this->getFwFacade()->getGroupList($dataObj);

        $results = [];
        foreach ($groupObjList as $groupObj) {
            $groupId = $groupObj->getId();

            $dataArray = [];
            $dataArray['_id'] = $groupId;
            $dataArray['col_foreign_key'] = $groupObj->getForeignKey();
            $dataArray['col_name'] = $groupObj->getName();
            $dataArray['col_parent'] = $groupObj->getParent();
            $dataArray['col_mtime'] = $groupObj->getMtime();
            $dataArray['col_description'] = $groupObj->getDescription();
            $dataArray['col_list_index'] = $groupObj->getListIndex();

            $results[$groupId] = $dataArray;
        }

        return $results;
    }

    public function getGroupInfoListByIds($inGroupIdArray, $inOffset, $inLimit)
    {
        $i18n = CB_I18N::getInstance();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();
        $dataObj['offset'] = $inOffset;
        $dataObj['limit'] = $inLimit;

        $groupObjList = $this->getFwFacade()
                             ->getGroupListByIds($dataObj, $inGroupIdArray);

        $results = [];
        foreach ($groupObjList as $groupObj) {
            $groupId = $groupObj->getId();

            $dataArray = [];
            $dataArray['_id'] = $groupId;
            $dataArray['col_foreign_key'] = $groupObj->getForeignKey();
            $dataArray['col_name'] = $groupObj->getName();
            $dataArray['col_parent'] = $groupObj->getParent();
            $dataArray['col_mtime'] = $groupObj->getMtime();
            $dataArray['col_description'] = $groupObj->getDescription();
            $dataArray['col_list_index'] = $groupObj->getListIndex();

            $results[$groupId] = $dataArray;
        }

        return $results;
    }

    public function getGroupInfoListByNames(
        $inGroupNameArray,
        $inIsAnd,
        $inOffset,
        $inLimit
    ) {
        $i18n = CB_I18N::getInstance();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();
        $dataObj['isAnd'] = $inIsAnd;
        $dataObj['offset'] = $inOffset;
        $dataObj['limit'] = $inLimit;

        $dao = new FwFacade();
        $groupObjList = $dao->getGroupListByNames($dataObj, $inGroupNameArray);

        $results = [];
        foreach ($groupObjList as $groupObj) {
            $groupId = $groupObj->getId();

            $dataArray = [];
            $dataArray['_id'] = $groupId;
            $dataArray['col_foreign_key'] = $groupObj->getForeignKey();
            $dataArray['col_name'] = $groupObj->getName();
            $dataArray['col_parent'] = $groupObj->getParent();
            $dataArray['col_mtime'] = $groupObj->getMtime();
            $dataArray['col_description'] = $groupObj->getDescription();
            $dataArray['col_list_index'] = $groupObj->getListIndex();

            $results[$groupId] = $dataArray;
        }

        return $results;
    }

    public function getUserGroupInfoListByUserIds(
        $inUserIdArray,
        $inIncludeDeleted,
        $inOffset,
        $inLimit
    ) {
        $i18n = CB_I18N::getInstance();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();
        $dataObj['isAliveUser'] = $inIncludeDeleted ? false : true;
        $dataObj['offset'] = $inOffset;
        $dataObj['limit'] = $inLimit;

        $dao = $this->getFwFacade();
        $groupObjList = $dao->getGroupListByUserIds($dataObj, $inUserIdArray);

        $results = [];
        foreach ($groupObjList as $groupObj) {
            $uid = $groupObj->getUserId();
            $groupId = $groupObj->getId();

            $dataArray = [];
            $dataArray['_id'] = $groupId;
            $dataArray['col_foreign_key'] = $groupObj->getForeignKey();
            $dataArray['col_name'] = $groupObj->getName();
            $dataArray['col_parent'] = $groupObj->getParent();
            $dataArray['col_mtime'] = $groupObj->getMtime();
            $dataArray['col_description'] = $groupObj->getDescription();
            $dataArray['col_list_index'] = $groupObj->getListIndex();

            $results[$uid][$groupId] = $dataArray;
        }

        return $results;
    }

    public function getGroupInfoListByForeignKeys(
        $inGroupForeignKeyArray,
        $inIsIn,
        $inOffset,
        $inLimit
    ) {
        $i18n = CB_I18N::getInstance();

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();
        $dataObj['isIn'] = $inIsIn;
        $dataObj['offset'] = $inOffset;
        $dataObj['limit'] = $inLimit;

        $dao = new FwFacade();
        $groupObjList = $dao->getGroupListByForeignKeys($dataObj,
            $inGroupForeignKeyArray);

        $results = [];
        foreach ($groupObjList as $groupObj) {
            $groupId = $groupObj->getId();

            $dataArray = [];
            $dataArray['_id'] = $groupId;
            $dataArray['col_foreign_key'] = $groupObj->getForeignKey();
            $dataArray['col_name'] = $groupObj->getName();
            $dataArray['col_parent'] = $groupObj->getParent();
            $dataArray['col_mtime'] = $groupObj->getMtime();
            $dataArray['col_description'] = $groupObj->getDescription();
            $dataArray['col_list_index'] = $groupObj->getListIndex();

            $results[$groupId] = $dataArray;
        }

        return $results;
    }

    /**
     * @return int
     */
    public function countGroup()
    {
        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;

        $groupCount = $this->getFwFacade()->countGroup($dataObj);

        return $groupCount;
    }

    /**
     * @param      $properties
     * @param null $id
     *
     * @return CB_Row
     */
    public function addGroup($properties, $id = null)
    {
        require_once('fw/string_util.csp');

        // unset foreign_key since it has a unique index therefore
        // we need to avoid giving it an empty string.
        if (array_key_exists('foreign_key', $properties)
            && (strlen($properties['foreign_key']) == 0)
        ) {
            unset($properties['foreign_key']);
        }

        if (( ! array_key_exists('name', $properties))
            || (strlen(cb_trim($properties['name'])) == 0)
        ) {
            cb_throw_error(E_COMMON_MISSING_MANDATORY);
        }

        $group = $this->_add($this->getGroupTable(), $properties, $id);

        // run triggers
        $this->_loadHook('addTriggerOnAddGroup', 'add_group_');
        $this->_runHook($this->_add_group_triggers, $group);

        return $group;
    }

    /**
     * @param CB_Group $inChildObj
     * @param int      $parentId
     * @param bool     $sync
     *
     * @return bool
     */
    public function setParentGroup($inChildObj, $parentId, $sync = false)
    {
        $parentObj = null;
        if (is_null($parentId) || ($parentId === false)) {
            $parentId = null;
            $parentObj = null;
        } else {
            $parentObj = $this->getGroup($parentId);

            if ($parentObj === false) {
                return false;
            }
        }

        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;

        $dao = new FwFacade();
        $groupCount = $dao->countGroupByParentId($dataObj, $parentId);
        $lastIdx = $groupCount + 1;

        $inChildObj->_setPrivately('list_index', $lastIdx);
        $inChildObj->_setPrivately('parent', $parentObj);
        $inChildObj->updateNow();

        return true;
    }

    public function validateGroupInfo($properties)
    {
        require_once('fw/string_util.csp');

        // unset foreign_key since it has a unique index therefore
        // we need to avoid giving it an empty string.
        if (array_key_exists('foreign_key', $properties)
            && (strlen($properties['foreign_key']) == 0)
        ) {
            unset($properties['foreign_key']);
        }

        if (array_key_exists('name', $properties)
            && (strlen(cb_trim($properties['name'])) == 0)
        ) {
            cb_throw_error(E_COMMON_MISSING_MANDATORY);
        }
    }

    /**
     * @param $id
     * @param $properties
     *
     * @return bool
     */
    public function setGroupProperties($id, $properties)
    {
        $this->validateGroupInfo($properties);

        return $this->_setProperties($this->getGroupTable(), $id, $properties);
    }

    /**
     * @param int $id
     *
     * @return bool
     */
    function removeGroup($id)
    {
        $group = $this->getGroup($id);
        if ( ! $group) {
            return false;
        }

        // run triggers recursively
        $this->_loadHook('addTriggerOnRemoveGroup', 'remove_group_');
        $this->_runHook($this->_remove_group_triggers, $group);

        $group->_deletePrivately();

        return true;
    }

    /**
     * @param int   $uid
     * @param int[] $gids
     *
     * @return bool
     */
    function setUserGroups($uid, $gids)
    {
        $table = $this->_getUserGroupTable();

        $user = $this->getUser($uid);
        if ( ! $user) {
            return false;
        }

        $rowset = new CB_RowSet($table);
        $rowset->addCondition('col_user=' . $user->getOID());
        /** @var CB_Group[] $g_oids */
        $g_oids = [];
        while ( ! is_null($row = $rowset->iterate())) {
            $group = $row->get('group');
            $g_oids[$group->getOID()] = $row;
        }

        $lidx = 0;
        foreach ($gids as $gid) {
            $group = $this->getGroup($gid);
            if ( ! $group) {
                continue;
            }

            $row = null;
            if (array_key_exists($group->getOID(), $g_oids)) {
                $row = $g_oids[$group->getOID()];
                unset($g_oids[$group->getOID()]);
            } else {
                /** @var CB_Group $row */
                $row = $table->_newRow();
                $row->_setPrivately('user', $user);
                $row->_setPrivately('group', $group);
            }

            $lidx = $lidx + 1;
            $row->_setPrivately('group_list', $lidx);
            $row->updateNow();
        }

        // delete relations that are not contained by $gids
        foreach (array_keys($g_oids) as $g) {
            $row = $g_oids[$g];
            $row->_deletePrivately();
        }

        return true;
    }

    /**
     * @param int   $gid
     * @param int[] $uids
     *
     * @return bool
     */
    function setGroupUsers($gid, $uids)
    {
        $table = $this->_getUserGroupTable();

        $group = $this->getGroup($gid);
        if ( ! $group) {
            return false;
        }

        $rowset = new CB_RowSet($table);
        $rowset->addCondition('col_group=' . $group->getOID());
        $u_oids = [];
        while ( ! is_null($row = $rowset->iterate())) {
            $user = $row->get('user');
            $u_oids[$user->getOID()] = $row;
        }

        $lidx = 0;
        foreach ($uids as $uid) {
            $user = $this->getUser($uid);
            if ( ! $user) {
                continue;
            }

            $row = null;
            if (array_key_exists($user->getOID(), $u_oids)) {
                $row = $u_oids[$user->getOID()];
                unset($u_oids[$user->getOID()]);
            } else {
                /** @var CB_Group $row */
                $row = $table->_newRow();
                $row->_setPrivately('user', $user);
                $row->_setPrivately('group', $group);
            }

            $lidx = $lidx + 1;
            $row->_setPrivately('user_list', $lidx);
            $row->updateNow();
        }

        // delete relations that are not contained by $uids
        foreach (array_keys($u_oids) as $u) {
            $row = $u_oids[$u];
            $row->_deletePrivately();
        }

        return true;
    }

    /**
     * @param      $inOrgId
     * @param      $inLocalNameArray
     * @param bool $sync
     *
     * @return bool
     */
    public function addGroupLocals($inOrgId, $inLocalNameArray, $sync = false)
    {
        require_once('fw/bean/CbGroupLocal.csp');
        $facade = $this->getFwFacade();

        $i18n = CB_I18N::getInstance();
        $availableLanguageArray = $i18n->getAvailableLanguages();
        foreach ($availableLanguageArray as $languageKey) {
            if ((array_key_exists($languageKey, $inLocalNameArray))
                && (strlen(cb_trim($inLocalNameArray[$languageKey])) > 0)
            ) {
                $localName = cb_trim($inLocalNameArray[$languageKey]);

                $dataObj = [];
                $dataObj["sync"] = $sync;
                $groupLocal = new CbGroupLocal();
                $groupLocal->setParentId($inOrgId);
                $groupLocal->setLanguageCode($languageKey);
                $groupLocal->setName($localName);

                $facade->insertGroupLocal($dataObj, $groupLocal);
            }
        }

        return true;
    }

    /**
     * @param      $inOrgId
     * @param      $inLocalNameArray
     *
     * @param bool $sync
     *
     * @return bool
     */
    public function modifyGroupLocals(
        $inOrgId,
        $inLocalNameArray,
        $sync = false
    ) {
        require_once('fw/bean/CbGroupLocal.csp');
        $dao = $this->getFwFacade();

        $i18n = CB_I18N::getInstance();
        $availableLanguageArray = $i18n->getAvailableLanguages();
        foreach ($availableLanguageArray as $languageKey) {
            if ((array_key_exists($languageKey, $inLocalNameArray))
                && (strlen(cb_trim($inLocalNameArray[$languageKey])) > 0)
            ) {
                $localName = cb_trim($inLocalNameArray[$languageKey]);

                $dataObj = [];
                $dataObj["sync"] = $sync;
                $groupLocal = new CbGroupLocal();
                $groupLocal->setParentId($inOrgId);
                $groupLocal->setLanguageCode($languageKey);
                $groupLocal->setName($localName);

                $dao->updateGroupLocal($dataObj, $groupLocal);
            } else {
                $dataObj = [];
                $dataObj["sync"] = $sync;
                $groupLocal = new CbGroupLocal();
                $groupLocal->setParentId($inOrgId);
                $groupLocal->setLanguageCode($languageKey);

                $dao->deleteGroupLocal($dataObj, $groupLocal);
            }
        }

        return true;
    }

    public function importGroupNameWithCSV(
        $inOperator,
        $inFilePath,
        $inCharset,
        $inSkipLineCount = 0
    ) {
        if ( ! $inCharset) {
            global $G_config_common;
            $inCharset = $G_config_common->get('I18N',
                'default_external_encoding');
        }

        require_once('fw/csv.csp');
        $csv = new CB_CSVReader($inCharset, $inFilePath);

        // 
        for ($i = 0; $i < $inSkipLineCount; ++$i) {
            $csv->readLine();
        }

        require_once('grn/org_privilege.csp');
        $logic = GRN_OrganizationPrivilegeLogic::getInstance();

        require_once('fw/bean/CbGroupLocal.csp');
        $dao = new FwFacade();
        $dataObj = [];
        $dataObj['messageTypeAdd'] = 'group_local_add_import';
        $dataObj['messageTypeModify'] = 'group_local_modify_import';
        $dataObj['messageTypeDelete'] = 'group_local_delete_import';

        $i18n = CB_I18N::getInstance();
        $groupTableInfo = $this->getGroupTable();
        $groupDataObj = [];
        $groupDataObj['lock'] = $groupTableInfo->_lock;
        $groupDataObj['language'] = $i18n->getCurrentLanguage();
        $availableLanguageArray = $i18n->getAvailableLanguages();

        while (($line = $csv->readLine()) !== false) {
            //ID
            if (is_null($line[0]) || (strlen($line[0]) <= 0)) {
                continue;
            }
            $groupObj = $dao->referGroupByForeignKey($groupDataObj, $line[0]);
            if ($groupObj === false) {
                continue;
            }

            //
            $gorupRow = $this->getGroupTable()->getRow($groupObj->getId(),
                $groupObj->convertArray());
            if ($logic->isPrivileged($inOperator, $gorupRow) === false) {
                continue;
            }

            if ( ! in_array($line[1], $availableLanguageArray)) {
                cb_throw_error(E_COMMON_CSV_LANGUAGE_CODE_INVALID);
            }
            //
            $groupLocal = new CbGroupLocal();
            $groupLocal->setParentId($groupObj->getId());
            $groupLocal->setLanguageCode($line[1]);
            $groupLocal->setName(cb_trim($line[2]));

            if (is_null($groupLocal->getName())
                || (strlen($groupLocal->getName()) <= 0)
            ) {
                $dao->deleteGroupLocal($dataObj, $groupLocal);
            } else {
                $dao->updateGroupLocal($dataObj, $groupLocal);
            }
        }

        $csv->close();

        return true;
    }

    public function createGroupNameCSV(
        $inOperator,
        $inCharset,
        $inIsExportHeader,
        $inExportLanguageCodeArray = null
    ) {
        /// 
        $tempdir = cb_tmpdir();
        $tempFilename = tempnam($tempdir, 'sys_group_');
        require_once('fw/csv.csp');
        $csv = new CB_CSVWriter($inCharset, $tempFilename);

        // 
        if ($inIsExportHeader) {
            $header = [];
            $header[] = cb_msg('grn.common', 'organization_code');
            $header[] = cb_msg('grn.common', 'language_code');
            $header[] = cb_msg('grn.common', 'organization_name');

            $csv->writeLine($header);
        }

        require_once('fw/inspection.csp');
        $inspection = CB_Group_Local_Inspection::getInstance();

        require_once('grn/org_privilege.csp');
        $logic = GRN_OrganizationPrivilegeLogic::getInstance();

        // ()
        $rootGroupList = ($logic->isAdmin()) ? $this->getGroupListByParentId()
            : $logic->getRootGroupsWithAuthority($inOperator);
        foreach (array_keys($rootGroupList) as $rootGroupId) {
            $this->_writeGroupNameRecursive($csv, $inspection, $rootGroupId,
                $inExportLanguageCodeArray);
        }

        $csv->close();

        return $tempFilename;
    }

    private function _writeGroupNameRecursive(
        $inCsv,
        $inInspection,
        $inGroupId,
        $inExportLanguageCodeArray
    ) {
        // 
        $groupLocalList
            = $this->getGroupLocalListByGroupId_LanguageCodes($inGroupId,
            $inExportLanguageCodeArray);
        foreach ($groupLocalList as $groupLocal) {
            $line = [];
            $line[0] = $groupLocal->getParentCode();
            $line[1] = $groupLocal->getLanguageCode();
            $line[2] = $groupLocal->getName();
            $inCsv->writeLine($line);

            //Check Inspection Message Enabled
            if ($inInspection->isEnabled()) {
                //Write Inspection Message
                $message_type = 'group_local_export';
                $message_args = [
                    'gid'          => $groupLocal->getParentId(),
                    'languageCode' => $groupLocal->getLanguageCode(),
                    'group_name'   => $groupLocal->getName()
                ];
                $inInspection->record($message_type, $message_args);
            }
        }

        //
        $childGroupList = $this->getGroupListByParentId($inGroupId);
        foreach (array_keys($childGroupList) as $childGroupId) {
            $this->_writeGroupNameRecursive($inCsv, $inInspection,
                $childGroupId, $inExportLanguageCodeArray);
        }
    }

    // Roles

    /**
     * @access private
     */
    function _isValidRole($key)
    {
        static $system_roles = null;

        if (is_null($system_roles)) {
            $system_roles = [
                'Everyone'    => 1,
                'LoginUser'   => 1,
                'CommandLine' => 1
            ];
        }

        return array_key_exists($key, $system_roles) ? false : true;
    }

    function getStaticRole($id)
    {
        $table = $this->getRoleTable();
        $table->setLock(CB_DATABASE_NO_LOCK);
        $role = $table->getRow($id);

        return $role;
    }

    function getStaticRoleByForeignKey($key)
    {
        $role = $this->_getByForeignKey($this->getRoleTable(), $key);

        return $role;
    }

    /**
     * @param string $slashId
     *
     * @return CB_Role
     */
    public function getStaticRoleBySlashId($slashId)
    {
        return $this->getBySlashID($this->getRoleTable(), $slashId);
    }

    function addStaticRole($properties, $id = null)
    {
        require_once('fw/string_util.csp');

        if (( ! array_key_exists('foreign_key', $properties))
            || (strlen(cb_trim($properties['foreign_key'])) == 0)
        ) {
            cb_throw_error(E_COMMON_MISSING_MANDATORY);
        }

        if ( ! $this->_isValidRole($properties['foreign_key'])) {
            cb_throw_error(E_COMMON_INVALID_ROLEKEY);
        }

        $role = $this->_add($this->getRoleTable(), $properties, $id);

        // run triggers
        $this->_loadHook('addTriggerOnAddStaticRole', 'add_role_');
        $this->_runHook($this->_add_role_triggers, $role);

        return $role;
    }

    function setStaticRoleProperties($id, $properties)
    {
        require_once('fw/string_util.csp');

        if (array_key_exists('foreign_key', $properties)
            && (strlen(cb_trim($properties['foreign_key'])) == 0)
        ) {
            cb_throw_error(E_COMMON_MISSING_MANDATORY);
        }

        if ( ! $this->_isValidRole($properties['foreign_key'])) {
            cb_throw_error(E_COMMON_INVALID_ROLEKEY);
        }

        $role = $this->getStaticRole($id);
        if ( ! $role) {
            return false;
        }

        foreach ($properties as $k => $v) {
            $role->_setPrivately($k, $v);
        }
        $role->updateNow();

        return true;
    }

    function removeStaticRole($id)
    {
        $role = $this->getStaticRole($id);
        if ( ! $role) {
            return false;
        }

        // run triggers
        $this->_loadHook('addTriggerOnRemoveStaticRole', 'remove_role_');
        $this->_runHook($this->_remove_role_triggers, $role);

        $role->_deletePrivately();

        return true;
    }

    function orderStaticRoles($ids)
    {
        $i = 0;
        foreach ($ids as $id) {
            $role = $this->getStaticRole($id);
            if ( ! $role) {
                continue;
            }

            $i = $i + 1;
            $role->_setPrivately('list_index', $i);
            $role->updateNow();
        }

        return true;
    }

    function setUserRoles($uid, $role_ids)
    {
        $table = $this->_getUserRoleTable();

        $user = $this->getUser($uid);
        if ( ! $user) {
            return false;
        }

        $rowset = new CB_RowSet($table);
        $rowset->addCondition('col_user=' . $user->getOID());
        $r_oids = [];
        while ( ! is_null($row = $rowset->iterate())) {
            $role = $row->get('role');
            $r_oids[$role->getOID()] = $row;
        }

        $lidx = 0;
        foreach ($role_ids as $role_id) {
            $role = $this->getStaticRole($role_id);
            if ( ! $role) {
                continue;
            }

            $row = null;
            if (array_key_exists($role->getOID(), $r_oids)) {
                $row = $r_oids[$role->getOID()];
                unset($r_oids[$role->getOID()]);
            } else {
                /** @var CB_Role $row */
                $row = $table->_newRow();
                $row->_setPrivately('user', $user);
                $row->_setPrivately('role', $role);
            }

            $lidx = $lidx + 1;
            $row->_setPrivately('role_list', $lidx);
            $row->updateNow();
        }

        // delete relations that are not contained by $roles
        foreach (array_keys($r_oids) as $r) {
            $row = $r_oids[$r];
            $row->_deletePrivately();
        }

        return true;
    }

    /**
     * @param CB_User $user
     *
     * @return CB_Role[]
     */
    public function getUserRoles(CB_User $user)
    {
        $roleInfos = $this->getFwFacade()->getRolesByUserId($user->getOID());
        $cbRoles = [];
        foreach ($roleInfos as $roleInfo) {
            $cbRoles[$roleInfo['_id']] = $this->getRoleTable()
                                              ->_getRow($roleInfo["_id"],
                                                  $roleInfo);
        }

        return $cbRoles;
    }

    /**
     * @param CB_TableInfo $table
     * @param              $key
     *
     * @return bool|CB_Row
     */
    private function _getByForeignKey($table, $key)
    {
        $rowset = new CB_RowSet($table);
        $db = $table->getDBConnection();
        $key = $db->escape($key);
        $rowset->addCondition("col_foreign_key='${key}'");
        if (strcmp($table->getTableName(), 'cb_user') === 0) {
            $rowset->addCondition('tab_cb_user.col_deleted IS NULL');
        }
        $rowset->setLock(CB_DATABASE_NO_LOCK);
        $row = $rowset->iterate();
        $rowset->destroy();

        if ( ! $row) {
            $row = false;
        }

        return $row;
    }

    /**
     * @param CB_TableInfo $table
     * @param string       $key
     *
     * @return CB_Row       return FALSE if not exist
     */
    private function getBySlashID($table, $key)
    {
        $rowset = new CB_RowSet($table);
        $db = $table->getDBConnection();
        $key = $db->escape($key);
        $rowset->addCondition("col_slash='{$key}'");
        $rowset->setLock(CB_DATABASE_NO_LOCK);
        $row = $rowset->iterate();
        $rowset->destroy();

        if ( ! $row) {
            $row = false;
        }

        return $row;
    }

    /**
     * @param CB_TableInfo $table
     * @param              $properties
     * @param              $oid
     *
     * @return CB_Row
     */
    function _add($table, $properties, $oid)
    {
        $row = $table->_newRow($oid);

        foreach ($properties as $key => $value) {
            $row->_setPrivately($key, $value);
        }
        $row->registerNow();

        return $row;
    }

    /**
     * @param CB_TableInfo $table
     * @param              $id
     * @param              $properties
     *
     * @return bool
     */
    function _setProperties($table, $id, $properties)
    {
        $row = $table->getRow($id);
        if ( ! $row) {
            return false;
        }

        foreach ($properties as $key => $value) {
            $row->_setPrivately($key, $value);
        }
        $row->updateNow();

        return true;
    }
}


