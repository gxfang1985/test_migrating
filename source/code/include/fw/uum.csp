<?php

use grn\system\sandbox\SandboxConstants;

/**
 * Unified User Management API.
 *
 * @package fw.uum
 */

require_once('fw/uum_core.csp');  // Core modules
require_once('fw/uum_spi.csp');   // Service Provider Interface
require_once('fw/module.csp');

/**
 * Uum API.
 *
 * @package fw.uum
 */
class CB_Uum extends CB_ModuleBase
{
    // cached table objects
    /**
     * @access private
     * @var \CB_UumCoreAPI
     */
    var $_core;             // core API
    /**
     * @access private
     * @var GRN_UumDefaultServiceProvider
     */
    var $_sp;               // service provider
    /**
     * @access private
     * @var CB_DatabaseConnection
     */
    var $_dbconn;

    private static $_user_groups_cache = [];

    protected $sandbox = SandboxConstants::NO_SANDBOX_MODE;

    /**
     * @access private
     */
    function __construct()
    {
        parent::__construct('fw.uum');

        global $G_container_base;

        $this->_core = CB_UumCoreAPI::getInstance();
        $this->_sp = $G_container_base->getInstance('uum_sp');
        $this->_dbconn = $G_container_base->getInstance('dbconn');
    }

    function setServiceProvider($sp)
    {
        $this->_sp = $sp;
    }

    //// Standard API ////

    /**
     * Return the instance of {@link CB_TableInfo} for {@link CB_User} table.
     *
     * @return CB_TableInfo  CB_User table.
     */
    function getUserTable()
    {
        $ret = $this->_core->getUserTable();

        return $ret;
    }

    /**
     * Return the instance of {@link CB_TableInfo} for {@link CB_Group} table.
     *
     * @return CB_TableInfo  CB_Group table.
     */
    public function getGroupTable()
    {
        $table = $this->_core->getGroupTable();

        return $table;
    }


    /**
     * Return the instance of {@link CB_TableInfo} for {@link CB_Role} table.
     *
     * @return CB_TableInfo
     */
    function getRoleTable()
    {
        $table = $this->_core->getRoleTable();

        return $table;
    }


    /**
     * @access protected
     * @return CB_TableInfo
     */
    function _getUserGroupTable()
    {
        $table = $this->_core->_getUserGroupTable();

        return $table;
    }

    /**
     * @access protected
     * @return CB_TableInfo
     */
    function _getUserRoleTable()
    {
        $table = $this->_core->_getUserRoleTable();

        return $table;
    }


    /**
     * Login as the specified user.
     *
     * @param CB_User $user
     */
    function loginAs($user)
    {
        $this->_sp->loginAs($user);
    }

    /**
     * Logout will discrad all granted roles in the current session.
     */
    function logout()
    {
        $this->_sp->logout();
    }

    /**
     * @return CB_User|bool  {@link CB_User} object, or FALSE if the user has
     *                       not been logged in.
     */
    function getLoginUser()
    {
        $user = $this->_sp->getLoginUser();

        return $user;
    }

    /**
     * Return an array of roles that have been granted to the current session.
     * Roles are keys of the array.  For example, the array to be returned
     * may look like:
     * array('LoginUser'=>1, 'Everyone'=>1, ...) .
     *
     * @param  bool $nocache
     *
     * @return array
     */
    function listGrantedRoles($nocache = false)
    {
        static $cache_roles = null;

        if ( ! is_null($cache_roles)) {
            return $cache_roles;
        }

        $roles = $this->_sp->listGrantedRoles();
        $roles['Everyone'] = 1;

        global $G_state_set;
        if ($G_state_set->get('command_line')) {
            $roles['CommandLine'] = 1;
        }

        if ( ! $nocache) {
            $cache_roles = $roles;
        }

        return $roles;
    }

    function requireRole($role_keys)
    {
        if (in_array('Everyone', $role_keys)) {
            return;
        }

        // Handle command-line case specially to avoid using sessions.
        global $G_state_set;
        if ($G_state_set->get('command_line')) {
            if (in_array('CommandLine', $role_keys)) {
                return;
            }

            if ($G_state_set->get('test_mode')) {
                return;
            }

            $role = implode(' or ', $role_keys);
            cb_throw_error(E_COMMON_ACCESS_DENIED, null, ['role' => $role]);
        }

        $roles = $this->listGrantedRoles(true);
        foreach ($role_keys as $role_key) {
            if (array_key_exists($role_key, $roles)) {
                return;
            }
        }

        foreach ($role_keys as $role_key) {
            if ($this->_sp->requireRole($role_key)) {
                return;
            }
        }

        $role = implode(' or ', $role_keys);
        cb_throw_error(E_COMMON_ACCESS_DENIED, null, ['role' => $role]);
    }

    /**
     * @param string $id
     * @param bool   $include_deleted
     *
     * @return CB_User|false
     */
    function getUser($id, $include_deleted = false)
    {
        $user = $this->_core->getUser($id, $include_deleted);

        return $user;
    }

    /**
     * @param string $key
     *
     * @return CB_User|bool
     */
    function getUserByForeignKey($key)
    {
        $user = $this->_core->getUserByForeignKey($key);

        return $user;
    }

    /**
     * @param string $key
     *
     * @return CB_User  return FALSE if not exist
     */
    public function getUserBySlashID($key)
    {
        return $this->_core->getUserBySlashID($key);
    }

    /**
     * @param string $id
     * @param bool   $isUseLocal
     *
     * @return CB_Group
     */
    public function getGroup($id, $isUseLocal = true)
    {
        if (is_null($id) || (strlen($id) <= 0)) {
            return false;
        }

        $group = $this->_core->getGroup($id, $isUseLocal);

        return $group;
    }

    public function getGroupByForeignKey($key)
    {
        $group = $this->_core->getGroupByForeignKey($key);

        return $group;
    }

    /**
     * @param string $key
     *
     * @return CB_Group  return FALSE if not exist
     */
    public function getGroupBySlashID($key)
    {
        return $this->_core->getGroupBySlashID($key);
    }

    public function getGroupLocalListByGroupId_LanguageCodes(
        $inGroupId,
        $inExportLanguageCodeArray
    ) {
        $result
            = $this->_core->getGroupLocalListByGroupId_LanguageCodes($inGroupId,
            $inExportLanguageCodeArray);

        return $result;
    }

    /**
     * @param $user_id_list
     *
     * @return CbGroup[]
     */
    public function getGroupListByUserIds($user_id_list)
    {
        $result = $this->_core->getGroupListByUserIds($user_id_list);

        return $result;
    }

    public function createMultiLanguageValuesArray($inGid)
    {
        $result = $this->_core->createMultiLanguageValuesArray($inGid);

        return $result;
    }

    /**
     * @param $id
     *
     * @return CB_Role
     */
    function getStaticRole($id)
    {
        $role = $this->_core->getStaticRole($id);

        return $role;
    }

    function getStaticRoleByForeignKey($key)
    {
        $role = $this->_core->getStaticRoleByForeignKey($key);

        return $role;
    }

    /**
     * @param string $slashId
     *
     * @return CB_Role
     */
    public function getStaticRoleBySlashId($slashId)
    {
        return $this->_core->getStaticRoleBySlashId($slashId);
    }

    /**
     * @param string $uid
     *
     * @return CB_Group[]|bool
     */
    function getUserGroups($uid)
    {
        $user = $this->getUser($uid);
        if ( ! $user) {
            return false;
        }

        if (array_key_exists($uid, self::$_user_groups_cache)) {
            return self::$_user_groups_cache[$uid];
        }

        require_once('fw/i18n.csp');
        $i18n = CB_I18N::getInstance();
        $dataObj = [];
        $dataObj['lock'] = CB_DATABASE_NO_LOCK;
        $dataObj['language'] = $i18n->getCurrentLanguage();
        $dataObj['orderByType'] = 'relation';

        $groups = [];
        $groupBeans = $this->_core->getFwFacade()
                                  ->getGroupListByUserIds($dataObj, [$uid]);
        foreach ($groupBeans as $groupBean) {
            $groups[$groupBean->getId()] = $this->getGroupTable()->_getRow(
                $groupBean->getId(), $groupBean->convertArray()
            );
        }

        return $groups;
    }

    /**
     * @param int[] $userIds
     */
    public function loadAndCacheUserGroups($userIds)
    {
        $query
            = " SELECT tab_cb_group.*, tab_cb_usergrouprelation.col_user AS userId, tab_cb_usergrouprelation.col_group AS groupId"
              . " FROM tab_cb_group"
              . " INNER JOIN tab_cb_usergrouprelation"
              . " ON tab_cb_group._id = tab_cb_usergrouprelation.col_group"
              . " WHERE"
              . $this->_dbconn->format(" col_user IN (@A) /** CB_Uum::loadAndCacheUserGroups */",
                [$userIds])
              . " ORDER BY col_group_list, _id";
        foreach ($userIds as $userId) {
            self::$_user_groups_cache[$userId] = [];
        }
        $result = $this->_dbconn->query($query);
        while ($row = $this->_dbconn->fetch_assoc($result)) {
            self::$_user_groups_cache[$row["userId"]][$row["groupId"]]
                = $this->getGroupTable()->getRow($row["groupId"], $row);
        }
        $this->_dbconn->free_result($result);
    }

    function getGroupUsers($gid)
    {
        $group = $this->getGroup($gid);
        if ( ! $group) {
            return false;
        }

        $db = $this->_dbconn;
        $gid = $db->escape($gid);

        $rowset = new CB_RowSet($this->_getUserGroupTable());
        $rowset->addCondition('col_group="' . $gid . '"');
        $on
            = 'tab_cb_usergrouprelation.col_user = tab_cb_user._id AND tab_cb_user.col_deleted IS NULL';
        $rowset->addJoin($this->getUserTable(), $on, CB_DATABASE_INNER_JOIN);
        $rowset->addOrderColumn('col_user_list');
        $rowset->setLock(CB_DATABASE_NO_LOCK);

        $users = [];
        while ( ! is_null($row = $rowset->iterate())) {
            $user = $row->get('user');
            $users[$user->getOID()] = clone $user;
        }

        return $users;
    }

    /**
     * Return static roles granted to the named user.
     * The return value will be an array that has OIDs as keys
     * and the CB_Role objects as values, i.e.,
     * array( '1'=> $role1, '2'=> $role2, ... )
     *
     * @param  string $uid
     *
     * @return CB_Role[]|FALSE
     *  CB_Role : if $uid is valid.
     *  FALSE  : if $uid is not valid.
     */
    function getUserRoles($uid)
    {
        $user = $this->getUser($uid);
        if ( ! $user) {
            return false;
        }

        return $this->_core->getUserRoles($user);
    }

    /**
     * Return an array of users who has the named static role.
     *
     * The array to be returned will look like:
     *  array( UID1 => $user1, UID2 => $user2, ... )
     *
     * @param  string $role_id
     *
     * @return array|bool Return FALSE if the role does not exist.
     */
    function getRoleUsers($role_id)
    {
        $role = $this->getStaticRole($role_id);
        if ( ! $role) {
            return false;
        }

        $rowset = new CB_RowSet($this->_getUserRoleTable());
        $rowset->addCondition('col_role=' . $role->getOID());
        $on
            = 'tab_cb_userrolerelation.col_user = tab_cb_user._id AND tab_cb_user.col_deleted IS NULL';
        $rowset->addJoin($this->getUserTable(), $on, CB_DATABASE_INNER_JOIN);
        $rowset->setLock(CB_DATABASE_NO_LOCK);

        $users = [];
        while ( ! is_null($row = $rowset->iterate())) {
            $user = $row->get('user');
            $users[$user->getOID()] = $user;
        }

        return $users;
    }

    /**
     * Return list of static roles.
     * The return value will be an array that has OIDs as values and
     * CB_Role objects as values, i.e.,
     * array( '1'=> $role1, '2'=> $role2, ... )
     *
     * @return CB_Role[]
     */
    function listStaticRoles()
    {
        $rowset = new CB_RowSet($this->getRoleTable());
        $rowset->addOrderColumn('col_list_index,col_slash,_id');
        $rowset->setLock(CB_DATABASE_NO_LOCK);

        $roles = [];
        while ( ! is_null($row = $rowset->iterate())) {
            $roles[$row->getOID()] = clone $row;
        }

        return $roles;
    }

    //GTM-2226
    function searchStaticRolesList($condition, $offset = 0, $limit = -1)
    {
        $rowset = new CB_RowSet($this->getRoleTable());
        if (0 < strlen($condition)) {
            $rowset->addCondition($condition);
        }
        $rowset->limit($offset, $limit);
        $rowset->addOrderColumn('col_list_index,col_slash,_id');
        $rowset->setLock(CB_DATABASE_NO_LOCK);

        $roles = [];
        while ( ! is_null($row = $rowset->iterate())) {
            $roles[$row->getOID()] = clone $row;
        }

        return $roles;
    }


    /**
     * @param bool $isUseLocal
     *
     * @return CB_Group[]
     */
    public function getRootGroups($isUseLocal = true)
    {
        return $this->_core->getGroupListByParentId(null, $isUseLocal);
    }

    /**
     * @param      $gid
     * @param bool $isUseLocal
     *
     * @return false|CB_Group[]
     */
    public function getChildGroups($gid, $isUseLocal = true)
    {
        $group = $this->getGroup($gid);
        if ( ! $group) {
            return false;
        }

        return $this->_core->getGroupListByParentId($gid, $isUseLocal);
    }

    /**
     * Return the default user profile object for named module.
     * Attributes in the default user profile will be used for
     * all users whose profiles do not have specific attributes.
     *
     * @param  string $module_name
     *
     * @return CB_Profile
     */
    function getDefaultUserProfile($module_name)
    {
        require_once('fw/profile.csp');
        $user = null;

        return cb_get_user_profile($user, $module_name);
    }

    function canChangePassword()
    {
        return $this->_sp->isServiceAvailable('change_password');
    }

    function canEditUsers()
    {
        return $this->_sp->isServiceAvailable('edit_user');
    }

    function canEditGroups()
    {
        return $this->_sp->isServiceAvailable('edit_group');
    }

    function canEditUserGroupRelations()
    {
        return $this->_sp->isServiceAvailable('edit_user_group_relation');
    }

    function canEditRoles()
    {
        return $this->_sp->isServiceAvailable('edit_role');
    }

    function canEditUserRoleRelations()
    {
        return $this->_sp->isServiceAvailable('edit_user_role_relation');
    }

    //// Optional API (may be provided by service provier) ////

    function changePassword($uid, $oldPassword, $newPassword, $force = false)
    {
        if ( ! $this->canChangePassword()) {
            cb_throw_error();
        }

        return $this->_sp->changePassword($uid, $oldPassword, $newPassword,
            $force);
    }

    function setHashedPassword($uid, $password_salt, $password_hashed)
    {
        if ( ! $this->canChangePassword()) {
            cb_throw_error();
        }

        return $this->_sp->setHashedPassword($uid, $password_salt,
            $password_hashed);
    }

    function addUser($properties, $id = null, $sync = false)
    {
        if ( ! $this->canEditUsers()) {
            cb_throw_error();
        }
        $user = $this->_sp->addUser($properties, $id);

        return $user;
    }

    function setUserProperties(
        $uid,
        $properties,
        $license_check = true,
        $sync = false
    ) {
        if ( ! $this->canEditUsers()) {
            cb_throw_error();
        }

        return $this->_sp->setUserProperties($uid, $properties);
    }

    function deleteActualUserData($uid)
    {
        if ( ! $this->canEditUsers()) {
            cb_throw_error();
        }

        return $this->_sp->deleteActualUserData($uid);
    }

    function removeUser($uid)
    {
        if ( ! $this->canEditUsers()) {
            cb_throw_error();
        }

        return $this->_sp->removeUser($uid);
    }

    function restoreUser($uid)
    {
        if ( ! $this->canEditUsers()) {
            cb_throw_error();
        }

        return $this->_sp->restoreUser($uid);
    }

    function orderUsers($uids)
    {
        if ( ! $this->canEditUsers()) {
            cb_throw_error();
        }

        return $this->_sp->orderUsers($uids);
    }

    // Group

    /**
     * WARNING:
     *  if you include list_index in $properties, It will be ignore.
     *  Because in the function of CB_UumDefaultServiceProvider::setParentGroup,
     *  value of list_index will be calculate, and set calculated value. @see GRB-16485
     *  But case of $sync = true is except.
     *
     * @param  string[]    $properties
     * @param  string|null $parentId
     * @param  string|null $id
     * @param bool         $sync
     *
     * @return CB_Group
     */
    function addGroupDefaultOnly(
        $properties,
        $parentId = null,
        $id = null,
        $sync = false
    ) {
        if ( ! $this->canEditGroups()) {
            cb_throw_error();
        }

        $sp = $this->_sp;
        $group = $sp->addGroup($properties, $id);

        if ($group) {
            $sp->setParentGroup($group, $parentId, $sync);
        }

        return $group;
    }

    /**
     * @param      $inOrgId
     * @param      $inLocalNameArray
     * @param bool $sync
     *
     * @return bool
     */
    public function addGroupLocals($inOrgId, $inLocalNameArray, $sync = false)
    {
        if ( ! $this->canEditGroups()) {
            cb_throw_error();
        }

        $group = $this->getGroup($inOrgId);
        if ( ! $group) {
            return false;
        }

        $this->_sp->addGroupLocals($inOrgId, $inLocalNameArray, $sync);

        return true;
    }

    /**
     * @param      $inOrgId
     * @param      $inLocalNameArray
     * @param bool $sync
     *
     * @return bool
     */
    public function modifyGroupLocals(
        $inOrgId,
        $inLocalNameArray,
        $sync = false
    ) {
        if ( ! $this->canEditGroups()) {
            cb_throw_error();
        }

        $group = $this->getGroup($inOrgId);
        if ( ! $group) {
            return false;
        }

        $this->_sp->modifyGroupLocals($inOrgId, $inLocalNameArray, $sync);

        return true;
    }

    /**
     * @param  string $gid
     * @param  string $parentId If <var>null</var>, the group becomes a root group.
     * @param bool    $sync
     * @param bool    $updateMtime
     *
     * @return bool
     */
    function setParentGroup($gid, $parentId, $sync = false, $updateMtime = true)
    {
        if ( ! $this->canEditGroups()) {
            cb_throw_error();
        }

        $group = $this->getGroup($gid);
        if ( ! $group) {
            return false;
        }

        return $this->_sp->setParentGroup($group, $parentId, $sync);
    }

    function setGroupProperties($gid, $properties, $sync = false)
    {
        if ( ! $this->canEditGroups()) {
            cb_throw_error();
        }

        return $this->_sp->setGroupProperties($gid, $properties);
    }

    function removeGroup($gid)
    {
        if ( ! $this->canEditGroups()) {
            cb_throw_error();
        }

        return $this->_sp->removeGroup($gid);
    }

    function setUserGroups($uid, $gids)
    {
        if ( ! $this->canEditUserGroupRelations()) {
            cb_throw_error();
        }

        return $this->_sp->setUserGroups($uid, $gids);
    }

    function setGroupUsers($gid, $uids)
    {
        if ( ! $this->canEditUserGroupRelations()) {
            cb_throw_error();
        }

        return $this->_sp->setGroupUsers($gid, $uids);
    }

    public function importGroupNameWithCSV(
        $inFilePath,
        $inCharset,
        $inSkipLineCount = 0
    ) {
        return $this->_sp->importGroupNameWithCSV($inFilePath, $inCharset,
            $inSkipLineCount);
    }

    public function createGroupNameCSV(
        $inCharset,
        $inIsExportHeader,
        $inExportLanguageCodeArray = null
    ) {
        return $this->_sp->createGroupNameCSV($inCharset, $inIsExportHeader,
            $inExportLanguageCodeArray);
    }


    // Role

    function addStaticRole($properties, $id = null, $sync = false)
    {
        if ( ! $this->canEditRoles()) {
            cb_throw_error();
        }
        $role = $this->_sp->addStaticRole($properties, $id);

        return $role;
    }

    function setStaticRoleProperties($id, $properties, $sync = false)
    {
        if ( ! $this->canEditRoles()) {
            cb_throw_error();
        }

        return $this->_sp->setStaticRoleProperties($id, $properties);
    }

    function removeStaticRole($id)
    {
        if ( ! $this->canEditRoles()) {
            cb_throw_error();
        }

        return $this->_sp->removeStaticRole($id);
    }

    function orderStaticRoles($role_ids)
    {
        if ( ! $this->canEditRoles()) {
            cb_throw_error();
        }

        return $this->_sp->orderStaticRoles($role_ids);
    }

    /**
     * @param  string   $uid
     * @param  string[] $role_ids
     *
     * @return bool
     */
    function setUserRoles($uid, $role_ids)
    {
        if ( ! $this->canEditUserRoleRelations()) {
            cb_throw_error();
        }

        return $this->_sp->setUserRoles($uid, $role_ids);
    }

    //// Optional Compound API for User Interfaces ////

    function moveUserHead($uid)
    {
        $user = $this->getUser($uid);
        if ( ! $user) {
            return false;
        }

        $uids = [$user->getOID()];

        $rowset = new CB_RowSet($this->getUserTable());
        $rowset->addOrderColumn('col_list_index');
        while ( ! is_null($row = $rowset->iterate())) {
            if (strcmp($row->getOID(), $uid) === 0) {
                continue;
            }

            $uids[] = $row->getOID();
        }

        return $this->orderUsers($uids);
    }

    function moveUserForward($uid)
    {
        $user = $this->getUser($uid);
        if ( ! $user) {
            return false;
        }

        $uids = [];

        $rowset = new CB_RowSet($this->getUserTable());
        $rowset->addOrderColumn('col_list_index');
        while ( ! is_null($row = $rowset->iterate())) {
            $uids[] = $row->getOID();
        }

        $previous = null;
        $found = false;
        $new_uids = [];
        foreach ($uids as $key) {
            if ($found) {
                $new_uids[] = $key;
                continue;
            }

            if (strcmp($key, $uid) === 0) {
                $found = true;
                $new_uids[] = $uid;
            }

            if ( ! is_null($previous)) {
                $new_uids[] = $previous;
            }
            $previous = $key;
        }

        return $this->orderUsers($new_uids);
    }

    function moveUserBackward($uid)
    {
        $user = $this->getUser($uid);
        if ( ! $user) {
            return false;
        }

        $uids = [];

        $rowset = new CB_RowSet($this->getUserTable());
        $rowset->addOrderColumn('col_list_index');
        while ( ! is_null($row = $rowset->iterate())) {
            $uids[] = $row->getOID();
        }

        $topush = false;
        $new_uids = [];
        foreach ($uids as $key) {
            if ($topush) {
                $new_uids[] = $key;
                $new_uids[] = $uid;
                $topush = false;
                continue;
            }

            if (strcmp($key, $uid) === 0) {
                $topush = true;
                continue;
            }

            $new_uids[] = $key;
        }
        if ($topush) {
            $new_uids[] = $uid;
        }

        return $this->orderUsers($new_uids);
    }

    function moveUserTail($uid)
    {
        $user = $this->getUser($uid);
        if ( ! $user) {
            return false;
        }

        $uids = [];

        $rowset = new CB_RowSet($this->getUserTable());
        $rowset->addOrderColumn('col_list_index');
        while ( ! is_null($row = $rowset->iterate())) {
            if (strcmp($row->getOID(), $uid) === 0) {
                continue;
            }

            $uids[] = $row->getOID();
        }
        $uids[] = $uid;

        return $this->orderUsers($uids);
    }

    function addUserRole($uid, $role_id)
    {
        $roles = $this->getUserRoles($uid);
        if ($roles === false) {
            return false;
        }

        if (array_key_exists($role_id, $roles)) {
            return true;
        }

        $ids = array_keys($roles);
        $ids[] = $role_id;

        return $this->setUserRoles($uid, $ids);
    }

    function removeUserRole($uid, $role_id)
    {
        $roles = $this->getUserRoles($uid);
        if ($roles === false) {
            return false;
        }

        if ( ! array_key_exists($role_id, $roles)) {
            return true;
        }

        unset($roles[$role_id]);

        return $this->setUserRoles($uid, array_keys($roles));
    }

    public function setRoleUsers($role_id, $uids, $remove = false)
    {
        if ($remove) {
            $this->_sp->setRoleUsers($role_id, $uids);
        }

        foreach ($uids as $uid) {
            $this->addUserRole($uid, $role_id);
        }
    }

    public function loadAndCache($user_id_list)
    {
        $this->_core->loadAndCache($user_id_list);
    }

    public function resetCache()
    {
        $this->_core->resetCache();
    }
}
