<?php
/**
 * A store implementation that accesses the server by using the POP3 protocol(RFC1939).
 * <p>
 *   It supports authentication methods, USER, APOP, LOGIN, PLAIN, CRAM-MD5 and DIGEST-MD5.
 * </p>
 *
 * @author  Mizuno, Kuniaki     2004/07
 * @auther  Miyabe, Tatsuhiko   2004/09
 * @version 1.0
 * @package fw.mail
 */

// +-----------------------------------------------------------------------+
// | Copyright (c) 2002, 2005, Richard Heyes                                     |
// | All rights reserved.                                                  |
// |                                                                       |
// | Redistribution and use in source and binary forms, with or without    |
// | modification, are permitted provided that the following conditions    |
// | are met:                                                              |
// |                                                                       |
// | o Redistributions of source code must retain the above copyright      |
// |   notice, this list of conditions and the following disclaimer.       |
// | o Redistributions in binary form must reproduce the above copyright   |
// |   notice, this list of conditions and the following disclaimer in the |
// |   documentation and/or other materials provided with the distribution.|
// | o The names of the authors may not be used to endorse or promote      |
// |   products derived from this software without specific prior written  |
// |   permission.                                                         |
// |                                                                       |
// | THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   |
// | "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     |
// | LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR |
// | A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  |
// | OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, |
// | SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ( iNCLUDING, BUT NOT      |
// | LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, |
// | DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY |
// | THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   |
// | ( iNCLUDING NEGLIGENCE OR OTHERWISe ) ARISING IN ANY WAY OUT OF THE USE |
// | OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  |
// |                                                                       |
// +-----------------------------------------------------------------------+
// | Author: Richard Heyes <richard@phpguru.org>                           |
// +-----------------------------------------------------------------------+
//
// $Id: mail_pop3.csp,v 2.30 2005/09/12 13:36:26 d-sano Exp $

require_once('Net/Socket.php');
require_once('fw/i18n.csp');
require_once('fw/mail_store.csp');
require_once('fw/mail_message.csp');
require_once('fw/mail_pop3_uidstorage.csp');
require_once('fw/socket_util.csp');

use grn\mail\exception\MailServiceException;

/** The POP3 default port number. */
define('CB_MAIL_PORT_POP', '110');

/**
 * A implementation of CB_MailStore.
 *
 * @package fw.mail
 */
class CB_MailPOP3Store extends CB_MailStore
{
    /**
     * The protocol handler.
     *
     * @var object CB_MailSMTPProtocol
     * @access private
     */
    var $_p;

    /**
     * If true, this sender has connected the server.
     *
     * @var boolean
     * @access private
     */
    var $_connected = false;

    /**
     * The UID strage to save UID of the last seen message.
     *
     * @var object CB_MailPOP3UIDStorage
     * @access private
     */
    var $_uid_storage;

    /**
     * The "INBOX" folder.
     *
     * @var object CB_MailPOP3Folder
     * @access private
     */
    var $_inbox;

    /**
     * @access private
     */
    var $_reconnect_config = false;

    function __construct()
    {
        parent::__construct();
        $this->_p = new CB_MailPOP3Protocol();
        $this->_init();
    }

    /**
     * @param object CB_Logger $logger
     */
    function setLogger($logger)
    {
        parent::setLogger($logger);
        $this->_p->setLogger($logger);
    }

    /**
     * Set error listener object.
     *
     * @param object CB_MailErrorListener $listener
     */
    function setErrorListener($listener)
    {
        parent::setErrorListener($listener);
        $this->_p->setErrorListener($listener);
    }

    /**
     * Commands DELE for all messages marked as deleted.
     */
    function commit()
    {
        if ( ! $this->_connected) {
            return true;
        }
        //sleep( 65 );
        if (isset($this->_inbox)) {
            if ( ! $this->_inbox->_commit()) {
                if ( ! is_null($this->_logger)) {
                    $this->_logger->warning('Failed commit. reason = disconnect server');
                }
                $this->disconnect();
                $this->connect($this->_reconnect_config);
                if ( ! $this->_inbox->_commit()) {
                    if ( ! is_null($this->_logger)) {
                        $this->_logger->error('Failed recommit.');
                    }

                    return false;
                }
            }
            $this->_init();
        }

        // commit mail server. (disconnect() calls QUIT command.)
        $this->disconnect();

        return true;
    }

    /**
     * Undeletes all messages marked as deleted.
     */
    function abort()
    {
        @$this->disconnect();

        return true;
    }

    /**
     * Opens a connection to the server.
     *
     * $info_array may have these keys:
     *   'hostname' => server hostname,
     *   'port'     => TCP port number,
     *   'uid'      => connecting user name,
     *   'domain'   => client domain name (e.g. domain name part of client mail address). default to 'localhost',
     *   'password' => credential,
     *   'timeout'  => timeout duration in seconds,
     *   'auth'     => implementation specific authentication mechanism.
     *
     * @param  array $info_array
     *
     * @return boolean    TRUE if the connect succeeds; otherwise FALSE.
     */
    function connect($info_array)
    {
        assert('!is_null( $info_array )');

        if ($this->_connected) {
            $msg = cb_msg('fw.mail', 'Already connected to the server.');
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(-1, $msg);
            }
            if ( ! is_null($this->_logger)) {
                $this->_logger->warning($msg);
            }

            return false;
        }
        $ret = $this->_setDefaultConnInfo($info_array);
        if (PEAR::isError(
            $err = $this->_p->connect($ret['hostname'], $ret['port'], $ret['domain'], $ret['uid'], $ret['password'],
                $ret['auth'], $ret['timeout'], true, $ret['pop3_ssl'], $ret['socks_info']))
        ) {
            $this->disconnect();

            return false;
        }

        $this->_connected = true;
        $this->_reconnect_config = $info_array;
        $this->_uid_storage->setup($ret['hostname'], $ret['port'], $ret['uid'], $ret['option']);

        return true;
    }

    /**
     * @access private
     */
    function _setDefaultConnInfo($info_array)
    {
        $ret = [];

        $ret['hostname'] = 'localhost';
        $ret['port'] = CB_MAIL_PORT_POP;
        $ret['pop3_ssl'] = false;
        $ret['domain'] = 'localhost';
        $ret['timeout'] = CB_MAIL_DEFAULT_TIMEOUT;
        $ret['auth'] = 'USER';
        $ret['uid'] = '';
        $ret['password'] = '';
        $ret['option'] = '';

        foreach (array_keys($ret) as $key) {
            if (isset($info_array[$key]) && isset($ret[$key])) {
                $ret[$key] = $info_array[$key];
            }
        }
        $ret['socks_info'] = cb_get_socks_info();
        $ret['auth'] = strtoupper($ret['auth']);

        return $ret;
    }

    /**
     * Implementation of {@link CB_MailService} method.
     */
    function isConnected()
    {
        return ($this->_connected);
    }

    /**
     * Implementation of {@link CB_MailService} method.
     */
    function disconnect()
    {
        $this->_connected = false;
        //$this->_init();
        if (PEAR::isError($err = $this->_p->disconnect())) {
            return false;
        }

        return true;
    }

    /**
     * Checks whether the service is available or not
     *
     * @param  array $info_array
     *   'hostname' => server hostname,
     *   'port'     => TCP port number,
     *   'timeout'  => timeout duration in seconds,
     *   'auth'     => implementation specific authentication mechanism.
     *
     * @return boolean
     */
    function isAvailable($info_array)
    {
        if ( ! is_array($info_array)) {
            return false;
        }

        $ret = $this->_setDefaultConnInfo($info_array);
        if (PEAR::isError(
            $err = $this->_p->connect($ret['hostname'], $ret['port'], $ret['domain'], $ret['uid'], $ret['password'],
                $ret['auth'], $ret['timeout'], false, $ret['pop3_ssl'], $ret['socks_info']))
        ) {
            $this->disconnect();

            return false;
        }

        if (PEAR::isError($result = $this->_p->checkSupportedAuthMethod($ret['auth']))) {
            $this->disconnect();

            return false;
        }

        $this->disconnect();

        return true;
    }

    /**
     * Returns the 'INBOX' folder.
     *
     * @return object {@link CB_MailFolder}.
     */
    function getDefaultFolder()
    {
        if ( ! $this->_checkConnection()) {
            $ret = false;

            return $ret;
        }

        if ( ! isset($this->_inbox)) {
            $this->_inbox = new CB_MailPOP3Folder($this);
        }

        return $this->_inbox;
    }

    /**
     * Only the name 'INBOX' is supported.
     *
     * @return object {@link CB_MailFolder}.
     */
    function getFolder($name)
    {
        assert('!is_null( $name )');

        if ( ! $this->_checkConnection()) {
            $ret = false;

            return $ret;
        }

        if (strtoupper($name) == 'INBOX') {
            $ret = $this->getDefaultFolder();

            return $ret;
        } else {
            $ret = false;

            return $ret;
        }
    }

    /**
     * The result contains a mapping to 'INBOX' folder.
     *
     * @return array array of {@link CB_MailFolder}.
     */
    function getFolders()
    {
        if ( ! $this->_checkConnection()) {
            return false;
        }

        return ['INBOX' => $this->getDefaultFolder()];
    }

    /**
     * Checks whether the connection is available.
     *
     * @access private
     */
    function _checkConnection()
    {
        if ( ! $this->_connected) {
            $msg = cb_msg('fw.mail', 'Has not connected to the server yet.');
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(-1, $msg);
            }
            if ( ! is_null($this->_logger)) {
                $this->_logger->warning($msg);
            }

            return false;
        }

        return true;
    }

    /**
     * Initialization.
     *
     * @access private
     */
    function _init()
    {
        if (isset($this->_inbox)) {
            $this->_inbox->_invalidate();
            unset($this->_inbox);
        }
    }
}

class CB_MailPOP3Folder extends CB_MailFolder
{
    /**
     * The protocol handler.
     *
     * @var object CB_MailSMTPProtocol
     * @access private
     */
    var $_p;

    /**
     * The UID strage to save UID of the seen message.
     *
     * @var object CB_MailPOP3UIDStorage
     * @access private
     */
    var $_uid_storage;

    /**
     * Some basic information about the mail drop:
     * <ul>
     *   <li>'count' - Total message count.
     *   <li>'size' - The sum total of all message size.
     * </ul>
     * Messages marked as deleted are not counted in either total.
     *
     * @var array
     * @access private
     */
    var $_maildropTotal;

    /**
     * List of information about each message in the mail drop.
     * The key is the message number, and the value is the message size.
     * Messages marked as deleted are not contained.
     *
     * @var array
     * @access private
     */
    var $_maildropList;

    /**
     * Cache of the mail object.
     * The key is the message number, and the value is the message object.
     * Messages marked as deleted are not contained.
     *
     * @var array
     * @access private
     */
    var $_mailCache;

    var $_UIDs;
    var $_seens;
    var $_unseens;
    var $_initialized = false;

    /**
     * Contains messages that marked as deleted.
     * Each element is hash and similar to _maildropList.
     *
     * @var array
     * @access private
     */
    var $_messagesToDelete = [];

    var $_error_code = 'FW00040';

    function __construct($store)
    {
        assert('is_a( $store, "CB_MailPOP3Store" )');

        parent::__construct($store);
        $this->_p = $store->_p;
        $this->_uid_storage = $store->_uid_storage;
    }

    function setThrowError($error_code)
    {
        $this->_error_code = $error_code;
    }

    function throwError($message = '')
    {
        if ( ! is_null($this->_error_code)) {
            cb_throw_error($this->_error_code,
                ['info' => $message],
                ['info' => $message],
                ['info' => $message],
                ['info' => $message]);
        }
    }

    /**
     * Implementation of {@link CB_MailFolder} method.
     */
    function getStore()
    {
        return $this->_store;
    }

    /**
     * Implementation of {@link CB_MailFolder} method.
     */
    function getMessageCount()
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        return $this->_maildropTotal['count'];
    }

    /**
     * @param int $msgnum
     *
     * @return mixed {@link CB_MailMessage}, or FALSE.
     */
    function getMessage($msgnum)
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));
            $message = false;

            return $message;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();
            $message = false;

            return $message;
        }

        if ( ! isset($this->_maildropList[$msgnum])) {
            $message = null;

            return $message;
        }

        if (isset($this->_mailCache[$msgnum])) {
            return $this->_mailCache[$msgnum];
        } else {
            $size = $this->_maildropList[$msgnum];
            $this->_mailCache[$msgnum] = new CB_MailPOP3Message($this->_p, $msgnum, $size);

            return $this->_mailCache[$msgnum];
        }
    }

    /**
     * Implementation of {@link CB_MailFolder} method.
     */
    function getAllMessages()
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        foreach ($this->_maildropList as $msgnum => $size) {
            if ( ! isset($this->_mailCache[$msgnum])) {
                $this->_mailCache[$msgnum] = new CB_MailPOP3Message($this->_p, $msgnum, $size);
            }
        }

        return $this->_mailCache;
    }

    /**
     * Implementation of {@link CB_MailFolder} method.
     *
     * @param int $msgnum
     *
     * @return int
     */
    function getMessageSize($msgnum)
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        if ( ! isset($this->_maildropList[$msgnum])) {
            return null;
        }

        $size = $this->_maildropList[$msgnum];

        return $size;
    }

    /**
     * Implementation of {@link CB_MailFolder} method.
     */
    function getTotalSize()
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        return $this->_maildropTotal['size'];
    }

    /**
     * Implementation of {@link CB_MailFolder} method.
     *
     * @param int  $msgnum
     * @param null $header_names
     *
     * @return array|bool
     */
    function getMessageHeaders($msgnum, $header_names = null)
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        $message = $this->getMessage($msgnum);

        if (is_null($header_names)) {
            return $message->getAllHeaders();
        } else {
            $result = [];
            foreach ($header_names as $name) {
                if (($headers = $message->getHeaders($name)) === false) {
                    return false;
                }
                $result = array_merge($result, $headers);
            }

            return $result;
        }
    }

    /**
     * Implementation of {@link CB_MailFolder} method.
     */
    function getAllMessageHeaders($header_names = null)
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        $result = [];
        $messages = $this->getAllMessages();
        foreach (array_keys($messages) as $msgnum) {
            $message = $messages[$msgnum];

            if (is_null($header_names)) {
                if (($result[$msgnum] = $message->getAllHeaders()) === false) {
                    return false;
                }
            } else {
                $headers = [];
                foreach ($header_names as $name) {
                    if (($message_headers = $message->getHeaders($name)) === false) {
                        return false;
                    }
                    $headers = array_merge($headers, $message_headers);
                }
                $result[$msgnum] = $headers;
            }
        }

        return $result;
    }

    /**
     * Implementation of {@link CB_MailFolder} method.
     *
     * @param int $msgnum
     *
     * @return bool
     */
    function deleteMessage($msgnum)
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        if ( ! isset($this->_maildropList[$msgnum])) {
            return true;
        }

        $this->_messagesToDelete[] = $msgnum;

        $this->_maildropTotal['count'] -= 1;
        $this->_maildropTotal['size'] -= $this->_maildropList[$msgnum];

        if ($this->_isUIDCapable) {
            $_uid = $this->_UIDs[$msgnum];
            $this->_uid_storage->deleteSeens([$_uid]);
        }
        unset($this->_maildropList[$msgnum]);
        unset($this->_UIDs[$msgnum]);
        unset($this->_seens[$msgnum]);
        unset($this->_unseens[$msgnum]);
        unset($this->_mailCache[$msgnum]);

        return true;
    }

    /**
     * Implementation of {@link CB_MailFolder} method.
     */
    function deleteAllMessages()
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        $this->_messagesToDelete = array_merge($this->_messagesToDelete, array_keys($this->_maildropList));

        $this->_maildropTotal = ['count' => 0, 'size' => 0];
        $this->_maildropList = [];

        if ($this->_isUIDCapable) {
            $this->_uid_storage->deleteSeens($this->_UIDs);
        }
        $this->_UIDs = [];
        $this->_seens = [];
        $this->_unseens = [];
        $this->_mailCache = [];

        return true;
    }

    /**
     * Implementation of {@link CB_MailFolder} method.
     */
    function getUnseenMessageNumbers()
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        return array_keys($this->_unseens);
    }

    /**
     * Implementation of {@link CB_MailFolder} method.
     */
    function getNextUnseenMessage()
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        $unseen_message = null;
        foreach (array_keys($this->_unseens) as $msgnum) {
            $message = $this->getMessage($msgnum);
            if ( ! $message) {
                return false;
            }
            $unseen_message = [
                'msgnum'  => $msgnum,
                'message' => $message
            ];
            unset($this->_unseens[$msgnum]);
            if ($this->_isUIDCapable) {
                $_uid = $this->_UIDs[$msgnum];
                $this->_seens[$msgnum] = $_uid;
                $this->_uid_storage->addSeens([$_uid]);
            } else {
                $this->_seens[$msgnum] = $msgnum;
            }
            break;
        }

        return $unseen_message;
    }

    /**
     * Implementation of {@link CB_MailFolder} method.
     */
    function deleteSeenMessages()
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        $newUnseens = [];
        foreach (array_keys($this->_seens) as $msgnum) {
            $this->_messagesToDelete[] = $msgnum;

            $this->_maildropTotal['count'] -= 1;
            $this->_maildropTotal['size'] -= $this->_maildropList[$msgnum];

            if ($this->_isUIDCapable) {
                $_uid = $this->_UIDs[$msgnum];
                $newUnseens[] = $_uid;
            }
            unset($this->_maildropList[$msgnum]);
            unset($this->_UIDs[$msgnum]);
            unset($this->_seens[$msgnum]);
            unset($this->_unseens[$msgnum]);
            unset($this->_mailCache[$msgnum]);
        }
        if (count($newUnseens) > 0) {
            $this->_uid_storage->deleteSeens($newUnseens);
        }

        return true;
    }

    /**
     * Implementation of {@link CB_MailFolder} method.
     *
     * @param array $msgnums
     *
     * @return bool
     */
    function setUnseen($msgnums)
    {
        if ( ! is_array($msgnums)) {
            return false;
        }
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        $newUnseens = [];
        foreach ($msgnums as $msgnum) {
            if (isset($this->_seens[$msgnum])) {
                unset($this->_seens[$msgnum]);
                if ($this->_isUIDCapable) {
                    $_uid = $this->_UIDs[$msgnum];
                    $this->_unseens[$msgnum] = $_uid;
                    $newUnseens[] = $_uid;
                } else {
                    $this->_unseens[$msgnum] = $msgnum;
                }
            }
        }
        if (count($newUnseens) > 0) {
            $this->_uid_storage->deleteSeens($newUnseens);
        }

        return true;
    }

    function isUIDCapable()
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        return $this->_isUIDCapable;
    }

    function getMessageNumber($uid)
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        if ($this->_isUIDCapable) {
            $msgnum = array_search($uid, $this->_UIDs);
            if ($msgnum) {
                return $msgnum;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    function getMessageUID($msgnum)
    {
        if ( ! $this->_checkValidate()) {
            $this->throwError(cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.'));

            return false;
        }
        if ( ! $this->_initialize()) {
            $this->throwError();

            return false;
        }

        if ($this->_isUIDCapable) {
            if (array_key_exists($msgnum, $this->_UIDs)) {
                return $this->_UIDs[$msgnum];
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * Sends DELE command for messages that has been marked as deleted.
     * Also update the UID strage for last seen message.
     *
     * @return boolean Success/Failure
     * @access private
     */
    function _commit()
    {
        if ( ! $this->_initialize()) {
            return false;
        }

        if ( ! empty($this->_messagesToDelete)) {
            foreach ($this->_messagesToDelete as $msgnum) {
                if (PEAR::isError($err = $this->_p->cmdDELE($msgnum))) {
                    return false;
                }
            }
        }

        return true;
    }

    function _initialize()
    {
        if ($this->_initialized === false) {
            if (PEAR::isError($this->_maildropList = $this->_p->cmdLIST())) {
                return false;
            }

            $this->_maildropTotal = ['count' => 0, 'size' => 0];
            foreach ($this->_maildropList as $message) {
                $this->_maildropTotal['count'] += 1;
                $this->_maildropTotal['size'] += $message;
            }

            $UIDs = $this->_p->cmdUIDL();
            // UID is capable
            if (is_array($UIDs)) {
                $this->_isUIDCapable = true;
                $this->_UIDs = $UIDs;

                $unseens = $this->_uid_storage->getUnseens($UIDs);
                $this->_seens = array_diff($UIDs, $unseens);
                $this->_unseens = array_diff($UIDs, $this->_seens);
            } // UID is not capable
            else {
                $this->_isUIDCapable = false;
                $this->_UIDs = [];

                $this->_seens = [];
                $this->_unseens = $this->_maildropList;
            }
            $this->_mailCache = [];
            $this->_initialized = true;
        }

        return true;
    }

    /**
     * Marks the folder as invalidated.
     *
     * @access private
     */
    function _invalidate()
    {
        unset($this->_store);
    }

    function _checkValidate()
    {
        if ( ! isset($this->_store)) {
            $msg = cb_msg('fw.mail', 'This folder is invalid. Please get the folder from the store again.');
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(-1, $msg);
            }
            if ( ! is_null($this->_logger)) {
                $this->_logger->warning($msg);
            }

            return false;
        }

        return true;
    }
}

/**
 * A implementation of CB_MailStore using PEAR::Net_Socket.
 *
 * @package fw.mail
 */
class CB_MailPOP3Protocol
{
    /**
     * The logger object.
     *
     * @var CB_Logger
     * @access private
     */
    var $_logger;

    /**
     * The error listener.
     *
     * @var CB_ErrorListener
     * @access private
     */
    var $_listener;

    /**
     * Used for APOP to store the timestamp
     *
     * @var string
     * @access private
     */
    var $_timestamp;

    /**
     * Socket object
     *
     * @var object
     * @access private
     */
    var $_socket;

    /**
     * Hostname
     */
    var $_host;
    var $_domain;

    /**
     * The auth methods this class support.
     *
     * @var array
     * @access private
     */
    var $_supportedAuthMethods = ['DIGEST-MD5', 'CRAM-MD5', 'APOP', 'PLAIN', 'LOGIN', 'USER'];

    /**
     * The auth methods this class support
     *
     * @var array
     * @access private
     */
    var $_supportedSASLAuthMethods = ['DIGEST-MD5', 'CRAM-MD5'];

    /**
     * The capability response
     *
     * @var array
     * @access private
     */
    var $_capability;

    /**
     * True to indicates the protocol handler in transaction.
     *
     * @var boolean
     * @access private
     */
    var $_in_transaction = false;

    /**
     * Socket wrapper.
     *
     * @var string
     * @access private
     */
    var $_readutil;

    /**
     * socks info
     *
     * @var array
     */
    var $_socks_info = [];

    /**
     * The constractor.
     */
    function __construct()
    {
        $this->_socket = new Net_Socket();

        global $G_config_common;
        $read_timeout = $G_config_common->get('Mail', 'mail_pop3_read_timeout');
        $read_buffer_size = $G_config_common->get('Mail', 'mail_pop3_read_buffer_size');
        $this->_readutil = new CB_MailSocketReader($this->_socket, $read_timeout, $read_buffer_size);

        /*
        * Include the Auth_SASL package.  If the package is not available,
        * we disable the authentication methods that depend upon it.
        */
        if ((@include_once('Auth/SASL.php')) == false) {
            //$this->_logger->warning("Auth/SASL.php not present!\n" );
            foreach ($this->_supportedSASLAuthMethods as $SASLMethod) {
                $pos = array_search($SASLMethod, $this->_supportedAuthMethods);
                //$this->_logger->debug("Disabling method $SASLMethod\n" );
                unset($this->_supportedAuthMethods[$pos]);
            }
        }
    }

    function setLogger($logger)
    {
        $this->_logger = $logger;
        $this->_readutil->setLogger($logger);
    }

    function setErrorListener($listener)
    {
        $this->_listener = $listener;
        $this->_readutil->setErrorListener($listener);
    }

    function connect($host, $port, $domain, $user, $password, $auth, $timeout, $login = true, $pop3_ssl = false, $socks_info)
    {
        assert('!is_null( $host)');
        assert('!is_null( $port)');
        assert('!is_null( $domain)');
        assert('!is_null( $timeout)');
        assert('!is_null( $user)');
        assert('!is_null( $password)');

        $this->_domain = $domain;
        $this->_host = $host;
        $auth = strtoupper($auth);
        $this->_socks_info = $socks_info;
        $options = ["ssl" => ["verify_peer" => false, "verify_peer_name" => false]];

        try {
            $this->checkError($this->connectToSocksServer($timeout, $options), false);
            $this->checkError($this->connectToMailServer($host, $port, $timeout, $options, $pop3_ssl), false);
            if ($pop3_ssl && cb_is_forest()) {
                $this->checkError($this->_socket->enableCrypto(true, STREAM_CRYPTO_METHOD_SSLv23_CLIENT), false);
            }
            $this->_socket->setBlocking(false);
            $this->_in_transaction = true;

            $data = $this->_readLine();
            $this->checkError($data);
            if (@substr($data, 0, 3) != '+OK') {
                $this->disconnect();
                throw new MailServiceException();
            }

            // Check for string matching apop timestamp
            if (preg_match('/<.+@.+>/U', $data, $matches)) {
                $this->_timestamp = $matches[0];
            } else {
                unset($this->_timestamp);
            }

            if ($login) {
                $success = $this->_login($user, $password, $auth);
                $this->checkError($success);
                if ($success == false) {
                    $msg = cb_msg('fw.mail', 'Authentication failed.');
                    if (!is_null($this->_listener)) {
                        $this->_listener->error(-1, $msg);
                    }
                    $this->disconnect();
                    throw new MailServiceException();
                }
            }
        } catch (MailServiceException $err) {
            return new PEAR_Error();
        }
        return true;
    }

    /**
     * check the PEAR_Error
     *
     * @param $err
     * @param bool $is_need_disconnect
     * @throws MailServiceException
     */
    public function checkError($err, $is_need_disconnect = true)
    {
        if (PEAR::isError($err)) {
            if ($is_need_disconnect) {
                $this->disconnect();
            }
            throw new MailServiceException();
        }
    }

    /**
     * connect to the socks server (.com server only)
     *
     * @param $timeout
     * @param $options
     *
     * @return bool|mixed|PEAR_Error
     */
    public function connectToSocksServer($timeout, $options)
    {
        if (cb_is_forest()) {
            $socks5_host = $this->_socks_info['host'];
            $socks5_port = $this->_socks_info['port'];
            $connect_code = pack("C3", 0x05, 0x01, 0x00);
            if (PEAR::isError($err =
                $this->_socket->connect($socks5_host, $socks5_port, FALSE, $timeout, $options))) {
                return $err;
            } elseif (PEAR::isError($err = $this->_socket->write($connect_code))) {
                return $err;
            } else {
                $buffer = $this->_socket->read(3);
                $response = unpack('C*', $buffer);
                if (count($response) != 2) {
                    return new PEAR_Error();
                } elseif ($response['1'] != 5) {
                    return new PEAR_Error();
                } elseif ($response['2'] != 0) {
                    return new PEAR_Error();
                }
            }
        }
        return TRUE;
    }

    /**
     * @param $host
     * @param $host_port
     * @param $timeout
     * @param $options
     * @param $pop3_ssl
     *
     * @return bool|PEAR_Error
     */
    public function connectToMailServer($host, $host_port, $timeout, $options, $pop3_ssl)
    {
        if (cb_is_forest()) {
            $host_ip = @gethostbyname($host);
            $connect_code =
                chr(5) . chr(1) . "\x00" . chr(1) . pack('Nn', ip2long($host_ip),
                    $host_port);

            if (PEAR::isError($err = $this->_socket->write($connect_code))) {
                return $err;
            } else {
                $buffer = $this->_socket->read(11);
                $response = unpack("C*", $buffer);
                if (count($response) != 10) {
                    return new PEAR_Error();
                } elseif ($response['1'] != 5) {
                    return new PEAR_Error();
                } elseif ($response['2'] != 0) {
                    return new PEAR_Error();
                }
            }

            return TRUE;
        } else {
            if (PEAR::isError(
                $err = $this->_socket->connect($host, $host_port, FALSE, $timeout, $options, $pop3_ssl))) {
                if (!is_null($this->_listener)) {
                    $this->_listener->error(-1, cb_msg('fw.mail', 'Failed to connect the server.'));
                }
                if (!is_null($this->_logger)) {
                    $this->_logger->warning($err->getMessage());
                }
                return $err;
            }
            return TRUE;
        }
    }

    /**
     * Disconnect function. Sends the QUIT command
     * and closes the socket.
     * If connection is already closed, this method does nothing.
     *
     * @return mixed true or PEAR_Error.
     */
    function disconnect()
    {
        if ($this->_in_transaction === true) {
            $this->_in_transaction = false;
            @$this->cmdQUIT();
            if (PEAR::isError($err = $this->_socket->disconnect())) {
                if ( ! is_null($this->_listener)) {
                    $this->_listener->error(-1, cb_msg('fw.mail', 'Failed to disconnect from the server.'));
                }
                if ( ! is_null($this->_logger)) {
                    $this->_logger->warning($err->getMessage());
                }

                return $err;
            }
        }

        return true;
    }

    function checkSupportedAuthMethod($user_method)
    {
        if (PEAR::isError($err = $this->cmdCAPA())) {
            return $err;
        }

        $availableMethods = ['APOP', 'USER'];
        if (isset($this->_capability['sasl'])) {
            $availableMethods = array_merge($availableMethods, $this->_capability['sasl']);
        }

        $methods = $this->_supportedAuthMethods;

        // Check the timestamp for APOP.
        if ( ! isset($this->_timestamp)) {
            $key = array_search('APOP', $availableMethods);
            if ($key !== false) {
                unset($availableMethods[$key]);
            }
        }

        if ( ! is_null($methods) && ! empty($availableMethods)) {
            if (in_array($user_method, $availableMethods)) {
                return true;
            }
        }

        $msg = cb_msg('fw.mail', 'The server does not support authentication.');
        if ( ! is_null($this->_listener)) {
            $this->_listener->error(-1, $msg);
        }

        return new PEAR_Error();
    }

    /**
     * Returns the name of the best authentication method that the server
     * has advertised.
     *
     * @param string if !=null,authenticate with this method ( $userMethod ).
     *
     * @return mixed    Returns a string containing the name of the best
     *                  supported authentication method or a PEAR_Error object
     *                  if a failure condition is encountered.
     * @access private
     * @return mixed true or PEAR_Error.
     */
    function _getBestAuthMethod()
    {
        if (PEAR::isError($err = $this->cmdCAPA())) {
            return $err;
        }

        $availableMethods = ['APOP', 'USER'];
        if (isset($this->_capability['sasl'])) {
            $availableMethods = array_merge($availableMethods, $this->_capability['sasl']);
        }

        $methods = $this->_supportedAuthMethods;

        // Check the timestamp for APOP.
        if ( ! isset($this->_timestamp)) {
            $key = array_search('APOP', $availableMethods);
            if ($key !== false) {
                unset($availableMethods[$key]);
            }
        }

        if ( ! is_null($methods) && ! empty($availableMethods)) {
            foreach ($methods as $method) {
                if (in_array($method, $availableMethods)) {
                    return $method;
                }
            }

            $availableMethods = implode(',', $availableMethods);
            $myMethods = implode(',', $methods);

            $msg = cb_msg('fw.mail', 'No authentication methods available.');
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(-1, $msg);
            }
            if ( ! is_null($this->_logger)) {
                $this->_logger->debug($msg);
            }

            return new PEAR_Error();
        } else {
            $msg = cb_msg('fw.mail', 'No authentication methods available.');
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(-1, $msg);
            }
            if ( ! is_null($this->_logger)) {
                $this->_logger->debug($msg);
            }

            return new PEAR_Error();
        }

        return true;
    }

    /**
     * Handles the authentication using any known method
     *
     * @param string The userid to authenticate as.
     * @param string The password to authenticate with.
     * @param string The method to use ( if $usermethod == '' then the class chooses the best method (the stronger is the best ) )
     *
     * @return mixed true or PEAR_Error.
     *
     * @access private
     */
    function _login($uid, $pwd, $method = null)
    {
        assert('!is_null( $uid )');
        assert('!is_null( $pwd )');
        if ($method == 'AUTO') {
            if (PEAR::isError($method = $this->_getBestAuthMethod())) {
                return $method;
            }
        } else {
            $method = strtoupper($method);
            if ( ! in_array($method, $this->_supportedAuthMethods)) {
                $msg = cb_msg('fw.mail', '&&method&& is not a supported authentication method.', ['method' => $method]);
                if ( ! is_null($this->_listener)) {
                    $this->_listener->error(-1, $msg);
                }
                if ( ! is_null($this->_logger)) {
                    $this->_logger->debug($msg);
                }

                return new PEAR_Error();
            }
        }

        switch ($method) {
            case 'DIGEST-MD5':
                $result = $this->_authDIGEST_MD5($uid, $pwd);
                break;
            case 'CRAM-MD5':
                $result = $this->_authCRAM_MD5($uid, $pwd);
                break;
            case 'LOGIN':
                $result = $this->_authLOGIN($uid, $pwd);
                break;
            case 'PLAIN':
                $result = $this->_authPLAIN($uid, $pwd);
                break;
            case 'APOP':
                $result = $this->cmdAPOP($uid, $pwd);
                break;
            case 'USER':
                $result = $this->_authUSER($uid, $pwd);
                break;
            default :
                $msg = cb_msg('fw.mail', '&&method&& is not a supported authentication method.', ['method' => $method]);
                if ( ! is_null($this->_listener)) {
                    $this->_listener->error(-1, $msg);
                }
                if ( ! is_null($this->_logger)) {
                    $this->_logger->debug($msg);
                }
                $result = new PEAR_Error();
                break;
        }

        return $result;
    }

    /**
     * Authenticates the user using the PLAIN method.
     *
     * @param string The userid to authenticate as.
     * @param string The password to authenticate with.
     *
     * @return mixed true or PEAR_Error.
     *
     * @access private
     */
    function _authUSER($user, $pass)
    {
        assert('!is_null( $user )');
        assert('!is_null( $pass )');

        if (PEAR::isError($err = $this->cmdUSER($user))) {
            return $err;
        }

        return $this->cmdPASS($pass);
    }

    /**
     * Authenticates the user using the PLAIN method.
     *
     * @param string The userid to authenticate as.
     * @param string The password to authenticate with.
     *
     * @return mixed true or PEAR_Error.
     *
     * @access private
     */
    function _authPLAIN($user, $pass)
    {
        assert('!is_null( $user )');
        assert('!is_null( $pass )');

        $cmd = sprintf('AUTH PLAIN %s', base64_encode(chr(0) . $user . chr(0) . $pass));

        if (PEAR::isError($err = $this->_writeLine($cmd))) {
            return $err;
        }

        return $this->_readResponse($data);
    }

    /**
     * Authenticates the user using the LOGIN method.
     *
     * @param string The userid to authenticate as.
     * @param string The password to authenticate with.
     *
     * @return mixed true or PEAR_Error.
     *
     * @access private
     */
    function _authLOGIN($user, $pass)
    {
        assert('!is_null( $user )');
        assert('!is_null( $pass )');

        if (PEAR::isError($err = $this->_writeLine('AUTH LOGIN'))) {
            return $err;
        }

        if (PEAR::isError($prompt = $this->_readLine())) {
            return $prompt;
        }
        if (substr($prompt, 0, 1) != '+') {
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $prompt);
            }

            return new PEAR_Error();
        }
        if ( ! is_null($this->_logger)) {
            if ($this->_logger->isDebugEnabled()) {
                $this->_logger->debug('Prompt "' . base64_decode(substr($prompt, 2)) . '"');
            }
        }

        if (PEAR::isError($err = $this->_writeLine(base64_encode($user)))) {
            return $err;
        }

        if (PEAR::isError($prompt = $this->_readLine())) {
            return $prompt;
        }
        if (substr($prompt, 0, 1) != '+') {
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $prompt);
            }

            return new PEAR_Error();
        }
        if ( ! is_null($this->_logger)) {
            if ($this->_logger->isDebugEnabled()) {
                $this->_logger->debug('Prompt "' . base64_decode(substr($prompt, 2)) . '"');
            }
        }

        if (PEAR::isError($err = $this->_writeLine(base64_encode($pass)))) {
            return $err;
        }

        return $this->_readResponse($data);
    }

    /**
     * Authenticates the user using the CRAM-MD5 method.
     *
     * @param string The userid to authenticate as.
     * @param string The password to authenticate with.
     *
     * @return mixed true or PEAR_Error.
     *
     * @access private
     */
    function _authCRAM_MD5($uid, $pwd)
    {
        assert('!is_null( $uid )');
        assert('!is_null( $pwd )');

        if (PEAR::isError($err = $this->_writeLine('AUTH CRAM-MD5'))) {
            return $err;
        }

        if (PEAR::isError($challenge = $this->_readLine())) {
            return $challenge;
        }
        if (substr($challenge, 0, 1) != '+') {
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $challenge);
            }

            return new PEAR_Error();
        }

        // remove '+ '
        $challenge = substr($challenge, 2);
        $challenge = base64_decode($challenge);
        if ( ! is_null($this->_logger)) {
            $this->_logger->debug("challenge: $challenge");
        }

        $cram = Auth_SASL::factory('CRAMMD5');
        $auth_str = $cram->getResponse($uid, $pwd, $challenge);
        if ( ! is_null($this->_logger)) {
            $this->_logger->debug("response: $auth_str");
        }
        $auth_str = base64_encode($auth_str);

        if (PEAR::isError($err = $this->_writeLine($auth_str))) {
            return $err;
        }

        return $this->_readResponse($data);
    }

    /**
     * Authenticates the user using the DIGEST-MD5 method.
     *
     * @param string The userid to authenticate as.
     * @param string The password to authenticate with.
     * @param string The efective user
     *
     * @return mixed true or PEAR_Error.
     *
     * @access private
     */
    function _authDIGEST_MD5($uid, $pwd)
    {
        assert('!is_null( $uid )');
        assert('!is_null( $pwd )');

        if (PEAR::isError($err = $this->_writeLine('AUTH DIGEST-MD5'))) {
            return $err;
        }

        if (PEAR::isError($challenge = $this->_readLine())) {
            return $challenge;
        }
        if (substr($challenge, 0, 1) != '+') {
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $challenge);
            }

            return new PEAR_Error();
        }

        // remove '+ '
        $challenge = substr($challenge, 2);

        $challenge = base64_decode($challenge);
        if ( ! is_null($this->_logger)) {
            $this->_logger->debug("challenge: $challenge");
        }

        $digest = Auth_SASL::factory('DIGESTMD5');
        $auth_str = $digest->getResponse($uid, $pwd, $challenge, $this->_host, 'pop', null, $this->_domain);
        if ( ! is_null($this->_logger)) {
            $this->_logger->debug("response: $auth_str");
        }
        $auth_str = base64_encode($auth_str);

        if (PEAR::isError($err = $this->_writeLine($auth_str))) {
            return $err;
        }

        if (PEAR::isError($challenge = $this->_readLine())) {
            return $challenge;
        }
        if (substr($challenge, 0, 1) != '+') {
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $challenge);
            }

            return new PEAR_Error();
        }

        /*
        * We don't use the protocol's third step because POP3 doesn't allow
        * subsequent authentication, so we just silently ignore it.
        */

        if (PEAR::isError($err = $this->_writeLine(''))) {
            return $err;
        }

        return $this->_readResponse($data);
    }

    /**
     * Parses the response from the capability command. Stores
     * the result in $this->_capability
     *
     * @return mixed true or PEAR_Error.
     */
    function cmdCAPA()
    {
        if (PEAR::isError($err = $this->_command('CAPA'))) {
            return $err;
        }
        if (PEAR::isError($success = $this->_readResponse($data))) {
            return $success;
        }
        if ($success === false) {
            return true;
        }
        if (PEAR::isError($data = $this->_readMultiline())) {
            return $data;
        }
        $data = preg_split('/\r?\n/', $data, -1, PREG_SPLIT_NO_EMPTY);

        for ($i = 0; $i < count($data); $i++) {

            $capa = '';
            if (preg_match('/^([a-z,\-]+)( ((.*))|$)$/i', $data[$i], $matches)) {

                $capa = strtolower($matches[1]);
                switch ($capa) {
                    case 'implementation':
                        $this->_capability['implementation'] = $matches[3];
                        break;
                    case 'sasl':
                        if (count($matches) > 3) {
                            $this->_capability['sasl'] = preg_split('/\s+/', $matches[3]);
                        }
                        break;
                    default :
                        $this->_capability[$capa] = $matches[2];
                        break;
                }
            }
        }

        return true;
    }

    /**
     * Sends the AUTH command.
     *
     * @return mixed true or PEAR_Error.
     */
    function cmdAUTH()
    {
        if (PEAR::isError($err = $this->_command('AUTH'))) {
            return $err;
        }
        if (PEAR::isError($success = $this->_readResponse($data))) {
            return $success;
        }
        if ($success === false) {
            return new PEAR_Error();
        }

        return $this->_readMultilineAsArray();
    }

    /**
     * Sends the APOP command
     *
     * @param  $user Username to send
     * @param  $pass Password to send
     *
     * @return mixed true or PEAR_Error.
     */
    function cmdAPOP($user, $pass)
    {
        assert('!is_null( $user )');
        assert('!is_null( $pass )');

        if ( ! isset($this->_timestamp)) {
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(-1, cb_msg('fw.mail', 'APOP isn\'t available on this server.'));
            }

            return new PEAR_Error();
        }
        if (PEAR::isError($err = $this->_command('APOP ' . $user . ' ' . md5($this->_timestamp . $pass)))) {
            return $err;
        }

        return $this->_readResponse($data);
    }

    /**
     * Sends the USER command
     *
     * @param  $user Username to send
     *
     * @return mixed true or PEAR_Error.
     */
    function cmdUSER($user)
    {
        assert('!is_null( $user )');

        if (PEAR::isError($err = $this->_command('USER ' . $user))) {
            return $err;
        }
        if (PEAR::isError($success = $this->_readResponse($data))) {
            return $success;
        }
        if ($success === false) {
            return new PEAR_Error();
        }

        return true;
    }

    /**
     * Sends the PASS command
     *
     * @param  $pass Password to send
     *
     * @return mixed true or PEAR_Error.
     */
    function cmdPASS($pass)
    {
        assert('!is_null( $pass )');

        if (PEAR::isError($err = $this->_command('PASS ' . $pass))) {
            return $err;
        }

        return $this->_readResponse($data);
    }

    /**
     * Sends the STAT command
     *
     * @return mixed true or PEAR_Error.
     */
    function &cmdSTAT()
    {
        if (PEAR::isError($err = $this->_command('STAT'))) {
            return $err;
        }
        if (PEAR::isError($success = $this->_readResponse($data))) {
            return $success;
        }
        if ($success === false) {
            $ret = new PEAR_Error();

            return $ret;
        }
        sscanf($data, '+OK %d %d', $count, $size);
        $ret = [
            'count' => $count,
            'size'  => $size
        ];

        return $ret;
    }

    var $_maildropList;

    /**
     * Sends the LIST command
     *
     * @return mixed true or PEAR_Error.
     */
    function &cmdLIST()
    {
        if (PEAR::isError($err = $this->_command('LIST'))) {
            return $err;
        }
        if (PEAR::isError($success = $this->_readResponse($data))) {
            return $success;
        }
        if ($success === false) {
            $ret = new PEAR_Error();

            return $ret;
        }
        $this->_maildropList = [];
        if (PEAR::isError($err = $this->_readMultilineByCallback("_cmdLISThandler"))) {
            return $err;
        }

        return $this->_maildropList;
    }

    function _cmdLISThandler($line)
    {
        assert('!is_null( $line )');

        sscanf($line, '%s %s', $msgnum, $size);
        $this->_maildropList[$msgnum] = $size;
    }

    /**
     * Sends the RETR command
     *
     * @param  $msgnum The message number to retrieve
     *
     * @return mixed   The message or PEAR_Error
     */
    function &cmdRETR($msgnum)
    {
        assert('!is_null( $msgnum )');

        if (PEAR::isError($err = $this->_command('RETR ' . $msgnum))) {
            return $err;
        }
        if (PEAR::isError($success = $this->_readResponse($data))) {
            return $success;
        }
        if ($success === false) {
            $ret = new PEAR_Error();

            return $ret;
        }
        $ret = $this->_readMultilineToFile();

        return $ret;
    }

    /**
     * Sends the DELE command
     *
     * @param  $msgnum Message number to mark as deleted
     *
     * @return mixed true or PEAR_Error.
     */
    function cmdDELE($msgnum)
    {
        assert('!is_null( $msgnum )');

        if (PEAR::isError($err = $this->_command('DELE ' . $msgnum))) {
            return $err;
        }
        if (PEAR::isError($success = $this->_readResponse($data))) {
            return $success;
        }
        if ($success === false) {
            return new PEAR_Error();
        }

        return true;
    }

    /**
     * Sends the RSET command
     *
     * @return mixed true or PEAR_Error.
     */
    function cmdRSET()
    {
        unset($this->_maildropList);
        if (PEAR::isError($err = $this->_command('RSET'))) {
            return $err;
        }
        if (PEAR::isError($success = $this->_readResponse($data))) {
            return $success;
        }
        if ($success === false) {
            return new PEAR_Error();
        }

        return true;
    }

    /**
     * Sends the QUIT command
     *
     * @return mixed true or PEAR_Error.
     */
    function cmdQUIT()
    {
        if (PEAR::isError($err = $this->_command('QUIT'))) {
            return $err;
        }
        if (PEAR::isError($success = $this->_readResponse($data))) {
            return $success;
        }
        if ($success === false) {
            return new PEAR_Error();
        }

        return true;
    }

    var $_headers;

    /**
     * Sends the TOP command
     *
     * @param  $msgnum    Message number
     *
     * @return mixed headers or PEAR_Error
     */
    function cmdTOP($msgnum)
    {
        assert('!is_null( $msgnum )');

        if (PEAR::isError($err = $this->_command('TOP ' . $msgnum . ' 0'))) {
            return $err;
        }
        if (PEAR::isError($success = $this->_readResponse($data))) {
            return $success;
        }
        if ($success === false) {
            return new PEAR_Error();
        }
        $this->_headers = [];
        if (PEAR::isError($err = $this->_readMultilineByCallback('_cmdTOPhandler'))) {
            return $err;
        }
        $map =& $this->_headers;
        foreach ($map as $key => $val) {
            $headers =& $map[$key];
            for ($i = 0; $i < count($headers); ++$i) {
                $headers[$i]->value = $headers[$i]->value;
            }
        }

        return $this->_headers;
    }

    function _cmdTOPhandler($line)
    {
        assert('!is_null( $line )');

        $head = substr($line, 0, 1);
        if ($head == ' ' or $head == "\t") {
            // Unfold header value.
            if ( ! empty($this->_headers)) {
                $last =& $this->_headers[$this->_name];
                $last[key($last)]->value .= $line;
            }
        } else {
            $pos = strpos($line, ':');
            if ($pos !== false) {
                $name = substr($line, 0, $pos);
                $value = ltrim(substr($line, $pos + 1));
                $header = new CB_MailHeader($name, $value);
                $name = strtolower($name);
                if (isset($this->_headers[$name])) {
                    $this->_headers[$name][] = $header;
                    end($this->_headers[$name]);
                } else {
                    $this->_headers[$name] = [$header];
                }
                $this->_name = $name;
            }
        }
    }

    var $msgnumToUID;

    /**
     * Sends the UIDL command
     *
     * @param  $msgnum Message number
     *
     * @return mixed true or PEAR_Error.
     */
    function &cmdUIDL()
    {
        if (PEAR::isError($err = $this->_command('UIDL'))) {
            return $err;
        }
        if (PEAR::isError($success = $this->_readResponse($data))) {
            return $success;
        }
        if ($success === false) {
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(-1, $data);
            }
            $ret = new PEAR_Error();

            return $ret;
        }
        $this->_msgnumToUID = [];
        if (PEAR::isError($err = $this->_readMultilineByCallback('cmdUIDLhandler'))) {
            return $err;
        }

        return $this->_msgnumToUID;
    }

    function cmdUIDLhandler($line)
    {
        assert('!is_null( $line )');

        sscanf($line, '%s %s', $msgnum, $uid);
        $this->_msgnumToUID[$msgnum] = $uid;
    }

    /**
     * Sends a command, checks the reponse, and
     * if good returns the reponse, other wise
     * returns false.
     *
     * @param  $cmd  Command to send (\r\n will be appended )
     *
     * @return mixed First line of response if successful, otherwise false or error.
     */
    function _command($cmd)
    {
        if (PEAR::isError($data = $this->_writeLine($cmd))) {
            return $data;
        }

        return true;
    }

    /**
     * Read line and checks the reponse, and
     * if good returns the reponse, other wise
     * returns false.
     *
     * @return mixed First line of response if successful, otherwise false or error.
     */
    function _readResponse(&$data)
    {
        if (PEAR::isError($str = $this->_readLine())) {
            return $str;
        }
        $data = $str;
        if (strlen($data) >= 3 && substr($data, 0, 3) == '+OK') {
            return true;
        } else {
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $data);
            }

            return false;
        }
    }

    /**
     * Send the given string of data to the server.
     *
     * @param   string $data The string of data to send.
     *
     * @return  mixed   True on success or a PEAR_Error object on failure.
     *
     * @access  private
     */
    function _writeLine($data)
    {
        if ( ! is_null($this->_logger)) {
            if ($this->_logger->isDebugEnabled()) {
                $this->_logger->debug("C: $data");
            }
        }

        if (PEAR::isError($err = $this->_socket->writeLine($data))) {
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(-1, cb_msg('fw.mail', 'Failed to write data.'));
            }
            if ( ! is_null($this->_logger)) {
                $this->_logger->debug($err->getMessage());
            }

            return $err;
        }

        return true;
    }

    /**
     * Reads a multiline reponse and returns the data.
     *
     * @return mixed the reponse or PERA_Error.
     * @access private
     */
    function &_readMultiline()
    {
        $data = '';
        $newline = '';
        for (; ;) {
            $line = $this->_readutil->readLine();
            if (PEAR::isError($line)) {
                return $line;
            } elseif ($line === '.') {
                return $data;
            } elseif (substr($line, 0, 2) == '..') {
                $data .= $newline . substr($line, 1);
                $newline = "\r\n";
            } else {
                $data .= $newline . $line;
                $newline = "\r\n";
            }
        }
    }

    function &_readMultilineToFile()
    {
        $newline = '';
        $tmp_dir = cb_tmpdir();
        $tmp_filename = tempnam($tmp_dir, 'mail');
        $tmp_fp = fopen($tmp_filename, 'w');
        for (; ;) {
            $line = $this->_readutil->readLine();
            if (PEAR::isError($line)) {
                fclose($tmp_fp);

                return $line;
            } elseif ($line === '.') {
                fclose($tmp_fp);

                return $tmp_filename;
            } elseif (substr($line, 0, 2) == '..') {
                fwrite($tmp_fp, $newline . substr($line, 1));
                $newline = "\r\n";
            } else {
                fwrite($tmp_fp, $newline . $line);
                $newline = "\r\n";
            }
        }
    }

    /**
     * Reads a multiline reponse and returns the data as array.
     *
     * @return mixed array or PEAR_Error
     * @access private
     */
    function &_readMultilineAsArray()
    {
        $data = [];
        for (; ;) {
            $line = $this->_readutil->readLine();
            if (PEAR::isError($line)) {
                return $line;
            } elseif ($line === '.') {
                return $data;
            } elseif (substr($line, 0, 2) == '..') {
                $data[] = substr($line, 1);
            } else {
                $data[] = $line;
            }
        }
    }

    /**
     * Reads a multiline reponse and pass each line to callback function.
     *
     * @return mixed true or PEAR_Error.
     * @access private
     */
    function &_readMultilineByCallback($handler)
    {
        if (PEAR::isError($data = $this->_readMultiLineAsArray())) {
            return $data;
        }
        $len = count($data);
        for ($i = 0; $i < $len; ++$i) {
            $this->$handler($data[$i]);
        }
        $ret = true;

        return $ret;
    }

    /**
     * Receive the given string of data from the server.
     *
     * @return  mixed   a line of response on success or a PEAR_Error object on failure.
     *
     * @access  private
     */
    function &_readLine()
    {
        $line = $this->_readutil->readLine();
        if (PEAR::isError($line)) {
            return $line;
        } else {
            return $line;
        }
    }
}

/**
 * A Implementation of mail message that fetches content from the POP3 server.
 *
 * @package fw.mail
 */
class CB_MailPOP3Message extends CB_MailLazyMessage
{
    /**
     * The protocol handler.
     *
     * @var CB_MailPOP3Protocol
     * @access private
     */
    var $_p;

    /**
     * Message number that is gotten by LIST.
     *
     * @var int
     * @access private
     */
    var $_msgnum;

    /**
     * Message size.
     *
     * @var int
     * @access private
     */
    var $_size;

    var $_error_code = 'FW00040';

    /**
     * The constractor.
     *
     * @param object  $p      CB_MailPOP3Protocol protocol handler.
     * @param integer $msgnum POP3 message number.
     * @param integer $size   message size
     *
     * @access protected
     */
    function __construct($p, $msgnum, $size)
    {
        assert('is_a( $p, "CB_MailPOP3Protocol" )');
        assert('!is_null( $msgnum)');
        assert('!is_null( $size )');

        parent::__construct();
        $this->_p = $p;
        $this->_msgnum = $msgnum;
        $this->_size = $size;
    }

    function setThrowError($error_code)
    {
        $this->_error_code = $error_code;
    }

    function throwError($message = '')
    {
        if ( ! is_null($this->_error_code)) {
            cb_throw_error($this->_error_code,
                ['info' => $message],
                ['info' => $message],
                ['info' => $message],
                ['info' => $message]);
        }
    }

    /**
     * Message size gotten from the server.
     *
     * @return integer
     */
    function getSize()
    {
        return $this->_size;
    }

    /**
     * If _name_to_headers has not been set
     * which fetches header from the server.
     *
     * @access private
     */
    function _fetchHeaders()
    {
        if (isset($this->_name_to_headers)) {
            return true;
        }

        //if ( PEAR::isError( $data = $this->_p->cmdTOP( $this->_msgnum ) ) ) {     
        //@2008/07/23 : Not use TOP command to improve the performance when receive mail
        if (PEAR::isError($err = $this->_fetchSource())) {
            $this->throwError();

            return $err;
        }

        return true;
        //}
        //$this->_name_to_headers =& $data;
        //return true;
    }

    /**
     * If _source_data has not been set
     * whitch fetches body.
     *
     * @access private
     */
    function _fetchSource()
    {
        if (isset($this->_source_data)) {
            return true;
        }

        if (PEAR::isError($data =& $this->_p->cmdRETR($this->_msgnum))) {
            $this->throwError();

            return $data;
        }
        $this->_source_data = file_get_contents($data);
        $message = CB_MailParser::static_parse($data, 'file');
        unlink($data);

        //$message =& CB_MailParser::static_parse( $this->_source_data, 'var' );
        $this->_name_to_headers =& $message->_name_to_headers;
        $this->_setBody($message->_body);

        return true;
    }

    function getAllRawHeaders()
    {
        $raw_headers = $this->_p->cmdTOP($this->_msgnum);
        if (PEAR::isError($raw_headers)) {
            return false;
        }

        $_header = [];
        foreach ($raw_headers as $key => $data) {
            $_header[$key] = $this->_decodeHeader($data[0]);
        }

        return $_header;
    }
}


