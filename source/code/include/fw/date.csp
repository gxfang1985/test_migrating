<?php

/**
 * Date utilities.
 *
 * @package fw.datetime
 */

require_once('fw/persistent.csp');
require_once('fw/basic_date.csp');
require_once('fw/i18n.csp');
require_once('fw/error_code.csp');
require_once('fw/error_trace_log.csp');

define('CB_TZINFO_CACHE_PRIFIX', 'fw.date.timezone_info');

define('GRN_WORKFLOW_DATE_FORMAT', 'DateWorkflow');
define('GRN_WORKFLOW_DATETIME_FORMAT', 'DateTimeWorkflow');

define('CB_DATE_YEAR_VALUE_BLANK', 'BlankValueYear');
define('CB_DATE_MONTH_VALUE_BLANK', 'BlankValueMonth');
define('CB_DATE_DAY_VALUE_BLANK', 'BlankValueDay');
define('CB_DATE_WDAY_VALUE_BLANK', 'BlankValueWday');
define('CB_DATE_HOUR_VALUE_BLANK', 'BlankValueHour');
define('CB_DATE_MINUTE_VALUE_BLANK', 'BlankValueMinute');
define('CB_DATE_SECOND_VALUE_BLANK', 'BlankValueSecond');

/**
 * This file is just unserialized for plugin_fw_timezone_jst object which was serialized at Garoon 2.5.x.
 * Ideally, such objects should have been replaced when Garoon was upgraded....
 */
require_once(cb_basedir() . '/code/plugin/fw/timezone/jst.csp');

/**
 * Format date in string
 *
 * @param string|null                                          $format_key
 * @param CB_Date|CB_DateTime|CB_Time|CB_TimeStamp|string|null $date
 * @param string|null                                          $user_id
 * @param string|null                                          $tzname
 * @param string|null                                          $language
 *
 * @return string
 */
function cb_date_format(
    $format_key = null,
    $date = null,
    $user_id = null,
    $tzname = null,
    $language = null
) {
    if (is_null($format_key)) {
        $format_key = "DateTimeCompact";
    }

    return CB_DateFormat::getDateTimeFormat($format_key, $date, $user_id,
        $tzname, $language);
}

define("CB_DateFormat_FORMAT_IN_TEMPLATE_FILE", null);

class CB_DateFormat
{
    private static $formats
        = [
            'DateFull_Y'        => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'DateFull_M'        => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'DateFull_D'        => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'DateFull_YM'       => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'DateFull_MD'       => 'ShortDateFormat',
            'DateFull_YMD'      => 'LongDateFormat',
            'DateFull_YMDW'     => 'LongDateFormat',
            'Date_YYYYMMDD_ICS' => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'DateLong_YM'       => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'DateLong_YMD'      => 'LongDateFormat',
            'DateLong_YMDW'     => 'LongDateFormat',
            'DateMiddle_YM'     => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'DateMiddle_YMD'    => 'LongDateFormat',
            'DateMiddle_YMDW'   => 'LongDateFormat',
            'DateShort_MD'      => 'ShortDateFormat',
            'DateShort_MDW'     => 'ShortDateFormat',
            'DateShort_YM'      => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'DateShort_YMD'     => 'LongDateFormat',
            'DateShort_YMDW'    => 'LongDateFormat',

            'DateTimeFull_YMDW_HM'   => ['LongDateFormat', 'TimeFormat'],
            'DateTimeFull_YMD_HM'    => ['LongDateFormat', 'TimeFormat'],
            'DateTimeLong_YMDW_HM'   => ['LongDateFormat', 'TimeFormat'],
            'DateTimeLong_YMD_HM'    => ['LongDateFormat', 'TimeFormat'],
            'DateTimeMiddle_YMDW_HM' => ['LongDateFormat', 'TimeFormat'],
            'DateTimeMiddle_YMD_HM'  => ['LongDateFormat', 'TimeFormat'],
            'DateTimeShort_YMDW_HM'  => ['LongDateFormat', 'TimeFormat'],
            'DateTimeShort_YMD_HM'   => ['LongDateFormat', 'TimeFormat'],
            'DateTime_YYYYMMDD_ICS'  => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'TimeLong_H'             => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'TimeLong_HM'            => 'TimeFormat',
            'TimeLong_HMS'           => 'TimeFormat',
            'TimeShort_H'            => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'TimeShort_HM'           => 'TimeFormat',
            'TimeShort_HMS'          => 'TimeFormat',
            'TimeShort_ICS'          => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'DateTimeCompact'        => 'DateTimeCompact',
            'Date_DW'                => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,

            'DateWorkflow'     => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'DateTimeWorkflow' => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,

            'LongDateFormat'             => 'LongDateFormat',
            'ShortDateFormat'            => 'ShortDateFormat',
            'TimeFormat'                 => 'TimeFormat',
            'Blank'                      => CB_DateFormat_FORMAT_IN_TEMPLATE_FILE,
            'DateTimeDetail_ShortFormat' => ['ShortDateFormat', 'TimeFormat'],
        ];

    private static $format_cache = [];

    /**
     * Determine date format from timestamp value
     *
     * @param  CB_Date|CB_DateTime|CB_Time|CB_TimeStamp|string|null $date
     * @param  string|null                                          $tzname
     *
     * @return string               date format
     */
    public static function getCompactFormat($date, $tzname = null)
    {
        $dt = _cb_date_convert_to_datetime($date, $tzname);
        $now = cb_timestamp_to_datetime();

        if ($dt->year != $now->year) {
            $format_id = 'LongDateFormat';
        } elseif ($dt->month != $now->month || $dt->day != $now->day) {
            $format_id = 'ShortDateFormat';
        } else {
            $format_id = 'TimeFormat';
        }

        return $format_id;
    }

    /**
     * Today -> TimeFormat
     * Same year, but not Today -> ShortDateFormat + TimeFormat
     * Different year -> LongDateFormat + TimeFormat
     *
     * @param CB_Date|CB_DateTime|CB_Time|CB_TimeStamp|string|null $date
     * @param string|null                                          $tzname
     *
     * @return string
     */
    public static function getCompactDateTimeDetailFormat($date, $tzname = null)
    {
        $dt = _cb_date_convert_to_datetime($date, $tzname);
        $now = cb_timestamp_to_datetime();
        if ($dt->year == $now->year && $dt->month == $now->month
            && $dt->day == $now->day
        ) {
            return 'TimeFormat';
        }
        if ($dt->year == $now->year) {
            return self::$formats['DateTimeDetail_ShortFormat'];
        }

        return self::$formats['DateTimeFull_YMDW_HM'];
    }

    /**
     * @param string                                               $inFormatKey
     * @param CB_Date|CB_DateTime|CB_Time|CB_TimeStamp|string|null $inDate
     * @param string|null                                          $inUserId
     * @param string|null                                          $inTimezoneName
     * @param string|null                                          $inLanguage
     *
     * @return string
     */
    private static function stringKey2DateTime(
        $inFormatKey,
        $inDate,
        $inUserId,
        $inTimezoneName,
        $inLanguage
    ) {
        $dateArray = cb_date_datetime2array($inDate, $inLanguage,
            $inTimezoneName);

        if ($inFormatKey == "LongDateFormat") {
            return cb_fillInTemplate(static::getCurrentLongDateFormat($inUserId),
                $dateArray);
        } elseif ($inFormatKey == "ShortDateFormat") {
            return cb_fillInTemplate(static::getCurrentShortDateFormat($inUserId),
                $dateArray);
        } elseif ($inFormatKey == "TimeFormat") {
            return cb_fillInTemplate(static::getCurrentTimeFormat($inUserId),
                $dateArray);
        } elseif (strpos($inFormatKey, '&&') !== false) {
            require_once("fw/i18n.csp");

            return cb_fillInTemplate($inFormatKey, $dateArray);
        }
        assert(false);

        return "Error: Invalid format key was given.";
    }

    /**
     * @param string|null $inUserId
     *
     * @return string
     */
    protected static function getCurrentLongDateFormat($inUserId)
    {
        require_once("fw/i18n/locale.csp");

        return CB_LocaleManager::getCurrentLongDateFormat($inUserId);
    }

    /**
     * @param string|null $inUserId
     *
     * @return string
     */
    protected static function getCurrentShortDateFormat($inUserId)
    {
        require_once("fw/i18n/locale.csp");

        return CB_LocaleManager::getCurrentShortDateFormat($inUserId);
    }

    /**
     * @param string|null $inUserId
     *
     * @return string
     */
    protected static function getCurrentTimeFormat($inUserId)
    {
        require_once("fw/i18n/locale.csp");

        return CB_LocaleManager::getCurrentTimeFormat($inUserId);
    }

    /**
     * @param string                                               $inFormat
     * @param CB_Date|CB_DateTime|CB_Time|CB_TimeStamp|string|null $inDate
     * @param string                                               $inTimezoneName
     *
     * @return string
     */
    private static function convertFormatKey(
        $inFormat,
        $inDate,
        $inTimezoneName
    ) {
        if ($inFormat == "DateTimeCompact") {
            return self::getCompactFormat($inDate, $inTimezoneName);
        }
        if ($inFormat == 'DateTimeDetailCompact') {
            return self::getCompactDateTimeDetailFormat($inDate,
                $inTimezoneName);
        }
        if (array_key_exists($inFormat, self::$formats)) {
            return self::$formats[$inFormat];
        }

        return $inFormat;
    }

    /**
     * @param string                                               $inFormatKey
     * @param CB_Date|CB_DateTime|CB_Time|CB_TimeStamp|string|null $inDate
     * @param string|null                                          $inUserId
     * @param string|null                                          $inTimezoneName
     * @param string|null                                          $inLanguage
     * @param int|null                                             $isSystem
     *
     * @return string
     */
    public static function getDateTimeFormat(
        $inFormatKey,
        $inDate,
        $inUserId = null,
        $inTimezoneName = null,
        $inLanguage = null,
        $isSystem = null
    ) {
        $formatKey = self::convertFormatKey($inFormatKey, $inDate,
            $inTimezoneName);

        $userId = $inUserId;
        if (is_null($userId)) {
            global $G_container_base;
            /** @var GRN_Uum $uum */
            $uum = $G_container_base->getInstance("uum");
            $loginUser = $uum->getLoginUser();
            if ($loginUser) {
                $userId = $loginUser->getOID();
            }
        }

        $language = $inLanguage;
        if (is_null($language)) {
            if (is_null($userId)) {
                require_once("fw/i18n.csp");
                $i18n = CB_I18N::getInstance();
                $language = $i18n->getCurrentLanguage();
            } else {
                $language = CB_LocaleManager::getCurrentLanguage($userId);
            }
        }

        $cacheKey = (is_array($formatKey) ? implode(' ', $formatKey)
                : $formatKey)
                    . "-" . $inFormatKey
                    . "-" . serialize($inDate)
                    . "-" . $userId
                    . "-" . $language
                    . "-" . $inTimezoneName
                    . "-" . $isSystem;

        if (isset(self::$format_cache[$cacheKey])) {
            return self::$format_cache[$cacheKey];
        }

        if ($formatKey == CB_DateFormat_FORMAT_IN_TEMPLATE_FILE) {
            $dateArray = cb_date_datetime2array($inDate,
                $language, $inTimezoneName);
            self::$format_cache[$cacheKey] = cb_msg("fw.date", $inFormatKey,
                $dateArray, $language);

            return self::$format_cache[$cacheKey];
        } elseif (is_string($formatKey)) {
            self::$format_cache[$cacheKey]
                = static::stringKey2DateTime($formatKey, $inDate, $userId,
                $inTimezoneName, $language);

            return self::$format_cache[$cacheKey];
        } elseif (is_array($formatKey)) {
            $ret = [];
            foreach ($formatKey as $eachFormatKey) {
                $ret[] = self::stringKey2DateTime($eachFormatKey, $inDate,
                    $userId, $inTimezoneName, $language);
            }
            self::$format_cache[$cacheKey] = implode(" ", $ret);

            return self::$format_cache[$cacheKey];
        }
        assert(false);
    }
}

class CB_DateFormatSystem extends CB_DateFormat
{
    /**
     * @param string|null $inUserId
     *
     * @return string
     */
    protected static function getCurrentLongDateFormat($inUserId)
    {
        require_once("fw/i18n/system_config.csp");

        return CB_I18N_SystemConfig::getPrintLongDateFormat();
    }

    /**
     * @param string|null $inUserId
     *
     * @return string
     */
    protected static function getCurrentShortDateFormat($inUserId)
    {
        require_once("fw/i18n/system_config.csp");

        return CB_I18N_SystemConfig::getPrintShortDateFormat();
    }

    /**
     * @param string|null $inUserId
     *
     * @return string
     */
    protected static function getCurrentTimeFormat($inUserId)
    {
        require_once("fw/i18n/system_config.csp");

        return CB_I18N_SystemConfig::getPrintTimeFormat();
    }
}

/**
 * Function for performance problem
 *
 * @param string $key
 * @param string $language
 *
 * @return string
 */
function _cb_date_getMessage($key, $language)
{
    static $messageCaches = [];
    if ( ! isset($messageCaches[$key][$language])) {
        $messageCaches[$key][$language] = cb_msg('fw.date', $key, null,
            $language);
    }

    return $messageCaches[$key][$language];
}

/**
 * @param CB_Date|CB_DateTime|CB_Time|CB_TimeStamp|string|null $date
 * @param string|null                                          $language
 * @param string|null                                          $tzname
 *
 * @return array
 */
function cb_date_datetime2array($date, $language = null, $tzname = null)
{
    $dt = _cb_date_convert_to_datetime($date, $tzname);

    $tempYear = $dt->year;
    $tempMonth = $dt->month;
    $tempDay = $dt->day;
    $tempHour = $dt->hour;
    $tempMinute = $dt->minute;
    $tempSecond = $dt->second;
    $isWdayPossible = true;

    $resultArray = [];

    if (is_numeric($tempYear) && 1970 <= $tempYear && $tempYear <= 2037) {
        $resultArray['year'] = $tempYear;
        $resultArray['year00'] = sprintf("%02d", $tempYear);
    } else {
        $tempYear = _cb_date_getMessage(CB_DATE_YEAR_VALUE_BLANK,
            $language);
        $resultArray['year'] = $tempYear;
        $resultArray['year00'] = $tempYear;
        $isWdayPossible = false;
    }

    if (is_numeric($tempMonth) && 1 <= $tempMonth && $tempMonth <= 12) {
        $resultArray['mon0sprs'] = $tempMonth;
        $resultArray['mon'] = sprintf("%02d", $tempMonth);
        $resultArray['monthshort']
            = _cb_date_getMessage("MonthShort{$tempMonth}",
            $language);
        $resultArray['monthfull']
            = _cb_date_getMessage("MonthFull{$tempMonth}",
            $language);
    } else {
        $tempMonth = _cb_date_getMessage(CB_DATE_MONTH_VALUE_BLANK,
            $language);
        $resultArray['mon0sprs'] = $tempMonth;
        $resultArray['mon'] = $tempMonth;
        $resultArray['monthshort'] = $tempMonth;
        $resultArray['monthfull'] = $tempMonth;
        $isWdayPossible = false;
    }

    if (is_numeric($tempDay) && 1 <= $tempDay && $tempDay <= 31) {
        $resultArray['mday0sprs'] = $tempDay;
        $resultArray['mday'] = sprintf("%02d", $tempDay);
    } else {
        $tempDay = _cb_date_getMessage(CB_DATE_DAY_VALUE_BLANK,
            $language);
        $resultArray['mday0sprs'] = $tempDay;
        $resultArray['mday'] = $tempDay;
        $isWdayPossible = false;
    }

    if ($isWdayPossible) {
        $wday_num = cb_get_day_of_week($dt->year, $dt->month,
            $dt->day);
        $resultArray['wdayshort'] = _cb_date_getMessage("WDayShort{$wday_num}",
            $language);
        $resultArray['wdayfull'] = _cb_date_getMessage("WDayFull{$wday_num}",
            $language);
    } else {
        $tempWday = _cb_date_getMessage(CB_DATE_WDAY_VALUE_BLANK,
            $language);
        $resultArray['wdayshort'] = $tempWday;
        $resultArray['wdayfull'] = $tempWday;
    }

    if (is_numeric($tempHour) && 0 <= $tempHour && $tempHour <= 23) {
        $tempHours12 = $tempHour % 12;
        $tempNotationshort = ($tempHour < 12) ? 'AM' : 'PM';
        $resultArray['hours12'] = $tempHours12 ? sprintf('%02d',
            $tempHours12) : 12;
        $resultArray['notationshort'] = $tempNotationshort;
        $resultArray['notation'] = _cb_date_getMessage($tempNotationshort,
            $language);
        $resultArray['hours0sprs'] = $tempHour;
        $resultArray['hours'] = sprintf("%02d",
            $tempHour); //$TWO_DIGIT_TEMPLATE[$tempHour];
    } else {
        $tempHour = _cb_date_getMessage(CB_DATE_HOUR_VALUE_BLANK,
            $language);
        $resultArray['hours12'] = $tempHour;
        $resultArray['notationshort'] = $tempHour;
        $resultArray['notation'] = $tempHour;
        $resultArray['hours0sprs'] = $tempHour;
        $resultArray['hours'] = $tempHour;
    }

    if (is_numeric($tempMinute) && 0 <= $tempMinute && $tempMinute <= 59) {
        $resultArray['minutes'] = $tempMinute;
        $resultArray['minutes00'] = sprintf('%02d',
            $tempMinute); //$TWO_DIGIT_TEMPLATE[$tempMinute];
    } else {
        $tempMinute = _cb_date_getMessage(CB_DATE_MINUTE_VALUE_BLANK,
            $language);
        $resultArray['minutes'] = $tempMinute;
        $resultArray['minutes00'] = $tempMinute;
    }

    if (is_numeric($tempSecond) && 0 <= $tempSecond && $tempSecond <= 59) {
        $resultArray['seconds'] = $tempSecond;
        $resultArray['seconds00'] = sprintf("%02d",
            $tempSecond); //$TWO_DIGIT_TEMPLATE[$tempSecond];
    } else {
        $tempSecond = _cb_date_getMessage(CB_DATE_SECOND_VALUE_BLANK,
            $language);
        $resultArray['seconds'] = $tempSecond;
        $resultArray['seconds00'] = $tempSecond;
    }

    return $resultArray;
}

/**
 * Convert string or object to timestamp.
 *
 * @param  CB_Date|CB_DateTime|CB_Time|CB_TimeStamp|string|null $date   date(-time) value
 * @param  string|null                                          $tzname timezone value
 *
 * @return int timestamp
 */
function cb_date_convert2timestamp($date, $tzname = null)
{
    $ts = new CB_TimestampEx(new CB_Timestamp);
    $dt = _cb_date_convert_to_datetime($date, $tzname);
    $ts->setDateTime($dt, $tzname);

    return $ts->unix_ts;
}

/**
 * Determine date format from timestamp value
 *
 * @param  CB_Date|CB_DateTime|CB_Time|CB_TimeStamp|string|null $date
 * @param  string|null                                          $tzname
 *
 * @return string               compact date format
 */
function cb_date_compact_format($date, $tzname = null)
{
    $dt = _cb_date_convert_to_datetime($date, $tzname);
    $now = cb_timestamp_to_datetime();

    if ($dt->year != $now->year) {
        $format_id = 'DateMiddle_YMDW';
    } elseif ($dt->month != $now->month || $dt->day != $now->day) {
        $format_id = 'DateShort_MDW';
    } else {
        $format_id = 'TimeShort_HM';
    }

    return $format_id;
}


/**
 * Converts into CB_DateTime.
 *
 * @access private
 *
 * @param  CB_Date|CB_DateTime|CB_Time|CB_TimeStamp|string|null $date
 * @param  string                                               $tzname
 *
 * @return CB_DateTime
 */
function _cb_date_convert_to_datetime($date, $tzname = null)
{
    $dt = new CB_DateTime;

    if (is_null($date)) {
        $ts = new CB_Timestamp;
        $ts->unix_ts = time();
        $ts_ex = new CB_TimestampEx($ts, $tzname);
        $now = $ts_ex->getDateTime();

        $dt->second = $now->second;
        $dt->minute = $now->minute;
        $dt->hour = $now->hour;
        $dt->day = $now->day;
        $dt->month = $now->month;
        $dt->year = $now->year;
    } elseif (is_object($date)) {
        if (is_a($date, 'CB_DateTime')) {
            $dt->second = $date->second;
            $dt->minute = $date->minute;
            $dt->hour = $date->hour;
            $dt->day = $date->day;
            $dt->month = $date->month;
            $dt->year = $date->year;
        } elseif (is_a($date, 'CB_Date')) {
            $dt->second = 0;
            $dt->minute = 0;
            $dt->hour = 0;
            $dt->day = $date->day;
            $dt->month = $date->month;
            $dt->year = $date->year;
        } elseif (is_a($date, 'CB_Time')) {
            $ts = new CB_Timestamp;
            $ts->unix_ts = time();
            $ts_ex = new CB_TimestampEx($ts, $tzname);
            $now = $ts_ex->getDateTime();

            $dt->second = $date->second;
            $dt->minute = $date->minute;
            $dt->hour = $date->hour;
            $dt->day = $now->day;
            $dt->month = $now->month;
            $dt->year = $now->year;
        } elseif (is_a($date, 'CB_Timestamp')) {
            $ts_ex = new CB_TimestampEx($date, $tzname);
            $dt = $ts_ex->getDateTime();
        } else {
            assert('is_a( $date, "CB_DateTime" ) ||
                     is_a( $date, "CB_Date" ) ||
                     is_a( $date, "CB_Time" ) ||
                     is_a( $date, "CB_Timestamp" )');
        }
    } elseif (is_string($date)) {
        $_datetime = new CB_DateTime;
        $_date = new CB_Date;
        $_time = new CB_Time;

        if ($_datetime->parse($date)) {
            $dt->second = $_datetime->second;
            $dt->minute = $_datetime->minute;
            $dt->hour = $_datetime->hour;
            $dt->day = $_datetime->day;
            $dt->month = $_datetime->month;
            $dt->year = $_datetime->year;
        } elseif ($_date->parse($date)) {
            $dt->second = 0;
            $dt->minute = 0;
            $dt->hour = 0;
            $dt->day = $_date->day;
            $dt->month = $_date->month;
            $dt->year = $_date->year;
        } elseif ($_time->parse($date)) {
            $ts = new CB_Timestamp;
            $ts->unix_ts = time();
            $ts_ex = new CB_TimestampEx($ts, $tzname);
            $now = $ts_ex->getDateTime();

            $dt->second = $_time->second;
            $dt->minute = $_time->minute;
            $dt->hour = $_time->hour;
            $dt->day = $now->day;
            $dt->month = $now->month;
            $dt->year = $now->year;
        } else {
            assert('$_datetime->parse( $date ) ||
                     $_date->parse( $date ) ||
                     $_time->parse( $date )');
        }
    } else {
        assert('is_object( $date ) ||
                 is_string( $date ) ');
    }

    return $dt;
}

/**
 * Extended date class that supports miscellaneous caclulations.
 * Instances of this class may be used as {@link CB_Date} since
 * this is a subclass of {@link CB_Date}.
 *
 * @package fw.datetime
 */
class CB_DateEx extends CB_Date
{
    /**
     * Constructor.
     * $date may be either an instance of {@link CB_Date} or its subclass,
     * or an instance of {@link CB_DateTime} or its subclass.
     *
     * @param CB_Date|CB_DateTime $date
     * @param string              $error_code
     */
    public function __construct($date, $error_code = E_COMMON_INVALID_DATE)
    {
        assert('is_object( $date ) && ( is_a( $date, \'cb_date\' ) || is_a( $date, \'cb_datetime\' ) )');

        $this->year = $date->year;
        $this->month = $date->month;
        $this->day = $date->day;

        if ( ! cb_date_validate_date($date)) {
            cb_throw_error($error_code);
        }
    }

    /**
     * @static
     *
     * @param array $state
     *
     * @return \CB_DateEx
     */
    static public function __set_state($state)
    {
        $date = new CB_Date();
        if (array_key_exists("year", $state)) {
            $date->year = $state["year"];
        }
        if (array_key_exists("month", $state)) {
            $date->month = $state["month"];
        }
        if (array_key_exists("day", $state)) {
            $date->day = $state["day"];
        }

        return new CB_DateEx($date);
    }

    /**
     * Compare a given object of date class.
     *
     * @param CB_Date|CB_DateTime $date
     *
     * @return int         < 0 if this object is less than $date,
     *                     > 0 if this object is greater than $date,
     *                     or 0 if they are equal.
     */
    function compare($date)
    {
        $ydiff = $this->year - $date->year;
        if ($ydiff !== 0) {
            return $ydiff;
        }

        $mdiff = $this->month - $date->month;
        if ($mdiff !== 0) {
            return $mdiff;
        }

        $ddiff = $this->day - $date->day;
        if ($ddiff !== 0) {
            return $ddiff;
        }

        return 0;
    }

    /**
     * Get the day of the week.
     *
     * @return int  The day of the week (0=Sunday).
     */
    function getDayOfWeek()
    {
        return cb_get_day_of_week($this->year, $this->month, $this->day);
    }

    /**
     * Add the amount of time.
     *
     * @param CB_DateTimeSpan $timespan The amount of time.
     */
    function add($timespan)
    {
        $days = intval($timespan->toDays());
        $this->moveDays($days);
    }

    /**
     * Subtract the amount of time.
     *
     * @param CB_DateTimeSpan $timespan The amount of time.
     */
    function sub($timespan)
    {
        $days = intval($timespan->toDays());
        $this->moveDays(-$days);
    }

    /**
     * Get number of days in the month.
     *
     * @return int  Number of days in this month.
     */
    function getEndOfMonthDay()
    {
        return cb_get_end_of_monthday($this->year, $this->month);
    }

    /**
     * Get the number of days plus 1 since the beginning of this year.
     * New year's day (January 1st) will return 1.
     *
     * @return int  The number of days since the beginning of this year.
     */
    function getDayOfYear()
    {
        return cb_get_day_of_year($this->year, $this->month, $this->day);
    }

    /**
     * Add/Subtract a given number of days.
     *
     * @param int $days Days to add/subtract.
     */
    function moveDays($days)
    {
        $jd = gregoriantojd($this->month, $this->day, $this->year);
        $jd += $days;
        list($month, $day, $year) = explode('/', jdtogregorian($jd));
        $this->month = intval($month);
        $this->day = intval($day);
        $this->year = intval($year);
    }

    /**
     * Add/Subtract a given number of weeks.
     *
     * @param int $weeks Weeks to add/subtract.
     */
    function moveWeeks($weeks)
    {
        $this->moveDays($weeks * 7);
    }

    /**
     * Add/Subtract a given number of months.
     *
     * @param int $months Months to add/subtract.
     */
    function moveMonths($months)
    {
        $this->year = intval(($this->year * 12 + $this->month - 1 + $months)
                             / 12);
        $this->month = ($this->year * 12 + $this->month - 1 + $months) % 12 + 1;

        $days = $this->getEndOfMonthDay();
        if ($this->day > $days) {
            $this->day = $days;
        }
    }

    /**
     * Add/Subtract a given number of years.
     * Feburary 29th may become truncated to 28.
     *
     * @param int $years Years to add/subtract.
     */
    function moveYears($years)
    {
        $this->year += $years;
        if ($this->month != 2) {
            return;
        }

        $days = $this->getEndOfMonthDay();
        if ($this->day > $days) {
            $this->day = $days;
        }
    }

    /**
     * Calculate the amount of time.
     *
     * @param CB_Date|CB_DateTime $date
     *
     * @return CB_DateTimeSpan  The amount of time.
     */
    function getInterval($date)
    {
        $interval = new CB_DateTimeSpan(
            (gregoriantojd($this->month, $this->day, $this->year) -
             gregoriantojd($date->month, $date->day, $date->year)) * 86400);

        return $interval;
    }

}

/**
 * Extended time class that supports miscellaneous caclulations.
 * Instances of this class may be used as {@link CB_Date} since
 * this is a subclass of {@link CB_Date}.
 *
 * @package fw.datetime
 */
class CB_TimeEx extends CB_Time
{
    /**
     * Constructor.
     * $time may be either an instance of {@link CB_Time} or its subclass,
     * or an instance of {@link CB_DateTime} or its subclass.
     *
     * @param CB_Time|CB_DateTime $time
     * @param string              $error_code
     */
    function __construct($time, $error_code = E_COMMON_INVALID_TIME)
    {
        assert('is_object( $time ) && ( is_a( $time, \'cb_time\' ) || is_a( $time, \'cb_datetime\' ) )');

        $this->hour = $time->hour;
        $this->minute = $time->minute;
        $this->second = $time->second;

        if ( ! cb_date_validate_time($time)) {
            cb_throw_error($error_code);
        }
    }

    /**
     * Compare a given object of time class.
     *
     * @param CB_Time|CB_DateTime $time
     *
     * @return int < 0 if this object is less than $time,
     *             > 0 if this object is greater than $time,
     *             or 0 if they are equal.
     */
    function compare($time)
    {
        $hdiff = $this->hour - $time->hour;
        if ($hdiff !== 0) {
            return $hdiff;
        }

        $mdiff = $this->minute - $time->minute;
        if ($mdiff !== 0) {
            return $mdiff;
        }

        $sdiff = $this->second - $time->second;
        if ($sdiff !== 0) {
            return $sdiff;
        }

        return 0;
    }

    /**
     * Add the amount of time.
     *
     * @param CB_DateTimeSpan $timespan The amount of time.
     */
    function add($timespan)
    {
        $seconds = $timespan->toSeconds();
        $this->moveSeconds($seconds);
    }

    /**
     * Subtract the amount of time.
     *
     * @param CB_DateTimeSpan $timespan The amount of time.
     */
    function sub($timespan)
    {
        $seconds = $timespan->toSeconds();
        $this->moveSeconds(-$seconds);
    }

    /**
     * Add/Subtract a given number of seconds.
     *
     * @param int $seconds Seconds to add/subtract.
     *
     * @return int          Over(under)flowed days.
     */
    function moveSeconds($seconds)
    {
        return intval($this->_parse($seconds + $this->_toSeconds()));
    }

    /**
     * Add/Subtract a given number of minutes.
     *
     * @param int $minutes Minutes to add/subtract.
     *
     * @return int          Over(under)flowed days.
     */
    function moveMinutes($minutes)
    {
        return intval($this->_parse($minutes * 60 + $this->_toSeconds()));
    }

    /**
     * Add/Subtract a given number of hours.
     *
     * @param int $hours Hours to add/subtract.
     *
     * @return int         Over(under)flowed days.
     */
    function moveHours($hours)
    {
        return intval($this->_parse($hours * 60 * 60 + $this->_toSeconds()));
    }

    /**
     * @access private
     *
     * @param int $seconds The amount of time in seonds.
     *
     * @return int          Over(under)flowed days.
     */
    function _parse($seconds)
    {
        $days = 0;
        if (0 > $seconds) {
            $days = intval($seconds / 86400) - 1;
            $seconds = 86400 + $seconds % 86400;
        }
        $this->second = $seconds % 60;
        $this->minute = intval($seconds / 60);
        $this->hour = intval($this->minute / 60);
        $this->minute %= 60;
        $days += intval($this->hour / 24);
        $this->hour %= 24;

        return $days;
    }

    /**
     * @access private
     * @return int  The amount of time in seconds.
     */
    function _toSeconds()
    {
        return $this->hour * 3600 + $this->minute * 60 + $this->second;
    }

    /**
     * Calculate the amount of time.
     *
     * @param CB_Time|CB_DateTime $time
     *
     * @return CB_DateTimeSpan  The amount of time in seconds.
     */
    function getInterval($time)
    {
        $interval = new CB_DateTimeSpan(
            ($this->hour * 3600 + $this->minute * 60 + $this->second) -
            ($time->hour * 3600 + $time->minute * 60 + $time->second));

        return $interval;
    }
}

/**
 * Extended date time class that supports miscellaneous caclulations.
 * Instances of this class may be used as {@link CB_DateTime} since
 * this is a subclass of {@link CB_DateTime}.
 *
 * @package fw.datetime
 */
class CB_DateTimeEx extends CB_DateTime
{
    /**
     * Constructor.
     *
     * @param CB_DateTime $datetime
     * @param string      $error_code
     */
    public function __construct(
        $datetime,
        $error_code = E_COMMON_INVALID_DATETIME
    ) {
        assert('is_object( $datetime ) && is_a( $datetime, \'cb_datetime\' )');

        $this->month = $datetime->month;
        $this->day = $datetime->day;
        $this->year = $datetime->year;
        $this->hour = $datetime->hour;
        $this->minute = $datetime->minute;
        $this->second = $datetime->second;

        if ( ! cb_date_validate_datetime($datetime)) {
            cb_throw_error($error_code);
        }
    }


    /**
     * @static
     *
     * @param $state
     *
     * @return CB_DateTimeEx
     */
    static public function __set_state($state)
    {
        $obj = new CB_DateTime();
        if (array_key_exists("year", $state)) {
            $obj->year = $state["year"];
        }
        if (array_key_exists("month", $state)) {
            $obj->month = $state["month"];
        }
        if (array_key_exists("day", $state)) {
            $obj->day = $state["day"];
        }
        if (array_key_exists("hour", $state)) {
            $obj->hour = $state["hour"];
        }
        if (array_key_exists("minute", $state)) {
            $obj->minute = $state["minute"];
        }
        if (array_key_exists("second", $state)) {
            $obj->second = $state["second"];
        }

        return new CB_DateTimeEx($obj);
    }


    /**
     * Compare a given object of date time class.
     *
     * @param CB_DateTime $datetime
     *
     * @return int  < 0 if this object is less than $datetime,
     *              > 0 if this object is greater than $datetime,
     *              or 0 if they are equal.
     */
    function compare($datetime)
    {
        $ydiff = $this->year - $datetime->year;
        if ($ydiff !== 0) {
            return $ydiff;
        }

        $mdiff = $this->month - $datetime->month;
        if ($mdiff !== 0) {
            return $mdiff;
        }

        $ddiff = $this->day - $datetime->day;
        if ($ddiff !== 0) {
            return $ddiff;
        }

        $hdiff = $this->hour - $datetime->hour;
        if ($hdiff !== 0) {
            return $hdiff;
        }

        $mdiff = $this->minute - $datetime->minute;
        if ($mdiff !== 0) {
            return $mdiff;
        }

        $sdiff = $this->second - $datetime->second;
        if ($sdiff !== 0) {
            return $sdiff;
        }

        return 0;
    }

    /**
     * Get the day of the week.
     *
     * @return int  The day of the week (0=Sunday).
     */
    function getDayOfWeek()
    {
        return cb_get_day_of_week($this->year, $this->month, $this->day);
    }

    /**
     * Get number of days in the month.
     *
     * @return int  Number of days in this month.
     */
    function getEndOfMonthDay()
    {
        return cb_get_end_of_monthday($this->year, $this->month);
    }

    /**
     * Get the day of the year.
     *
     * @return int  The day of the year.
     */
    function getDayOfYear()
    {
        return cb_get_day_of_year($this->year, $this->month, $this->day);
    }

    /**
     * Add the amount of time.
     *
     * @param CB_DateTimeSpan $timespan The amount of time.
     */
    function add($timespan)
    {
        $seconds = $timespan->toSeconds();
        $this->moveSeconds($seconds);
    }

    /**
     * Subtract the amount of time.
     *
     * @param CB_DateTimeSpan $timespan The amount of time.
     */
    function sub($timespan)
    {
        $seconds = $timespan->toSeconds();
        $this->moveSeconds(-$seconds);
    }

    /**
     * Add/Subtract a given number of seconds.
     *
     * @param int  $seconds Seconds to add/subtract.
     * @param bool $validate
     */
    function moveSeconds($seconds, $validate = true)
    {
        $time = new CB_TimeEx($this);
        $days = $time->moveSeconds($seconds);
        if (0 != $days) {
            $date = new CB_DateEx($this);
            $date->moveDays($days);
            $this->setDate($date, $validate);
        }
        $this->setTime($time, $validate);
    }

    /**
     * Add/Subtract a given number of minutes.
     *
     * @param int $minutes Minutes to add/subtract.
     */
    function moveMinutes($minutes)
    {
        $time = new CB_TimeEx($this);
        $days = $time->moveMinutes($minutes);
        if (0 != $days) {
            $date = new CB_DateEx($this);
            $date->moveDays($days);
            $this->setDate($date);
        }
        $this->setTime($time);
    }

    /**
     * Add/Subtract a given number of hours.
     *
     * @param int $hours Hours to add/subtract.
     */
    function moveHours($hours)
    {
        $time = new CB_TimeEx($this);
        $days = $time->moveHours($hours);
        if (0 != $days) {
            $date = new CB_DateEx($this);
            $date->moveDays($days);
            $this->setDate($date);
        }
        $this->setTime($time);
    }

    /**
     * Add/Subtract a given number of days.
     *
     * @param int $days Days to add/subtract.
     */
    function moveDays($days)
    {
        cb_date_move_days($this, $days);
    }

    /**
     * Add/Subtract a given number of weeks.
     *
     * @param int $weeks Weeks to add/subtract.
     */
    function moveWeeks($weeks)
    {
        cb_date_move_weeks($this, $weeks);
    }

    /**
     * Add/Subtract a given number of months.
     *
     * @param int $months Months to add/subtract.
     */
    function moveMonths($months)
    {
        cb_date_move_months($this, $months);
    }

    /**
     * Add/Subtract a given number of years.
     *
     * @param int $years Years to add/subtract.
     */
    function moveYears($years)
    {
        cb_date_move_years($this, $years);
    }

    /**
     * Set the local date.
     *
     * @param CB_Date $date
     * @param bool    $validate
     */
    function setDate($date, $validate = true)
    {
        $this->month = $date->month;
        $this->day = $date->day;
        $this->year = $date->year;

        if ($validate && ! cb_date_validate_date($date)) {
            cb_throw_error(E_COMMON_INVALID_DATE);
        }
    }

    /**
     * Get the local date.
     *
     * @return CB_DateEx  The local date.
     */
    function getDate()
    {
        $ret = new CB_DateEx($this);

        return $ret;
    }

    /**
     * Set the local time.
     *
     * @param CB_Time $time
     * @param bool    $validate
     *
     */
    function setTime($time, $validate = true)
    {
        $this->hour = $time->hour;
        $this->minute = $time->minute;
        $this->second = $time->second;

        if ($validate && ! cb_date_validate_time($time)) {
            cb_throw_error(E_COMMON_INVALID_TIME);
        }
    }

    /**
     * Get the local time.
     *
     * @return CB_TimeEx  The local time.
     */
    function getTime()
    {
        return new CB_TimeEx($this);
    }

    /**
     * Calculate the amount of time.
     *
     * @param CB_DateTime $datetime
     *
     * @return CB_DateTimeSpan  The amount of time.
     */
    function getInterval($datetime)
    {
        $interval = new CB_DateTimeSpan(
            gmmktime($this->hour, $this->minute, $this->second,
                $this->month, $this->day, $this->year) -
            gmmktime($datetime->hour, $datetime->minute, $datetime->second,
                $datetime->month, $datetime->day, $datetime->year));

        return $interval;
    }

    /**
     * Create new CB_DateTimeEx instance by CB_Date instance and CB_Time instance.
     *
     * @param CB_Date|CB_DateTime $date
     * @param CB_Time             $time
     * @param string              $error_code
     *
     * @return CB_DateTimeEx
     */
    public static function createByDateAndTime(
        $date,
        $time,
        $error_code = E_COMMON_INVALID_DATETIME
    ) {
        $datetime = new CB_DateTime();
        $datetime->year = $date->year;
        $datetime->month = $date->month;
        $datetime->day = $date->day;
        $datetime->hour = $time->hour;
        $datetime->minute = $time->minute;
        $datetime->second = $time->second;

        if ( ! cb_date_validate_datetime($datetime)) {
            cb_throw_error($error_code);
        }

        return new CB_DateTimeEx($datetime);
    }

    /**
     * setHour
     *
     * @param Integer (0-23) if argment is out of range, return NULL
     *
     * @return self
     */
    public function setHour($hour)
    {
        if ($hour < 0 or 23 < $hour) {
            return null;
        }
        $this->hour = $hour;

        return $this;
    }

    /**
     * setMinite
     *
     * @param Integer (0-59) if argment is out of range, return NULL
     *
     * @return self
     */
    public function setMinite($min)
    {
        if ($min < 0 or 59 < $min) {
            return null;
        }
        $this->minute = $min;

        return $this;

    }

    /**
     * setSecond
     *
     * @param Integer (0-59) if argment is out of range, return NULL
     *
     * @return self
     */
    public function setSecond($second)
    {
        if ($second < 0 or 59 < $second) {
            return null;
        }
        $this->second = $second;

        return $this;

    }

    public function roundByDay()
    {
        return $this->setHour(0)->setMinite(0)->setSecond(0);
    }
}

/**
 * Extended timestamp class that supports miscellaneous caclulations.
 * Instances of this class may be used as {@link CB_TimeStamp} since
 * this is a subclass of {@link CB_TimeStamp}.
 *
 * @package fw.datetime
 */
class CB_TimeStampEx extends CB_TimeStamp
{
    /**
     * @access private
     * @var CB_TimezoneInfo
     */
    var $_timezone = null;

    /**
     * Constructor.
     * if $tzname is null, the timezone will be set equal to CB_I18N's
     * current timezone.
     *
     * @param CB_Timestamp|null $timestamp
     * @param string|null       $tzname
     */
    public function __construct($timestamp = null, $tzname = null)
    {
        assert('is_null( $timestamp ) || is_a( $timestamp, \'cb_timestamp\' )');

        if (is_null($tzname)) {
            $i18n = CB_I18N::getInstance();
            $tzname = $i18n->getCurrentTimezone();
        }

        if (is_null($timestamp)) {
            $this->unix_ts = time();
        } else {
            $this->unix_ts = $timestamp->unix_ts;
        }

        $this->setTimezone($tzname);

        assert('0 <= $this->unix_ts');
    }

    /**
     * Compare a given object of timestamp class.
     *
     * @param CB_TimeStamp $ts
     *
     * @return int  < 0 If this object is less than the object of the argument;
     *              > 0 If $this is greater than $date, and 0 if they are equal.
     */
    function compare($ts)
    {
        return $this->unix_ts - $ts->unix_ts;
    }

    /**
     * Get the time zone name.
     *
     * @return string  The time zone name.
     */
    function getTimezone()
    {
        return $this->_timezone->getName();
    }

    /**
     * Change time zone.
     *
     * @param string $tzname The time zone name.
     */
    function setTimezone($tzname)
    {
        global $G_container_base;
        /** @var CB_TimeZoneInfoPHPFactory $tzfactory */
        $tzfactory = $G_container_base->getInstance('timezoneinfo_factory');
        $this->_timezone = $tzfactory->getTimezoneInfo($tzname);
    }

    /**
     * Get the local date.
     *
     * @return CB_DateEx  The local date.
     */
    function getDate()
    {
        $datetime = $this->getDateTime();
        $obj = new CB_DateEx($datetime);

        return $obj;
    }

    /**
     * Get the local time.
     *
     * @return CB_TimeEx  The local time.
     */
    function getTime()
    {
        $datetime = $this->getDateTime();
        $obj = new CB_TimeEx($datetime);

        return $obj;
    }

    /**
     * Set the local time.
     *
     * @param CB_DateTime $datetime
     * @param string      $tzname timezone name.
     */
    function setDateTime($datetime, $tzname = null)
    {

        $timezone = $this->_timezone;
        if ( ! is_null($tzname)) {
            global $G_container_base;
            /** @var CB_TimezoneInfoPHPFactory $tzfactory */
            $tzfactory = $G_container_base->getInstance('timezoneinfo_factory');
            $timezone = $tzfactory->getTimezoneInfo($tzname);
        }
        $this->unix_ts = $timezone->datetimeToTimestamp($datetime);
    }

    /**
     * Get the local date time.
     *
     * @return CB_DateTimeEx  The local date time.
     */
    function getDateTime()
    {
        static $_datetime = null;
        $datetime = $this->_timezone->timestampToDatetime($this->unix_ts);

        if (is_null($_datetime)) {
            $_datetime = new CB_DateTimeEx($datetime);

            return clone $_datetime;
        }

        $obj = clone $_datetime;
        $obj->year = $datetime->year;
        $obj->month = $datetime->month;
        $obj->day = $datetime->day;
        $obj->hour = $datetime->hour;
        $obj->minute = $datetime->minute;
        $obj->second = $datetime->second;

        return $obj;
    }

    /**
     * Add the amount of time.
     *
     * @param CB_DateTimeSpan $timespan The amount of time.
     */
    function add($timespan)
    {
        $this->unix_ts += $timespan->toSeconds();
    }

    /**
     * Subtract the amount of time.
     *
     * @param CB_DateTimeSpan $timespan The amount of time.
     */
    function sub($timespan)
    {
        $this->unix_ts -= $timespan->toSeconds();
    }

    /**
     * Calculate the amount of time.
     *
     * @param CB_TimeStamp $ts A timestamp.
     *
     * @return CB_DateTimeSpan  The amount of time.
     */
    function getInterval($ts)
    {
        $interval = new CB_DateTimeSpan($this->unix_ts - $ts->unix_ts);

        return $interval;
    }

    /**
     * Format timestamp.
     *
     * @param string $format date()が理解できるフォーマット
     *
     * @return string
     */
    public function format($format)
    {
        $datetime = $this->getDateTime();

        global $G_container_base;
        /* @var CB_TimeZoneInfoPHPFactory $tzfactory */
        $tzfactory = $G_container_base->getInstance('timezoneinfo_factory');
        $timezone = $tzfactory->getTimezoneInfo($this->getTimezone());

        return $timezone->formatDateTime($format, $datetime);
    }
}

/**
 * Represents the amount of time.
 *
 * @package fw.datetime
 */
class CB_DateTimeSpan
{
    /**
     * @access private
     */
    var $_amount; // in seconds.

    /**
     * Constructor
     *
     * @param int $amount_in_seconds The amount of time. (A unit is a second.)
     */
    function __construct($amount_in_seconds)
    {
        $this->_amount = $amount_in_seconds;
    }

    /**
     * Compare a given object of the amount of time class.
     *
     * @param CB_DateTimeSpan $timespan The amount of time.
     *
     * @return int                              < 0 if this is less than $ts,
     *                                          > 0 if this is greater than $ts,
     *                                          and 0 if they are equal.
     */
    function compare($timespan)
    {
        return $this->_amount - $timespan->toSeconds();
    }

    /**
     * Add the amount of time.
     *
     * @param CB_DateTimeSpan $timespan The amount of time.
     */
    function add($timespan)
    {
        $this->_amount += $timespan->toSeconds();
    }

    /**
     * Subtract the amount of time.
     *
     * @param CB_DateTimeSpan $timespan The amount of time.
     */
    function sub($timespan)
    {
        $this->_amount -= $timespan->toSeconds();
    }

    /**
     * Set the amount of time.
     *
     * @param int $second The amount of time of a seconds.
     * @param int $minute The amount of time of a minutes.
     * @param int $hour   The amount of time of a hours.
     * @param int $day    The amount of time of a days.
     */
    function set($second, $minute = 0, $hour = 0, $day = 0)
    {
        $seconds = (($day * 24 + $hour) * 60 + $minute) * 60 + $second;
        $this->_amount = $seconds;
    }

    /**
     * It converts into days.
     *
     * @return float  Days.
     */
    function toDays()
    {
        return $this->_amount / 86400;
    }

    /**
     * It converts into hours.
     *
     * @return float  Hours.
     */
    function toHours()
    {
        return $this->_amount / 3600;
    }

    /**
     * It converts into minutes.
     *
     * @return float  Minutes.
     */
    function toMinutes()
    {
        return $this->_amount / 60;
    }

    /**
     * It converts into seconds.
     *
     * @return int  Seconds.
     */
    function toSeconds()
    {
        return $this->_amount;
    }
}

/**
 * Represent the information data of a time zone.
 * Use {@link CB_TimezoneInfoFactory::getTimezoneInfo} to obtain a object.
 *
 * @abstract
 * @package fw.datetime
 */
class CB_TimezoneInfo
{
    /**
     * @access private
     */
    var $_name = null;

    /**
     * Constructor
     *
     * @param string $tzname The time zone name.
     */
    public function __construct($tzname)
    {
        $this->_name = $tzname;
    }

    /**
     * Get the time zone name.
     *
     * @return string The time zone name.
     */
    public function getName()
    {
        return $this->_name;
    }

    /**
     * Get the information data of a time zone.
     *
     * @param CB_Date|CB_DateTime $date
     *
     * @return array       The information data of a time zone.
     */
    public function getInfo($date)
    {
        return [];
    }

    /**
     * Convert local datetime to timestamp.
     *
     * @param CB_DateTime $datetime
     *
     * @return int
     */
    public function datetimeToTimestamp($datetime)
    {
        return cb_datetime_to_timestamp($datetime, $this->getName());
    }

    /**
     * Convert timestamp to local datetime.
     *
     * @param int $timestamp
     *
     * @return CB_DateTime
     */
    public function timestampToDatetime($timestamp)
    {
        return cb_timestamp_to_datetime($timestamp, $this->getName());
    }

    /**
     * @param string $time time string.
     *
     * @return bool|int  return FALSE if time string is invalid.
     */
    public function timestringToTimestamp($time)
    {
        return cb_timestring_to_timestamp($time);
    }

    public function getOffset($timestamp)
    {
        return null;
    }

    /**
     * Returns date formatted according to given format
     *
     * @param string      $format Format accepted by date().
     * @param CB_DateTime $cb_datetime
     *
     * @return string
     */
    public function formatDateTime($format, $cb_datetime)
    {
        return null;
    }
}

class CB_TimezoneInfoPHP extends CB_TimezoneInfo
{
    private $datetimezone_caches = [];
    private static $datetime_cache = [];

    /**
     * @param string $name
     *
     * @return DateTimeZone
     */
    private function getDateTimeZone($name)
    {
        if ( ! isset($this->datetimezone_caches[$name])) {
            $this->datetimezone_caches[$name] = new DateTimeZone($name);
        }

        return $this->datetimezone_caches[$name];
    }

    public function __construct($tzname)
    {
        parent::__construct($tzname);
    }

    /**
     * Convert local datetime to timestamp.
     *
     * @param CB_DateTime $cb_datetime
     *
     * @return int
     */
    public function datetimeToTimestamp($cb_datetime)
    {
        $datetime = new DateTime($cb_datetime->format(),
            $this->getDateTimeZone($this->getName()));
        $timestamp = $datetime->getTimestamp();

        return $timestamp;
    }

    /**
     * Convert timestamp to local datetime.
     *
     * @param int $timestamp
     *
     * @return CB_Datetime
     */
    public function timestampToDatetime($timestamp)
    {
        if (isset(self::$datetime_cache[$timestamp . "-" . $this->getName()])) {
            return clone self::$datetime_cache[$timestamp . "-"
                                               . $this->getName()];
        }
        $datetime = new DateTime();
        $datetime->setTimezone($this->getDateTimeZone($this->getName()));
        $datetime->setTimestamp($timestamp);

        $cb_datetime = new CB_DateTime();
        $arr
            = explode(':', $datetime->format('Y:m:d:H:i:s'));
        $cb_datetime->year
            = (int)$arr[0];
        $cb_datetime->month
            = (int)$arr[1];
        $cb_datetime->day
            = (int)$arr[2];
        $cb_datetime->hour
            = (int)$arr[3];
        $cb_datetime->minute
            = (int)$arr[4];
        $cb_datetime->second
            = (int)$arr[5];
        self::$datetime_cache[$timestamp . "-" . $this->getName()]
            = $cb_datetime;

        return $cb_datetime;
    }

    /**
     * @param string $time
     *
     * @return bool|int return FALSE if time string is invalid.
     */
    public function timestringToTimestamp($time)
    {
        try {
            $datetime = new DateTime($time,
                $this->getDateTimeZone($this->getName()));
        } catch (Exception $e) {
            return false;
        }

        return $datetime->getTimestamp();
    }

    /**
     * Return offset from GMT
     *
     * @param int $timestamp
     *
     * @return int
     */
    public function getOffset($timestamp)
    {
        $datetimezone = $this->getDateTimeZone($this->getName());
        $datetime = new DateTime();
        $datetime->setTimezone($datetimezone);
        $datetime->setTimestamp($timestamp);

        return $datetimezone->getOffset($datetime);
    }

    /**
     * Returns date formatted according to given format
     *
     * @param string      $format Format accepted by date().
     * @param CB_DateTime $cb_datetime
     *
     * @return string
     */
    public function formatDateTime($format, $cb_datetime)
    {
        $datetime = new DateTime($cb_datetime->format(),
            $this->getDateTimeZone($this->getName()));

        return $datetime->format($format);
    }
}

/**
 * Create and manage {@link CB_TimezoneInfo} objects each of which
 * is associated with the time zone name.
 *
 * @abstract
 * @package fw.datetime
 */
abstract class CB_TimezoneInfoFactory
{
    /**
     * Return TRUE if this factory denies write access; otherwise return FALSE.
     *
     * @return bool
     */
    abstract public function isReadOnly();

    /**
     * Get list of the time zone name.
     *
     * @return array  List of the time zone name.
     */
    abstract public function getTimezoneNames();

    /**
     * Get the information data of a time zone.
     *
     * @param string $tzname The time zone name.
     *
     * @return CB_TimezoneInfo  The information data of a time zone.
     */
    abstract public function getTimezoneInfo($tzname);
}

class CB_TimezoneInfoPHPFactory extends CB_TimezoneInfoFactory
{
    private $tzinfo_cache = [];

    /**
     * Return TRUE if this factory denies write access; otherwise return FALSE.
     *
     * @return bool
     */
    public function isReadOnly()
    {
        return true;
    }

    /**
     * Get list of the time zone name.
     *
     * @return array  List of the time zone name.
     */
    public function getTimezoneNames()
    {
        require_once('fw/timezone_identifiers.csp');
        $timezone_names = GRN_TimezoneIdentifiers::getTimezoneIdentifiers();

        return $timezone_names;
    }

    /**
     * Get the information data of a time zone.
     *
     * @param string $tzname The time zone name.
     *
     * @return CB_TimezoneInfo  The information data of a time zone.
     */
    public function getTimezoneInfo($tzname)
    {
        if ( ! isset($this->tzinfo_cache[$tzname])) {
            $this->tzinfo_cache[$tzname] = new CB_TimezoneInfoPHP($tzname);
        }

        return $this->tzinfo_cache[$tzname];
    }
}

/**
 * Get the day of the week.
 *
 * @param int $year
 * @param int $month
 * @param int $day
 *
 * @return int  The day of the week (0=Sunday).
 */
function cb_get_day_of_week($year, $month, $day)
{
    $jd = gregoriantojd($month, $day, $year);

    return jddayofweek($jd, 0);
}

/**
 * Get number of days in the month.
 *
 * @param int $year
 * @param int $month
 *
 * @return int  Number of days in this month.
 */
function cb_get_end_of_monthday($year, $month)
{
    switch ($month) {
        case 1:
        case 3:
        case 5:
        case 7:
        case 8:
        case 10:
        case 12:
            return 31;

        case 4:
        case 6:
        case 9:
        case 11:
            return 30;

        case 2:
            if (($year % 4) !== 0) {
                return 28;
            }
            if (($year % 400) === 0) {
                return 29;
            }
            if (($year % 100) === 0) {
                return 28;
            }

            return 29;

        default:
            assert('FALSE');
    }
}

/**
 * Get the number of days plus 1 since the beginning of this year.
 * New year's day (January 1st) will return 1.
 *
 * @param $year
 * @param $month
 * @param $day
 *
 * @return int  The number of days since the beginning of this year.
 */
function cb_get_day_of_year($year, $month, $day)
{
    $from = gregoriantojd(1, 1, $year);
    $to = gregoriantojd($month, $day, $year);

    return $to - $from + 1;
}

/**
 * Validate the date within the normal range.
 *
 * @param CB_Date|CB_DateTime $date
 *
 * @return bool
 */
function cb_date_validate_date($date)
{
    if ((1970 <= $date->year) && ($date->year <= 2037) && (0 < $date->month)
        && ($date->month < 13)
        && (0 < $date->day)
        && ($date->day <= cb_get_end_of_monthday($date->year, $date->month))
    ) {
        return true;
    }

    return false;
}

/**
 * Validate the time within the normal range.
 *
 * @param CB_Time|CB_DateTime $time
 *
 * @return bool
 */
function cb_date_validate_time($time)
{
    if ((0 <= $time->hour) && ($time->hour < 24) && (0 <= $time->minute)
        && ($time->minute < 60)
        && (0 <= $time->second)
        && ($time->second < 60)
    ) {
        return true;
    }

    return false;
}

/**
 * Validate the datetime within the normal range.
 *
 * @param CB_DateTime $datetime
 *
 * @return bool
 */
function cb_date_validate_datetime($datetime)
{
    if (cb_date_validate_date($datetime) && cb_date_validate_time($datetime)) {
        return true;
    }

    return false;
}

/**
 * Get $timezone's offset at $timestamp
 *
 * @global CB_LWContainer $G_container_base
 *
 * @param string          $timezone
 * @param int             $timestamp
 *
 * @return int
 */
function cb_get_timezone_offset($timezone, $timestamp = null)
{
    if (is_null($timestamp)) {
        $timestamp = time();
    }

    global $G_container_base;
    /* @var CB_TimeZoneInfoPHPFactory $tzfactory */
    $tzfactory = $G_container_base->getInstance('timezoneinfo_factory');
    $timezoneinfo = $tzfactory->getTimezoneInfo($timezone);

    return $timezoneinfo->getOffset($timestamp);
}

/**
 * Convert to datatime from timestamp.
 *
 * @param int    $timestamp
 * @param string $tzname timezone name
 *
 * @return CB_DateTime
 */
function cb_timestamp_to_datetime($timestamp = null, $tzname = null)
{
    if (is_null($tzname)) {
        $i18n = CB_I18N::getInstance();
        $tzname = $i18n->getCurrentTimezone();
    }
    if (is_null($timestamp)) {
        $timestamp = time();
    }

    global $G_container_base;
    /** @var CB_TimeZoneInfoPHPFactory $tzfactory */
    $tzfactory = $G_container_base->getInstance('timezoneinfo_factory');
    $timezone = $tzfactory->getTimezoneInfo($tzname);

    $ret = $timezone->timestampToDatetime($timestamp);

    return $ret;
}

/**
 * Convert to timestamp from datetime.
 *
 * @param CB_DateTime $datetime
 * @param string      $tzname timezone name
 *
 * @return int
 */
function cb_datetime_to_timestamp($datetime, $tzname = null)
{
    if (is_null($tzname)) {
        $i18n = CB_I18N::getInstance();
        $tzname = $i18n->getCurrentTimezone();
    }

    global $G_container_base;
    /* @var CB_TimeZoneInfoPHPFactory $tzfactory */
    $tzfactory = $G_container_base->getInstance('timezoneinfo_factory');
    $timezone = $tzfactory->getTimezoneInfo($tzname);

    $timestamp = $timezone->datetimeToTimestamp($datetime);

    return $timestamp;
}

/**
 * Convert to timestamp from time string.
 *
 * @param string $time
 * @param string $tzname
 *
 * @return bool|int  return FALSE if timie string is invalid.
 */
function cb_timestring_to_timestamp($time, $tzname = null)
{
    if (is_null($tzname)) {
        $i18n = CB_I18N::getInstance();
        $tzname = $i18n->getCurrentTimezone();
    }

    global $G_container_base;
    /* @var CB_TimeZoneInfoPHPFactory $tzfactory */
    $tzfactory = $G_container_base->getInstance('timezoneinfo_factory');
    /* @var CB_TimezoneInfoPHPFactory $tzfactory */
    $timezone = $tzfactory->getTimezoneInfo($tzname);

    $timestamp = $timezone->timestringToTimestamp($time, $tzname);

    return $timestamp;
}

/**
 * Add/Subtract a given number of years.
 *
 * @param CB_DateTime|CB_Date $date
 * @param int                 $years
 * @param string              $error_code
 */
function cb_date_move_years($date, $years, $error_code = E_COMMON_INVALID_DATE)
{
    $date->year += $years;
    if ($date->month != 2) {
        return;
    }

    $days = cb_get_end_of_monthday($date->year, $date->month);
    if ($date->day > $days) {
        $date->day = $days;
    }

    if ( ! cb_date_validate_date($date)) {
        cb_throw_error($error_code);
    }
}

/**
 * Add/Subtract a given number of days.
 *
 * @param CB_DateTime|CB_Date $date
 * @param int                 $days Days to add/subtract
 * @param string              $error_code
 */
function cb_date_move_days($date, $days, $error_code = E_COMMON_INVALID_DATE)
{
    $jd = gregoriantojd($date->month, $date->day, $date->year);
    $jd += $days;
    list($month, $day, $year) = explode('/', jdtogregorian($jd));
    $date->month = intval($month);
    $date->day = intval($day);
    $date->year = intval($year);

    if ( ! cb_date_validate_date($date)) {
        cb_throw_error($error_code);
    }
}

/**
 * Add/Subtract a given number of weeks.
 *
 * @param CB_DateTime|CB_Date $date
 * @param int                 $weeks
 * @param string              $error_code
 */
function cb_date_move_weeks($date, $weeks, $error_code = E_COMMON_INVALID_DATE)
{
    cb_date_move_days($date, $weeks * 7);

    if ( ! cb_date_validate_date($date)) {
        cb_throw_error($error_code);
    }
}

/**
 * Add/Subtract a given number of months.
 *
 * @param  CB_DateTime|CB_Date $date
 * @param int                  $months
 * @param string               $error_code
 */
function cb_date_move_months(
    $date,
    $months,
    $error_code = E_COMMON_INVALID_DATE
) {
    $date->year = intval(($date->year * 12 + $date->month - 1 + $months) / 12);
    $date->month = ($date->year * 12 + $date->month - 1 + $months) % 12 + 1;

    $days = cb_get_end_of_monthday($date->year, $date->month);
    if ($date->day > $days) {
        $date->day = $days;
    }

    if ( ! cb_date_validate_date($date)) {
        cb_throw_error($error_code);
    }
}

/**
 * Compare a given object of datetime, date, time class.
 *
 * @param CB_DateTime|CB_Date|CB_Time $dt1
 * @param CB_DateTime|CB_Date|CB_Time $dt2
 *
 * @return int
 */
function cb_date_compare($dt1, $dt2)
{
    if (is_a($dt1, 'CB_DateTime') && is_a($dt2, 'CB_DateTime')) {
        $ydiff = $dt1->year - $dt2->year;
        if ($ydiff !== 0) {
            return $ydiff;
        }

        $mdiff = $dt1->month - $dt2->month;
        if ($mdiff !== 0) {
            return $mdiff;
        }

        $ddiff = $dt1->day - $dt2->day;
        if ($ddiff !== 0) {
            return $ddiff;
        }

        $hdiff = $dt1->hour - $dt2->hour;
        if ($hdiff !== 0) {
            return $hdiff;
        }

        $mdiff = $dt1->minute - $dt2->minute;
        if ($mdiff !== 0) {
            return $mdiff;
        }

        $sdiff = $dt1->second - $dt2->second;
        if ($sdiff !== 0) {
            return $sdiff;
        }

        return 0;
    } elseif (is_a($dt1, 'CB_Date') && is_a($dt2, 'CB_Date')) {
        $ydiff = $dt1->year - $dt2->year;
        if ($ydiff !== 0) {
            return $ydiff;
        }

        $mdiff = $dt1->month - $dt2->month;
        if ($mdiff !== 0) {
            return $mdiff;
        }

        $ddiff = $dt1->day - $dt2->day;
        if ($ddiff !== 0) {
            return $ddiff;
        }

        return 0;
    } elseif (is_a($dt1, 'CB_Time') && is_a($dt2, 'CB_Time')) {
        $hdiff = $dt1->hour - $dt2->hour;
        if ($hdiff !== 0) {
            return $hdiff;
        }

        $mdiff = $dt1->minute - $dt2->minute;
        if ($mdiff !== 0) {
            return $mdiff;
        }

        $sdiff = $dt1->second - $dt2->second;
        if ($sdiff !== 0) {
            return $sdiff;
        }

        return 0;
    } else {
        assert(false);
    }
}

class CB_DayOfWeek
{
    const SUNDAY = 0;
    const MONDAY = 1;
    const TUESDAY = 2;
    const WEDNESDAY = 3;
    const THURSDAY = 4;
    const FRIDAY = 5;
    const SATURDAY = 6;
}

class CB_TimeUnit
{
    const HOURS_OF_DAY = 24;
    const MINUTES_OF_HOUR = 60;
    const SECONDS_OF_MINUTE = 60;
    const SECONDS_OF_HOUR = 3600;
    const SECONDS_OF_DAY = 86400;
}

class CB_ISO8601Util
{
    const DATETIME_REGEX = "(?'year'[0-9]{4})-(?'month'[0-9]{2})-(?'day'[0-9]{2})T(?'hour'[0-9]{2}):(?'minute'[0-9]{2}):(?'second'[0-9]{2})(?'second_fraction_part'\.[0-9]+)?";
    const TIMEZONE_OFFSET_REGEX = "(?'timezone'Z|[\+-][0-9]{2}:[0-9]{2})";

    /**
     * @static
     *
     * @param string $str_datetime
     * @param bool   $require_timezone_offset
     *
     * @return bool
     */
    public static function isISO8601(
        $str_datetime,
        $require_timezone_offset = true
    ) {
        if ( ! is_string($str_datetime)) {
            return false;
        }

        $regex = self::DATETIME_REGEX . self::TIMEZONE_OFFSET_REGEX;
        if ( ! $require_timezone_offset) {
            $regex .= '?';
        }
        $count = preg_match("#\A$regex\z#", $str_datetime);

        return ($count > 0);
    }

    /**
     * @param string $str_datetime
     * @param bool   $require_timezone_offset
     *
     * @return bool|CB_DateTimeEx
     */
    public static function toUTCDateTime(
        $str_datetime,
        $require_timezone_offset = true
    ) {
        if ( ! self::isISO8601($str_datetime, $require_timezone_offset)) {
            return false;
        }

        if ( ! preg_match('#\A' . self::DATETIME_REGEX . '#', $str_datetime, $regs)) {
            return false;
        }

        $datetime = new CB_DateTime();
        $datetime->year = intval($regs['year']);
        $datetime->month = intval($regs['month']);
        $datetime->day = intval($regs['day']);
        $datetime->hour = intval($regs['hour']);
        $datetime->minute = intval($regs['minute']);
        $datetime->second = intval($regs['second']);

        if ( ! cb_date_validate_datetime($datetime)) {
            return false;
        }

        $datetime = new CB_DateTimeEx($datetime);

        $seconds = self::calcTimezoneOffsetSeconds($str_datetime);
        $datetime->moveSeconds($seconds, false);
        if ( ! cb_date_validate_datetime($datetime)) {
            return false;
        }
        return $datetime;
    }

    /**
     * @param $str_datetime
     *
     * @return bool|CB_DateEx
     */
    public static function toUTCDate($str_datetime)
    {
        if ( ! self::isISO8601($str_datetime, false)) {
            return false;
        }
        if ( ! preg_match('#\A' . self::DATETIME_REGEX . '#', $str_datetime, $regs)) {
            return false;
        }

        $datetime = new CB_Date();
        $datetime->year = intval($regs['year']);
        $datetime->month = intval($regs['month']);
        $datetime->day = intval($regs['day']);

        if ( ! cb_date_validate_date($datetime)) {
            return false;
        }

        return new CB_DateEx($datetime);
    }

    /**
     * @param $str_datetime
     *
     * @return int
     */
    public static function calcTimezoneOffsetSeconds($str_datetime): int
    {
        $timezone_offset = self::extractTimezoneOffset($str_datetime);
        if ($timezone_offset === "" || $timezone_offset === 'Z') {
            return 0;
        }

        $sign = $timezone_offset{0};
        $seconds = substr($timezone_offset, 1, 2) * 3600;
        $seconds += substr($timezone_offset, 4, 2) * 60;

        if ($sign === '-') {
            return $seconds;
        }

        return -$seconds;
    }


    /**
     * @param string $str_datetime
     *
     * @return bool
     */
    public static function hasTimezoneOffset(string $str_datetime): bool
    {
        $timezone_offset = self::extractTimezoneOffset($str_datetime);

        return $timezone_offset !== "";
    }

    private static function extractTimezoneOffset(string $str_datetime)
    {
        $regex = '#\A' . self::DATETIME_REGEX . self::TIMEZONE_OFFSET_REGEX . '\z#';
        $result = preg_match($regex, $str_datetime, $regs);
        if ( ! $result) {
            return "";
        }

        return $regs['timezone'] ?? "";
    }

    /**
     * @param string      $str_datetime
     * @param string|null $dst_timezone
     * @param bool        $require_timezone_offset
     *
     * @return bool|CB_DateTime|CB_DateTimeEx
     */
    public static function toDateTime(
        $str_datetime,
        $dst_timezone = null,
        $require_timezone_offset = true
    ) {
        $datetime = self::toUTCDateTime($str_datetime, $require_timezone_offset);

        if ( ! $datetime) {
            return false;
        }

        if ( ! self::hasTimezoneOffset($str_datetime)) {
            if ($require_timezone_offset) {
                return false;
            }

            return $datetime;
        }

        if (is_null($dst_timezone)) {
            require_once("fw/i18n.csp");
            $i18n = CB_I18N::getInstance();
            $dst_timezone = $i18n->getCurrentTimezone();
        }

        require_once("fw/i18n.csp");

        return CB_I18N::translateDatetimeTimezone($datetime, 'UTC', $dst_timezone);
    }
}


