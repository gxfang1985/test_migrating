<?php

/**
 * Provide utility functions/classes to handle strings.
 *
 * @package fw.core
 */

/**
 * Trim space characters before and after a string.
 *
 * @param string $s The string to be trimmed.
 *
 * @return string   Trimmed string.
 */
function cb_trim($s)
{
    $ret = mb_ereg_replace("^(　| |\t|\n|\r|\0|\x0B)*|(　| |\t|\n|\r|\0|\x0B)*$",
        "", $s);

    return $ret === false ? '' : $ret;
}

/**
 * Throw an error iff trimmed string of <var>$s</var> is empty.
 *
 * @param string $s          The string to be checked.
 * @param string $error_code Optional error code to be thrown.
 *
 * @return string            Trimmed string, if not empty.
 */
function cb_trim_check($s, $error_code = E_COMMON_MISSING_MANDATORY)
{
    // quickly check if $s is an empty string.
    if (mb_strlen($s) == 0) {
        cb_throw_error($error_code);
    }

    // do trim then recheck
    $s = cb_trim($s);
    if (mb_strlen($s) == 0) {
        cb_throw_error($error_code);
    }

    return $s;
}

/**
 * Normalize a sort key string as well as checking it.
 *
 * @param string $s
 *
 * @return string
 */
function cb_normalize_sort_key($s)
{
    /*
    $full_size_hiragana = array(
    'あ', 'い', 'う', 'え', 'お', 'ぁ', 'ぃ', 'ぅ', 'ぇ', 'ぉ',
    'か', 'き', 'く', 'け', 'こ', 'が', 'ぎ', 'ぐ', 'げ', 'ご',
    'さ', 'し', 'す', 'せ', 'そ', 'ざ', 'じ', 'ず', 'ぜ', 'ぞ',
    'た', 'ち', 'つ', 'て', 'と', 'だ', 'ぢ', 'づ', 'で', 'ど', 'っ',
    'な', 'に', 'ぬ', 'ね', 'の',
    'は', 'ひ', 'ふ', 'へ', 'ほ', 'ば', 'び', 'ぶ', 'べ', 'ぼ', 'ぱ', 'ぴ', 'ぷ', 'ぺ', 'ぽ',
    'ま', 'み', 'む', 'め', 'も',
    'ゃ', 'や', 'ゅ', 'ゆ', 'ょ', 'よ',
    'ら', 'り', 'る', 'れ', 'ろ',
    'ゎ', 'わ', 'ゐ', 'ゑ', 'を', 'ん', 'ゔ',
    );
    
    $upper_alphabet = array(
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
    );
    
    $convert = mb_convert_kana($s, 'HcV', mb_internal_encoding());
    $convert = strtoupper($convert);
    
    $total = mb_strlen($convert);
    for($i = 0; $i < $total; $i++)
    {
        $c = mb_substr($convert, $i, 1);
        if(!in_array($c, $full_size_hiragana) && !in_array($c, $upper_alphabet))
        {
            cb_throw_error(E_COMMON_ILLEGAL_SORTKEY, null, array('key'=>$s ));
        }
    }
    return $convert;
    */

    return mb_convert_kana($s, 'HcVas', mb_internal_encoding());
}

/**
 * Test if $str can be encoded in $charset.
 *
 * @param string $str     The string to be validate.
 * @param string $charset Target character set name.
 *
 * @return boolean
 */
function cb_test_charset_validity($str, $charset)
{
    $internal = mb_internal_encoding();

    //Get substitute character ("none", "long" or unicode value as an integer)
    $ch = mb_substitute_character();

    //Remove substitute character
    if (is_integer($ch)) {
        $str = preg_replace('/\x{' . dechex($ch) . '}/u', '', $str);
    }

    require_once('fw/i18n.csp');
    $temp = cb_encode($str, $charset, $internal);
    $ret = cb_encode($temp, $internal, $charset);

    if (mb_strlen($ret, $internal) !== mb_strlen($str, $internal)) {
        return false;
    }

    if (is_integer($ch) && preg_match('/\x{' . dechex($ch) . '}/u', $ret) > 0) {
        return false;
    }

    return true;
}

/**
 * Divide an input string into words.
 * Use this to parse simple search strings.
 *
 * @param string $text The input string.
 *
 * @return array The divided tokens.
 */
function cb_parse_search_text($text)
{
    // replace Zenkaku-space with a space
    $t = mb_ereg_replace('　', ' ', $text);
    $t = explode(' ', $t);

    $search_words = [];
    foreach ($t as $word) {
        $word = trim($word);
        if (strlen($word) > 0) {
            $search_words[$word] = $word;
        }
    }

    return array_values($search_words);
}

/**
 * Return TRUE if $email_address is a valid email address.
 * If $email_address is an empty string, return $empty value.
 *
 * The validation logic is the same as SmartyValidate's "isEmail".
 *
 * @param  string $email_address
 * @param  bool   $empty
 *
 * @return bool
 */
function cb_is_emailaddress($email_address, $empty = true)
{
    if (strlen($email_address) === 0) {
        return $empty;
    }

    // regex taken from Jeffrey Freidl e-mail validation example
    // http://public.yahoo.com/~jfriedl/regex/email-opt.pl
    $_regex
        = '[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*@[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*|(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[^()<>@,;:".\\\[\]\x80-\xff\000-\010\012-\037]*(?:(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[^()<>@,;:".\\\[\]\x80-\xff\000-\010\012-\037]*)*<[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:@[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*(?:,[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*@[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*)*:[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)?(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*@[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*>)';

    // in case value is several addresses separated by newlines
    $_addresses = preg_split('![\n\r]+!', $email_address);

    foreach ($_addresses as $_address) {
        if ( ! preg_match("/^$_regex$/", $_address)) {
            return false;
        }
    }

    return true;
}

/**
 * 数字を千位毎にグループ化してフォーマットする。
 * パラメータが 1 つだけ渡された場合、 inNumber は千位毎にカンマ (",") が追加され、 小数なしでフォーマットされます。
 * パラメータが 2 つ渡された場合、inNumber は inDecimals 桁の小数の前にドット (".") 、 千位毎にカンマ (",") が追加されてフォーマットされます。
 * パラメータが 3 つ渡された場合、inNumber はドット (".") の代わりに inDecPoint が inDecimals 桁の小数の前に、千位毎にカンマ (",") が追加されてフォーマットされます。
 * パラメータが 4 つ渡された場合、inNumber はドット (".") の代わりに inDecPoint が inDecimals 桁の小数の前に、千位毎にカンマ (",") の代わりに inThousandsSep が追加されてフォーマットされます。
 * パラメータが 5 つ渡された場合、inNumber はドット (".") の代わりに inDecPoint が inDecimals 桁の小数の前に、千位毎にカンマ (",") の代わりに inThousandsSep が追加されてフォーマットされます。 マイナス ("-") の代わりに inMinusChar が使用されてフォーマットされます。
 * パラメータが 6 つ渡された場合、inNumber はドット (".") の代わりに inDecPoint が inDecimals 桁の小数の前に、千位毎にカンマ (",") の代わりに inThousandsSep が追加されてフォーマットされます。 マイナス ("-") の代わりに inMinusChar が使用されてフォーマットされます。 inIsDecimalZeroPaddingがTRUEの場合、inNumberの小数部がinDecimalsに満たない分だけ'0'で埋めます。
 *
 * @param  string $inNumber
 * @param  int    $inDecimals
 * @param  string $inDecPoint
 * @param  string $inThousandsSep
 * @param  string $inMinusChar
 * @param  bool   $inIsDecimalZeroPadding
 *
 * @return string
 */
function cb_number_format(
    $inNumber,
    $inDecimals = 0,
    $inDecPoint = '.',
    $inThousandsSep = ',',
    $inMinusChar = '-',
    $inIsDecimalZeroPadding = false
) {
    //number resolution(数値を整数と小数に分解)
    $tempNumberElementArray = explode('.', $inNumber);
    $integerParts = (strlen($tempNumberElementArray[0]) > 0)
        ? $tempNumberElementArray[0] : '0';
    $decimalParts = (count($tempNumberElementArray) > 1)
        ? $tempNumberElementArray[1] : '';


    //integer parts format(整数部のフォーマット)
    $pattern = '/(\d)(?=(\d\d\d)+(?!\d))/';  //桁区切りを行う正規表現
    $replacement = '$1' . $inThousandsSep;       //桁区切りに使う文字
    $result = preg_replace($pattern, $replacement, $integerParts);


    if ($inDecimals > 0) {
        //decimal parts format(小数部のフォーマット)
        if (strlen($decimalParts) >= $inDecimals) {
            $decimalParts = substr($decimalParts, 0, $inDecimals);
        } elseif ($inIsDecimalZeroPadding) {
            $decimalParts = sprintf("%-'0{$inDecimals}s", $decimalParts);
        }

        //integerParts and decimalParts join(整数部と小数部をつなげる)
        if (strlen($decimalParts) > 0) {
            $result = $result . $inDecPoint . $decimalParts;
        }
    }

    //Format Minus Type
    $result = str_replace('-', $inMinusChar, $result);

    return $result;
}

// Unicode BOM is U+FEFF, but after encoded, it will look like this.
define('UTF32_BIG_ENDIAN_BOM', chr(0x00) . chr(0x00) . chr(0xFE) . chr(0xFF));
define('UTF32_LITTLE_ENDIAN_BOM',
    chr(0xFF) . chr(0xFE) . chr(0x00) . chr(0x00));
define('UTF16_BIG_ENDIAN_BOM', chr(0xFE) . chr(0xFF));
define('UTF16_LITTLE_ENDIAN_BOM', chr(0xFF) . chr(0xFE));
define('UTF8_BOM', chr(0xEF) . chr(0xBB) . chr(0xBF));

/**
 * Detect UTF-8/16/32 of file by its BOM (not work with string or file without BOM)
 *
 * @param  string $str
 *
 * @return string charset code
 */
function detect_utf_bom_encoding($str)
{
    $first2 = substr($str, 0, 2);
    $first3 = substr($str, 0, 3);
    $first4 = substr($str, 0, 3);

    if ($first3 == UTF8_BOM) {
        return 'UTF-8';
    } elseif ($first4 == UTF32_BIG_ENDIAN_BOM) {
        return 'UTF-32BE';
    } elseif ($first4 == UTF32_LITTLE_ENDIAN_BOM) {
        return 'UTF-32LE';
    } elseif ($first2 == UTF16_BIG_ENDIAN_BOM) {
        return 'UTF-16BE';
    } elseif ($first2 == UTF16_LITTLE_ENDIAN_BOM) {
        return 'UTF-16LE';
    }
}

/**
 * escape a CDATA end
 *
 * @param string $value
 *
 * @return string
 */
function cb_escape_cdata($value)
{
    return str_replace(']]>', ']]]]><![CDATA[>', $value);
}

/**
 * @param mixed $string
 *
 * @return mixed
 */
function cb_remove_invalid_xml_chars($string)
{
    return preg_replace('/[^\x9\xA\xD\x20-\x{D7FF}\x{E000}-\x{FFFD}\x{10000}-\x{10FFFF}]/u',
        '', $string);
}
