<?php

class CbUnserialize
{
    /**
     * @param string $serialized_text
     * @param array  $options
     *
     * @return mixed
     */
    function unserialize(string $serialized_text, array $options = [])
    {
        $allowed_classes = $options["allowed_classes"] ?? [];
        if ( ! is_array($allowed_classes)) {
            $allowed_classes = [];
        }
        $common_allowed_classes = $this->readAllowedClassesFromCommonIni();
        if ($common_allowed_classes !== false) {
            $allowed_classes = array_merge($allowed_classes,
                explode(" ", $common_allowed_classes));
        }

        if (empty($allowed_classes)) {
            $allowed_classes = false;
        }

        $options["allowed_classes"] = $allowed_classes;
        $result = unserialize($serialized_text, $options);

        if ( ! $this->checkUnserializeSucceeded($serialized_text, $result)) {
            cb_throw_error(E_COMMON_FAILED_TO_UNSERIALIZE, null, null, null,
                ["serialized_text" => $serialized_text]);
        }

        return $result;
    }

    /**
     * @param string $serialized_text
     * @param mixed  $result
     *
     * @return bool
     */
    private function checkUnserializeSucceeded(
        string $serialized_text,
        $result
    ): bool {
        $PHP_INCOMPLETE_CLASS = "__PHP_Incomplete_Class";
        $original_num = substr_count($serialized_text,
            $PHP_INCOMPLETE_CLASS);
        $result_num = substr_count(json_encode($result),
            $PHP_INCOMPLETE_CLASS);

        return ($result_num === $original_num);
    }

    /**
     * @return string|bool
     */
    function readAllowedClassesFromCommonIni()
    {
        global $G_config_common;

        return $G_config_common->get('Global', 'unserialize_allowed_classes');
    }
}

