<?php

/**
 * Plugin support.
 *
 * @author      Yamamoto, Hirotaka      2004/07
 * @version     1.0
 * @package     fw.core
 */

/**
 * Plugin loader class.
 *
 * @package fw.core
 */
class CB_PluginLoader
{
    /**
     * The base directory from which plugins/drivers are loaded.
     *
     * @access private
     */
    private $_dir;

    /**
     * @access private
     */
    private $_prefix;

    /**
     * Create a plugin loader for a specific module.
     * The module name will become a part of directory path
     * from which plugins/drivers will be loaded.
     *
     * @param string $module The module name.
     */
    public function __construct($module)
    {
        $module = str_replace('.', '/', strtolower($module));

        global $G_config_common;
        $this->_dir = cb_basedir() . '/code/plugin/' . $module;
        $this->_prefix = 'plugin_' . str_replace('/', '_', $module) . '_';
    }

    /**
     * Load a driver class.
     * The file name must be strtolower( $class_name ) followed by ".csp" .
     * The actual class name will be "plugin_${module}_${class_name}" where
     * $module is the string passed to the constructor.
     *
     * This method returns FALSE if the specified driver is not found.
     *
     * @param string $class_name The driver class name.  The real class name
     *                           is prefixed with "plugin_${module}".
     *
     * @return object $class_name An instance of the loaded class, or FALSE.
     */
    public function loadDriver($class_name)
    {
        $ret = false;
        $file = $this->_dir . '/' . strtolower(basename($class_name)) . '.csp';
        if ( ! file_exists($file)) {
            return $ret;
        }

        require_once($file);
        $real_class_name = $this->_prefix . $class_name;
        if ( ! class_exists($real_class_name)) {
            cb_throw_error(E_COMMON_MISSING_DRIVER_CLASS, null, null,
                [
                    'file'  => strtolower($class_name) . '.csp',
                    'class' => $real_class_name
                ]);
        }
        $ret = new $real_class_name;

        return $ret;
    }

    /**
     * Load hook functions.
     * $prefix may be specified to selectively load files, or may be
     * left NULL to load all files.  Filenames must be hook function
     * name followed by ".csp" .
     *
     * @param string $prefix optional prefix of files to be loaded.
     *
     * @return array list of loaded hook function names (not file names).
     */
    public function loadHooks($prefix = null)
    {
        return $this->_lookupHooks($prefix, true);
    }

    /**
     * Load files simply.
     * $prefix may be specified to selectively load files, or may be
     * left NULL to load all files.  Filenames must end with ".csp".
     *
     * @param string $prefix optional prefix of files to be loaded.
     *
     * @return array list of loaded file paths.
     */
    public function loadFiles($prefix = null)
    {
        return $this->_lookupFiles($prefix, true);
    }

    /**
     * Test if specified file is loadable or not.
     *
     * @param string $file Filename
     *
     * @return bool TRUE if $file is loadable; otherwise FALSE.
     */
    public function exist($file)
    {
        return is_readable($this->_dir . '/' . $file);
    }

    /**
     * List hook functions.
     * This does the same as loadAll() except that this does not
     * load files.
     *
     * @param string $prefix optional prefix of files to be listed.
     *
     * @return array list of hook function names (not file names).
     */
    public function listHooks($prefix = null)
    {
        return $this->_lookupHooks($prefix, false);
    }

    /**
     * List loadable files.
     * This does the same as loadFiles() except that this does not
     * load files.
     *
     * @param string $prefix optional prefix of files to be listed.
     *
     * @return array list of file paths.
     */
    public function listFiles($prefix = null)
    {
        return $this->_lookupFiles($prefix, false);
    }

    /**
     * @access private
     */
    private function _lookupHooks($prefix, $do_load)
    {
        $hooks = [];

        $dir = @ opendir($this->_dir);
        if ($dir === false) {
            return $hooks;
        }

        while (($file = readdir($dir)) !== false) {
            if (($file == '.') || ($file == '..')) {
                continue;
            }

            if ($prefix
                && (strncmp($prefix, $file, strlen($prefix)) != 0)
            ) {
                continue;
            }

            if ( ! preg_match("/^(.*)\\.csp$/", $file, $regs)) {
                continue;
            }

            $func = $this->_prefix . $regs[1];
            if ($do_load) {
                require_once($this->_dir . '/' . $file);
                if ( ! function_exists($func)) {
                    cb_throw_error(E_COMMON_MISSING_HOOK_FUNCTION, null, null,
                        ['file' => $file, 'func' => $func]);
                }
            }
            $hooks[] = $func;
        }

        closedir($dir);

        return $hooks;
    }

    /**
     * @access private
     */
    private function _lookupFiles($prefix, $do_load)
    {
        $__files__ = [];

        $__dir__ = @ opendir($this->_dir);
        if ($__dir__ === false) {
            return $__files__;
        }

        while (($file = readdir($__dir__)) !== false) {
            if (($file == '.') || ($file == '..')) {
                continue;
            }

            if ($prefix
                && (strncmp($prefix, $file, strlen($prefix)) != 0)
            ) {
                continue;
            }

            if ( ! preg_match("/^.*\\.csp$/", $file)) {
                continue;
            }

            $file = $this->_dir . '/' . $file;
            $__files__[] = $file;
        }

        // do sort on file names.
        sort($__files__, SORT_STRING);

        if ($do_load) {
            foreach ($__files__ as $file) {
                require($file);
            }
        }

        closedir($__dir__);

        return $__files__;
    }

    /**
     * Decode param
     *
     * @param string $encoded_value
     *
     * @return mixed
     */
    public static function decodeParam($encoded_value)
    {
        $data = @cb_unserialize(base64_decode($encoded_value),
            ['allowed_classes' => false]);
        if ($data === false) {
            $data = [];
        }

        return $data;
    }

    /**
     * Encode param
     *
     * @param array|mixed $value
     *
     * @return string
     */
    public static function encodeParam($value)
    {
        return base64_encode(serialize($value));
    }
}


