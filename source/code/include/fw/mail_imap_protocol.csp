<?php
/**
 * An IMAP protocol provider.
 *
 * @auther  Miyabe, Tatsuhiko   2004/09
 * @version 1.0
 * @package fw.mail
 */
//
// +----------------------------------------------------------------------+
// | PHP Version 4                                                        |
// +----------------------------------------------------------------------+
// | Copyright (c) 1997-2003 The PHP Group                                |
// +----------------------------------------------------------------------+
// | This source file is subject to version 2.02 of the PHP license,      |
// | that is bundled with this package in the file LICENSE, and is        |
// | available at through the world-wide-web at                           |
// | http://www.php.net/license/2_02.txt.                                 |
// | If you did not receive a copy of the PHP license and are unable to   |
// | obtain it through the world-wide-web, please send a note to          |
// | license@php.net so we can mail you a copy immediately.               |
// +----------------------------------------------------------------------+
// | Author: Damian Alejandro Fernandez Sosa <damlists@cnba.uba.ar>       |
// +----------------------------------------------------------------------+
require_once('Net/Socket.php');
require_once('fw/i18n.csp');
require_once('fw/socket_util.csp');

/**
 * Provides an implementation of the IMAP protocol using PEAR's
 * Net_Socket:: class.
 *
 * @package fw.mail
 * @author  Damian Alejandro Fernandez Sosa <damlists@cnba.uba.ar>
 */
class CB_MailIMAPProtocol
{
    /**
     * The auth methods this class support
     *
     * @var array
     * @access private
     */
    var $_supportedAuthMethods = ['DIGEST-MD5', 'CRAM-MD5', 'LOGIN', 'PLAIN', 'USER'];

    /**
     * The auth methods this class support
     *
     * @var array
     * @access private
     */
    var $_supportedSASLAuthMethods = ['DIGEST-MD5', 'CRAM-MD5'];

    /**
     * _serverAuthMethods
     *
     * @var boolean
     * @access private
     */
    var $_serverAuthMethods = null;

    /**
     * The the current mailbox
     *
     * @var string
     * @access private
     */
    var $_currentMailbox;
    var $_writeable;

    /**
     * The socket resource being used to connect to the IMAP server.
     *
     * @var resource
     * @access private
     */
    var $_socket = null;

    /**
     * The logger object.
     *
     * @var CB_Logger
     * @access private
     */
    var $_logger;
    var $_listener;

    /**
     * Command Number
     *
     * @var int
     * @access private
     */
    var $_cmdCounter = 1;

    /**
     * Capabilities
     *
     * @var boolean
     * @access private
     */
    var $_serverSupportedCapabilities = null;

    /**
     * Hostname.
     *
     * @var string
     * @access private
     */
    var $_host;
    var $_domain;

    /**
     * True to indicates the protocol handler in transaction.
     *
     * @var boolean
     * @access private
     */
    var $_in_transaction = false;

    /**
     * Use UTF-7 funcionallity
     *
     * @var boolean
     * @access private
     */
    var $_useUTF_7 = true;

    /**
     * Socket wrapper.
     *
     * @var string
     * @access private
     */
    var $_readutil;

    /**
     * socks info
     *
     * @var array
     */
    var $_socks_info = [];


    /**
     * Constructor
     *
     * Instantiates a new Net_IMAP object.
     *
     * @since  1.0
     */
    function __construct()
    {
        $this->_socket = new Net_Socket();

        global $G_config_common;
        $read_timeout = $G_config_common->get('Mail', 'mail_imap_read_timeout');
        $read_buffer_size = $G_config_common->get('Mail', 'mail_imap_read_buffer_size');
        $this->_readutil = new CB_MailSocketReader($this->_socket, $read_timeout, $read_buffer_size);

        /*
         * Include the Auth_SASL package.  If the package is not available,
         * we disable the authentication methods that depend upon it.
         */
        if ((@include_once('Auth/SASL.php')) == false) {
            foreach ($this->_supportedSASLAuthMethods as $SASLMethod) {
                $pos = array_search($SASLMethod, $this->_supportedAuthMethods);
                unset($this->_supportedAuthMethods[$pos]);
            }
        }

    }

    function setLogger($logger)
    {
        $this->_logger = $logger;
        $this->_readutil->setLogger($logger);
    }

    function setErrorListener($listener)
    {
        $this->_listener = $listener;
        $this->_readutil->setErrorListener($listener);
    }

    /**
     * Attempt to connect to the IMAP server.
     *
     * @param string  $host
     * @param string  $port
     * @param string  $domain
     * @param string  $user
     * @param string  $password
     * @param string  $auth
     * @param string  $timeout
     * @param boolean $login
     * @param boolean $imap_ssl
     * @param array $socks_info
     *
     * @return mixed true or PEAR_Error.
     */
    function connect($host, $port, $domain, $user, $password, $auth, $timeout, $login = true, $imap_ssl = false, $socks_info)
    {
        assert('!is_null( $host)');
        assert('!is_null( $port)');
        assert('!is_null( $timeout)');

        if ($login === true) {
            assert('!is_null( $user)');
            assert('!is_null( $password)');
            assert('!is_null( $domain)');
        }

        $this->_domain = $domain;
        $this->_host = $host;
        $auth = strtoupper($auth);
        $this->_socks_info = $socks_info;
        $options = ["ssl" => ["verify_peer" => false, "verify_peer_name" => false]];
        if (PEAR::isError($err = $this->connectToSocksServer($timeout, $options))) {
            return $err;
        } elseif (PEAR::isError($err = $this->connectToMailServer($host, $port, $timeout, $options, $imap_ssl))) {
            return $err;
        } elseif ($imap_ssl && cb_is_forest() && PEAR::isError($err = $this->_socket->enableCrypto(TRUE, STREAM_CRYPTO_METHOD_SSLv23_CLIENT))) {
            return $err;
        }
        $this->_in_transaction = true;

        if (PEAR::isError($data = $this->_readLine())) {
            // Don't call disconnect(). If connected server isn't IMAP,
            // library hangs up probably.
            return $data;
        }

        if (@substr($data, 0, 1) !== '*') {
            return new PEAR_Error();
        }

        //
        if ($login === false) {
            return true;
        }

        if (PEAR::isError($err = $this->_login($user, $password, $auth))) {
            return $err;
        }

        return true;
    }

    /**
     * connect to the socks server (.com server only)
     *
     * @param $timeout
     * @param $options
     *
     * @return bool|mixed|PEAR_Error
     */
    public function connectToSocksServer($timeout, $options)
    {
        if (cb_is_forest()) {
            $socks5_host = $this->_socks_info['host'];
            $socks5_port = $this->_socks_info['port'];
            $connect_code = pack("C3", 0x05, 0x01, 0x00);
            if (PEAR::isError($err =
                $this->_socket->connect($socks5_host, $socks5_port, FALSE, $timeout, $options))) {
                return $err;
            } elseif (PEAR::isError($err = $this->_socket->write($connect_code))) {
                return $err;
            } else {
                $buffer = $this->_socket->read(3);
                $response = unpack('C*', $buffer);
                if (count($response) != 2) {
                    return new PEAR_Error();
                } elseif ($response['1'] != 5) {
                    return new PEAR_Error();
                } elseif ($response['2'] != 0) {
                    return new PEAR_Error();
                }
            }
        }
        return TRUE;
    }

    /**
     * @param $host
     * @param $host_port
     * @param $timeout
     * @param $options
     * @param $imap_ssl
     *
     * @return bool|PEAR_Error
     */
    public function connectToMailServer($host, $host_port, $timeout, $options, $imap_ssl)
    {
        if (cb_is_forest()) {
            $host_ip = @gethostbyname($host);
            $connect_code =
                chr(5) . chr(1) . "\x00" . chr(1) . pack('Nn', ip2long($host_ip),
                    $host_port);

            if (PEAR::isError($err = $this->_socket->write($connect_code))) {
                return $err;
            } else {
                $buffer = $this->_socket->read(11);
                $response = unpack("C*", $buffer);
                if (count($response) != 10) {
                    return new PEAR_Error();
                } elseif ($response['1'] != 5) {
                    return new PEAR_Error();
                } elseif ($response['2'] != 0) {
                    return new PEAR_Error();
                }
            }

            return TRUE;
        } else {
            if (PEAR::isError($err = $this->_socket->connect($host, $host_port, false, $timeout, $options, $imap_ssl))) {
                if (!is_null($this->_listener)) {
                    $this->_listener->error(-1, cb_msg('fw.mail', 'Failed to connect the server.'));
                }
                if (!is_null($this->_logger)) {
                    $this->_logger->warning($err->getMessage());
                }
                return new PEAR_Error();
            }
            return TRUE;
        }
    }

    function disconnect()
    {
        if ($this->_in_transaction === true) {
            $this->_in_transaction = false;
            if (PEAR::isError($err = $this->cmdLOGOUT())) {
                return $err;
            }
            if (PEAR::isError($err = $this->_socket->disconnect())) {
                if ( ! is_null($this->_listener)) {
                    $this->_listener->error(-1, cb_msg('fw.mail',
                        'Failed to disconnect from the server.'));
                }
                if ( ! is_null($this->_logger)) {
                    $this->_logger->debug($err->getMessage());
                }

                return $err;
            }
        }

        return true;
    }

    /**
     * get current mailbox name
     *
     * @return string Returns the current mailbox
     *
     * @access public
     * @since  1.0
     */
    function getCurrentMailbox()
    {
        return $this->_currentMailbox;
    }

    function isWriteable()
    {
        return $this->_writeable;
    }

    /**
     * @param  string authentication method
     *
     * @access public
     */
    function checkSupportedAuthMethod($user_method)
    {
        if (is_null($this->_serverSupportedCapabilities)) {
            $this->cmdCAPABILITY();
        }

        $methods = $this->_supportedAuthMethods;

        $user_method = strtoupper($user_method);

        if (($methods != null) && ($this->_serverAuthMethods != null)) {
            if (in_array($user_method, $this->_serverAuthMethods)) {
                return true;
            }
        }

        $msg = cb_msg('fw.mail', 'The server does not support authentication.');
        if ( ! is_null($this->_listener)) {
            $this->_listener->error(-1, $msg);
        }

        return new PEAR_Error();
    }

    /**
     * Attempt to authenticate to the IMAP server.
     *
     * @param string  $user            The userid to authenticate as.
     * @param string  $pass            The password to authenticate with.
     * @param string  $useauthenticate true: authenticate using
     *                                 the IMAP AUTHENTICATE command. false: authenticate using
     *                                 the IMAP AUTHENTICATE command. 'string': authenticate using
     *                                 the IMAP AUTHENTICATE command but using the authMethod in 'string'
     * @param boolean $selectMailbox   automaticaly select inbox on login (false does not)
     *
     * @return true on success or PEAR_Error
     *
     * @access private
     * @since  1.0
     */
    function _login($user, $pass, $auth)
    {
        assert('!is_null( $user )');
        assert('!is_null( $pass )');

        if (is_null($auth)) {
            $auth = 'USER';
        }
        //Try the selected Auth method
        if (PEAR::isError($parsed = $this->_authenticate($user, $pass, $auth))) {
            return $parsed;
        }

        if (strtoupper($parsed['RESPONSE']['CODE']) != 'OK') {
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $parsed['RESPONSE']['STR_CODE']);
                $this->_listener->error(-1, cb_msg('fw.mail', 'Authentication failed.'));
            }

            return new PEAR_Error();
        }

        return true;
    }

    /**
     * get the cmd ID
     *
     * @return string Returns the CmdID and increment the counter
     *
     * @access private
     * @since  1.0
     */
    function _getCmdId()
    {
        $lastCmdID = 'A000' . $this->_cmdCounter;
        $this->_cmdCounter++;

        return $lastCmdID;
    }

    /**
     * Send the given string of data to the server.
     *
     * @param   string $data The string of data to send.
     *
     * @return  mixed   True on success or a PEAR_Error object on failure.
     *
     * @access  private
     * @since   1.0
     */
    function _writeLine($data)
    {
        if (PEAR::isError($err = $this->_socket->write("$data\r\n"))) {
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(-1, cb_msg('fw.mail', 'Failed to write data.'));
            }
            if ( ! is_null($this->_logger)) {
                $this->_logger->debug($err->getMessage());
            }

            return $err;
        }

        if ( ! is_null($this->_logger)) {
            if ($this->_logger->isDebugEnabled()) {
                // C: means this data was sent by  the client (this class)
                $this->_logger->debug("C: $data");
            }
        }

        return true;
    }

    /**
     * Receive the given string of data from the server.
     *
     * @return  mixed   a line of response on success or a PEAR_Error object on failure.
     *
     * @access  private
     * @since   1.0
     */
    function &_readLine()
    {
        $line = $this->_readutil->readLine();
        if (PEAR::isError($line)) {
            return $line;
        } else {
            return $line;
        }
    }

    function _genericCommand($command, $params = null)
    {
        $cmdid = $this->_getCmdId();
        if (PEAR::isError($err = $this->_putCMD($cmdid, $command, $params))) {
            return $err;
        }
        if (PEAR::isError($args = $this->_getRawResponse($cmdid))) {
            return $args;
        }
        $parsed = $this->_genericImapResponseParser($args, $cmdid);
        if (strtoupper($parsed['RESPONSE']['CODE']) != 'OK') {
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $parsed['RESPONSE']['STR_CODE']);
            }

            return new PEAR_Error();
        }

        return $parsed;
    }

    /**
     * Send a command to the server with an optional string of arguments.
     * A carriage return / linefeed (CRLF) sequence will be appended to each
     * command string before it is sent to the IMAP server.
     *
     * @param   string $commandId   The IMAP cmdID to send to the server.
     * @param   string $command     The IMAP command to send to the server.
     * @param   string $args        A string of optional arguments to append
     *                              to the command.
     *
     * @return  mixed   The result of the _writeLine() call.
     *
     * @access  private
     * @since   1.0
     */
    function _putCMD($commandId, $command, $args = null)
    {
        if (is_null($args)) {
            return $this->_writeLine("$commandId $command");
        }

        return $this->_writeLine("$commandId $command $args");
    }

    /**
     * Get a response from the server with an optional string of commandID.
     * A carriage return / linefeed (CRLF) sequence will be appended to each
     * command string before it is sent to the IMAP server.
     *
     * @param   string $commandid The IMAP commandid retrive from the server.
     *
     * @return  string   The result response.
     *
     * @access  private
     */
    function _getRawResponse($commandId = '*', $errId = null)
    {
        $arguments = '';

        for (; ;) {
            if (PEAR::isError($line = $this->_readLine())) {
                return $line;
            }

            $reply_code = strtok($line, ' ');
            $arguments .= "$line\r\n";

            if (substr($line, strlen($line) - 1) == '}') {
                $line = substr($line, 0, strlen($line) - 1);
                $pos = strrpos($line, '{');
                if ($pos !== false) {
                    $length = substr($line, $pos + 1);
                    if (is_numeric($length)) {
                        if (PEAR::isError($data = $this->_readutil->read($length))) {
                            return $data;
                        }
                        $arguments .= $data;
                    }
                }
            }

            if ( ! (strcmp($commandId, $reply_code))) {
                return $arguments;
            }
            if ( ! is_null($errId) && strcmp($errId, $reply_code) == 0) {
                return new PEAR_Error();
            }
            if (strpos(strtok(' '), 'BYE') === 0) {
                if ( ! is_null($this->_listener)) {
                    $this->_listener->error(-1, cb_msg('fw.mail', 'The server returned an error response.'));
                }

                return new PEAR_Error();
            }
        }

        return $arguments;
    }

    /* Authenticates the user using the DIGEST-MD5 method.
    *
    * @param string The userid to authenticate as.
    * @param string The password to authenticate with.
    * @param string The cmdID.
    *
    * @return array Returns an array containing the response
    *
    * @access private
    * @since  1.0
    */
    function _authDIGEST_MD5($uid, $pwd, $cmdid)
    {
        assert('!is_null( $uid )');
        assert('!is_null( $pwd )');

        if (PEAR::isError($err = $this->_putCMD($cmdid, 'AUTHENTICATE', 'DIGEST-MD5'))) {
            return $err;
        }

        if (PEAR::isError($args = $this->_readLine())) {
            return $args;
        }

        $tokens = $args;
        $this->_getNextToken($tokens, $plus);
        if ($plus != '+') {
            $parsed = $this->_genericImapResponseParser($args, $cmdid);
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $parsed['RESPONSE']['STR_CODE']);
            }

            return new PEAR_Error();
        }
        $this->_getNextToken($tokens, $space);
        $this->_getNextToken($tokens, $challenge);
        $challenge = base64_decode($challenge);
        if ( ! is_null($this->_logger)) {
            $this->_logger->debug("challenge: $challenge");
        }

        $digest = Auth_SASL::factory('DIGESTMD5');

        function _cb_mail_realm_selector($realm)
        {
            if ((count($realm) == 1 || array_search($realm, $this->_domain) === false) && $realm != '') {
                return $realm;
            }

            return $this->_domain;
        }

        $auth_str = $digest->getResponse($uid, $pwd, $challenge, $this->_host, 'imap', null, $this->_domain);
        if ( ! is_null($this->_logger)) {
            $this->_logger->debug("response: $auth_str");
        }
        $auth_str = base64_encode($auth_str);
        if (PEAR::isError($err = $this->_writeLine($auth_str))) {
            return $err;
        }

        if (PEAR::isError($args = $this->_readLine())) {
            return $args;
        }

        $tokens = $args;
        $this->_getNextToken($tokens, $plus);
        if ($plus != '+') {
            $parsed = $this->_genericImapResponseParser($args, $cmdid);
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $parsed['RESPONSE']['STR_CODE']);
            }

            return new PEAR_Error();
        }

        /*
         * We don't use the protocol's third step because IMAP doesn't allow
         * subsequent authentication, so we just silently ignore it.
         */
        if (PEAR::isError($err = $this->_writeLine(''))) {
            return $err;
        }

        if (PEAR::isError($args = $this->_getRawResponse($cmdid))) {
            return $args;
        }

        return $this->_genericImapResponseParser($args, $cmdid);
    }

    /* Authenticates the user using the CRAM-MD5 method.
    *
    * @param string The userid to authenticate as.
    * @param string The password to authenticate with.
    * @param string The cmdID.
    *
    * @return array Returns an array containing the response
    *
    * @access private
    * @since  1.0
    */
    function _authCRAM_MD5($uid, $pwd, $cmdid)
    {
        assert('!is_null( $uid )');
        assert('!is_null( $pwd )');

        if (PEAR::isError($err = $this->_putCMD($cmdid, 'AUTHENTICATE', 'CRAM-MD5'))) {
            return $err;
        }

        if (PEAR::isError($args = $this->_readLine())) {
            return $args;
        }

        $tokens = $args;
        $this->_getNextToken($tokens, $plus);
        if ($plus != '+') {
            $parsed = $this->_genericImapResponseParser($args, $cmdid);
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $parsed['RESPONSE']['STR_CODE']);
            }

            return new PEAR_Error();
        }
        $this->_getNextToken($tokens, $space);
        $this->_getNextToken($tokens, $challenge);
        $challenge = base64_decode($challenge);
        if ( ! is_null($this->_logger)) {
            $this->_logger->debug("challenge: $challenge");
        }

        $cram = Auth_SASL::factory('CRAMMD5');
        $auth_str = $cram->getResponse($uid, $pwd, $challenge);
        if ( ! is_null($this->_logger)) {
            $this->_logger->debug("response: $auth_str");
        }
        $auth_str = base64_encode($auth_str);

        if (PEAR::isError($err = $this->_writeLine($auth_str))) {
            return $err;
        }

        if (PEAR::isError($args = $this->_getRawResponse($cmdid))) {
            return $args;
        }

        return $this->_genericImapResponseParser($args, $cmdid);
    }

    /* Authenticates the user using the LOGIN method.
    *
    * @param string The userid to authenticate as.
    * @param string The password to authenticate with.
    * @param string The cmdID.
    *
    * @return array Returns an array containing the response
    *
    * @access private
    * @since  1.0
    */
    function _authLOGIN($uid, $pwd, $cmdid)
    {
        assert('!is_null( $uid )');
        assert('!is_null( $pwd )');

        if (PEAR::isError($err = $this->_putCMD($cmdid, 'AUTHENTICATE', 'LOGIN'))) {
            return $err;
        }
        if (PEAR::isError($args = $this->_readLine())) {
            return $args;
        }

        $tokens = $args;
        $this->_getNextToken($tokens, $plus);
        if ($plus != '+') {
            $parsed = $this->_genericImapResponseParser($args, $cmdid);
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $parsed['RESPONSE']['STR_CODE']);
            }

            return new PEAR_Error();
        }
        $this->_getNextToken($tokens, $space);
        $this->_getNextToken($tokens, $challenge);
        $challenge = base64_decode($challenge);

        $auth_str = base64_encode("$uid");
        if (PEAR::isError($err = $this->_writeLine($auth_str))) {
            return $err;
        }

        if (PEAR::isError($args = $this->_readLine())) {
            return $args;
        }
        $tokens = $args;
        $this->_getNextToken($tokens, $plus);
        if ($plus != '+') {
            $parsed = $this->_genericImapResponseParser($args, $cmdid);
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $parsed['RESPONSE']['STR_CODE']);
            }

            return new PEAR_Error();
        }

        $auth_str = base64_encode("$pwd");
        if (PEAR::isError($err = $this->_writeLine($auth_str))) {
            return $err;
        }

        if (PEAR::isError($args = $this->_getRawResponse($cmdid))) {
            return $args;
        }

        return $this->_genericImapResponseParser($args, $cmdid);
    }

    function _authPLAIN($user, $pass, $cmdid)
    {
        assert('!is_null( $user )');
        assert('!is_null( $pass )');

        if (PEAR::isError($err = $this->_putCMD($cmdid, 'AUTHENTICATE', 'PLAIN'))) {
            return $err;
        }
        if (PEAR::isError($args = $this->_readLine())) {
            return $args;
        }

        $args = ltrim($args);
        if (substr($args, 0, 1) != '+') {
            $parsed = $this->_genericImapResponseParser($args, $cmdid);
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(1, $parsed['RESPONSE']['STR_CODE']);
            }

            return new PEAR_Error();
        }
        $auth_str = base64_encode(chr(0) . $user . chr(0) . $pass);

        if (PEAR::isError($err = $this->_writeLine($auth_str))) {
            return $err;
        }

        if (PEAR::isError($args = $this->_getRawResponse($cmdid))) {
            return $args;
        }

        return $this->_genericImapResponseParser($args, $cmdid);
    }

    /**
     * Attempt to login to the iMAP server.
     *
     * @param string The userid to authenticate as.
     * @param string The password to authenticate with.
     *
     * @return array Returns an array containing the response
     *
     * @access public
     * @since  1.0
     */
    function _authUSER($uid, $pwd, $cmdid)
    {
        assert('!is_null( $uid )');
        assert('!is_null( $pwd )');

        $param = "\"$uid\" \"$pwd\"";
        if (PEAR::isError($err = $this->_putCMD($cmdid, 'LOGIN', $param))) {
            return $err;
        }
        if (PEAR::isError($args = $this->_getRawResponse($cmdid))) {
            return $args;
        }

        return $this->_genericImapResponseParser($args, $cmdid);
    }

    /**
     * Returns the name of the best authentication method that the server
     * has advertised.
     *
     * @param string if !=null,authenticate with this method ( $userMethod).
     *
     * @return mixed    Returns a string containing the name of the best
     *                  supported authentication method or a PEAR_Error object
     *                  if a failure condition is encountered.
     * @access private
     * @since  1.0
     */
    function _getBestAuthMethod()
    {
        if (is_null($this->_serverSupportedCapabilities)) {
            $this->cmdCAPABILITY();
        }

        $methods = $this->_supportedAuthMethods;

        if (($methods != null) && ($this->_serverAuthMethods != null)) {
            foreach ($methods as $method) {
                if (in_array($method, $this->_serverAuthMethods)) {
                    return $method;
                }
            }
            $serverMethods = implode(',', $this->_serverAuthMethods);
            $myMethods = implode(',', $this->_supportedAuthMethods);
            $msg = cb_msg('fw.mail', 'No authentication methods available.');
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(-1, $msg);
            }
            if ( ! is_null($this->_logger)) {
                $this->_logger->debug($msg);
            }

            return new PEAR_Error();
        } else {
            $msg = cb_msg('fw.mail', 'No authentication methods available.');
            if ( ! is_null($this->_listener)) {
                $this->_listener->error(-1, $msg);
            }
            if ( ! is_null($this->_logger)) {
                $this->_logger->debug($msg);
            }

            return new PEAR_Error();
        }
    }

    /**
     * Attempt to authenticate to the iMAP server.
     *
     * @param string The userid to authenticate as.
     * @param string The password to authenticate with.
     * @param string The cmdID.
     *
     * @return array Returns an array containing the response
     *
     * @access public
     * @since  1.0
     */
    function _authenticate($uid, $pwd, $method = 'AUTO')
    {
        assert('!is_null( $uid )');
        assert('!is_null( $pwd )');

        $cmdid = $this->_getCmdId();

        if ($method == 'AUTO') {
            if (PEAR::isError($method = $this->_getBestAuthMethod())) {
                return $method;
            }
        } else {
            $method = strtoupper($method);
            if ( ! in_array($method, $this->_supportedAuthMethods)) {
                $msg = cb_msg('fw.mail', '&&method&& is not a supported authentication method.', ['method' => $method]);
                if ( ! is_null($this->_listener)) {
                    $this->_listener->error(-1, $msg);
                }
                if ( ! is_null($this->_logger)) {
                    $this->_logger->debug($msg);
                }

                return new PEAR_Error();
            }
        }

        switch ($method) {
            case 'DIGEST-MD5':
                $result = $this->_authDIGEST_MD5($uid, $pwd, $cmdid);
                break;
            case 'CRAM-MD5':
                $result = $this->_authCRAM_MD5($uid, $pwd, $cmdid);
                break;
            case 'LOGIN':
                $result = $this->_authLOGIN($uid, $pwd, $cmdid);
                break;
            case 'PLAIN':
                $result = $this->_authPLAIN($uid, $pwd, $cmdid);
                break;
            case 'USER':
                $result = $this->_authUSER($uid, $pwd, $cmdid);
                break;

            default :
                $msg = cb_msg('fw.mail', '&&method&& is not a supported authentication method.', ['method' => $method]);
                if ( ! is_null($this->_listener)) {
                    $this->_listener->error(-1, $msg);
                }
                if ( ! is_null($this->_logger)) {
                    $this->_logger->debug($msg);
                }

                return new PEAR_Error();
        }

        return $result;
    }

    /**
     * Attempt to disconnect from the IMAP server.
     *
     * @return array Returns an array containing the response
     *
     * @access public
     * @since  1.0
     */
    function cmdLOGOUT()
    {
        $cmdid = $this->_getCmdId();
        if (PEAR::isError($err = $this->_putCMD($cmdid, 'LOGOUT'))) {
            return $err;
        }
        if (PEAR::isError($args = $this->_getRawResponse('*', $cmdid))) {
            return $args;
        }

        return $args;
    }

    /**
     * Send the  Select Mailbox Command
     *
     * @param string The mailbox to select.
     *
     * @return array Returns an array containing the response
     *
     * @access public
     * @since  1.0
     */
    function cmdSELECT($mailbox)
    {
        assert('!is_null( $mailbox )');

        $mailbox_name = sprintf("\"%s\"", $this->utf_7_encode($mailbox));
        if (PEAR::isError($result = $this->_genericCommand('SELECT', $mailbox_name))) {
            return $result;
        }
        $this->_currentMailbox = $mailbox;
        $this->_writeable = true;

        return $result;
    }

    /**
     * Send the  EXAMINE  Mailbox Command
     *
     * @param string The mailbox to examine.
     *
     * @return array Returns an array containing the response
     *
     * @access public
     * @since  1.0
     */
    function cmdEXAMINE($mailbox)
    {
        assert('!is_null( $mailbox )');

        $mailbox_name = sprintf("\"%s\"", $this->utf_7_encode($mailbox));
        if (PEAR::isError($result = $this->_genericCommand('EXAMINE', $mailbox_name))) {
            return $result;
        }
        $this->_currentMailbox = $mailbox;
        $this->_writeable = false;

        return $result;
    }

    /**
     * Send the  FETCH Command
     *
     * @return mixed Returns a PEAR_Error with an error message on any
     *               kind of failure, or true on success.
     * @access public
     * @since  1.0
     */
    function cmdFETCH($msgset, $fetchparam)
    {
        return $this->_genericCommand('FETCH', "$msgset $fetchparam");
    }

    /**
     * Send the  CAPABILITY Command
     *
     * @return mixed Returns a PEAR_Error with an error message on any
     *               kind of failure, or true on success.
     * @access public
     * @since  1.0
     */
    function cmdCAPABILITY()
    {
        $this->_serverAuthMethods = ['USER'];
        $this->_serverSupportedCapabilities = [];
        if (PEAR::isError($result = $this->_genericCommand('CAPABILITY'))) {
            return $result;
        }
        if (isset($result['PARSED'])) {
            $result['PARSED'] = $result['PARSED'][0]['EXT']['CAPABILITY'];
            //fill the $this->_serverAuthMethods and $this->_serverSupportedCapabilities arrays
            foreach ($result['PARSED']['CAPABILITIES'] as $auth_method) {
                if (strtoupper(substr($auth_method, 0, 5)) == 'AUTH=') {
                    $this->_serverAuthMethods[] = substr($auth_method, 5);
                }
            }
            // Keep the capabilities response to use ir later
            $this->_serverSupportedCapabilities = $result['PARSED']['CAPABILITIES'];
        }

        return $result;
    }

    /**
     * Send the  STATUS Mailbox Command
     *
     * @param string $mailbox the mailbox name
     * @param string $request the request status it could be:
     *                        MESSAGES | RECENT | UIDNEXT
     *                        UIDVALIDITY | UNSEEN
     *
     * @return array Returns a Parsed Response
     *
     * @access public
     * @since  1.0
     */
    function cmdSTATUS($mailbox, $request)
    {
        assert('!is_null( $mailbox )');

        $mailbox_name = sprintf("\"%s\"", $this->utf_7_encode($mailbox));
        if ($request != 'MESSAGES' && $request != 'RECENT' && $request != 'UIDNEXT' && $request != 'UIDVALIDITY'
            && $request != 'UNSEEN'
        ) {
            if ( ! is_null($this->_logger)) {
                $this->_logger->warning("Invalid request: '$request'. See RFC2060.");
            }
        }
        if (PEAR::isError($result = $this->_genericCommand('STATUS', "$mailbox_name ($request)"))) {
            return $result;
        }
        if (isset($result['PARSED'])) {
            $result['PARSED'] = $result['PARSED'][count($result['PARSED']) - 1]['EXT'];
        }

        return $result;
    }

    /**
     * Send the  LIST  Command
     *
     * @return mixed Returns a PEAR_Error with an error message on any
     *               kind of failure, or true on success.
     * @access public
     * @since  1.0
     */
    function cmdLIST($mailbox_base, $mailbox)
    {
        assert('!is_null( $mailbox_base )');
        assert('!is_null( $mailbox )');

        $mailbox_name = sprintf("\"%s\"", $this->utf_7_encode($mailbox));
        $mailbox_base = sprintf("\"%s\"", $this->utf_7_encode($mailbox_base));

        return $this->_genericCommand('LIST', "$mailbox_base $mailbox_name");
    }

    /**
     * Send the CLOSE command.
     *
     * @return mixed Returns a PEAR_Error with an error message on any
     *               kind of failure, or true on success.
     * @access public
     * @since  1.0
     */
    function cmdCLOSE()
    {
        return $this->_genericCommand('CLOSE');
    }

    /**
     * Send the EXPUNGE command.
     *
     * @return mixed Returns a PEAR_Error with an error message on any
     *               kind of failure, or true on success.
     * @access public
     * @since  1.0
     */
    function cmdEXPUNGE()
    {
        if (PEAR::isError($result = $this->_genericCommand('EXPUNGE'))) {
            return $result;
        }
        if (isset($result['PARSED'])) {
            $parsed = $result['PARSED'];
            unset($result['PARSED']);
            foreach ($parsed as $command) {
                if (strtoupper($command['COMMAND']) == 'EXPUNGE') {
                    $result['PARSED'][$command['COMMAND']][] = $command['NRO'];
                } else {
                    $result['PARSED'][$command['COMMAND']] = $command['NRO'];
                }
            }
        }

        return $result;
    }

    /**
     * Send the SEARCH command.
     *
     * @return mixed Returns a PEAR_Error with an error message on any
     *               kind of failure, or true on success.
     * @access public
     * @since  1.0
     */

    function cmdSEARCH($search_cmd)
    {
        $result = $this->_genericCommand('SEARCH', $search_cmd);
        if (PEAR::isError($result)) {
            return $result;
        }

        if ( ! isset($result['PARSED'])
             || ! is_array($result['PARSED'])
        ) {
            return new PEAR_Error();
        }

        foreach ($result['PARSED'] as $parsed_data) {
            if (isset($parsed_data['COMMAND']) && $parsed_data['COMMAND'] == 'SEARCH') {
                $result['PARSED'] = $parsed_data['EXT'];
                break;
            }
        }

        return $result;
    }

    /**
     * Send the STORE command.
     *
     * @param string $message_set the sessage_set
     * @param string $dataitem    : the way we store the flags
     *                            FLAGS: replace the flags whith $value
     *                            FLAGS.SILENT: replace the flags whith $value but don't return untagged responses
     *
     *          +FLAGS: Add the flags whith $value
     *          +FLAGS.SILENT: Add the flags whith $value but don't return untagged responses
     *
     *          -FLAGS: Remove the flags whith $value
     *          -FLAGS.SILENT: Remove the flags whith $value but don't return untagged responses
     *
     * @param string $value
     *
     * @return mixed Returns a PEAR_Error with an error message on any
     *               kind of failure, or true on success.
     * @access public
     * @since  1.0
     */

    function cmdSTORE($message_set, $dataitem, $value)
    {
        /* As said in RFC2060...
        C: A003 STORE 2:4 +FLAGS (\Deleted)
        S: * 2 FETCH FLAGS (\Deleted \Seen)
        S: * 3 FETCH FLAGS (\Deleted)
        S: * 4 FETCH FLAGS (\Deleted \Flagged \Seen)
        S: A003 OK STORE completed
        */
        if ($dataitem != 'FLAGS' && $dataitem != 'FLAGS.SILENT' && $dataitem != '+FLAGS' && $dataitem != '+FLAGS.SILENT'
            && $dataitem != '-FLAGS'
            && $dataitem != '-FLAGS.SILENT'
        ) {
            if ( ! is_null($this->_logger)) {
                $this->_logger->warning("Invalid dataitem: '$dataitem'. See RFC2060.");
            }
        }
        $param = sprintf("%s %s (%s)", $message_set, $dataitem, $value);

        return $this->_genericCommand('STORE', $param);
    }

    /**
     * Parses the responses like RFC822.SIZE and INTERNALDATE
     *
     * @param string the IMAP's server response
     *
     * @return string containing  the parsed response
     * @access private
     * @since  1.0
     */

    function _parseOneStringResponse(&$str, $line, $file)
    {
        $this->_parseSpace($str, $line, $file);
        $size = $this->_getNextToken($str, $uid);

        return $uid;
    }

    /**
     * Parses the FLAG response
     *
     * @param string the IMAP's server response
     *
     * @return Array containing  the parsed  response
     * @access private
     * @since  1.0
     */
    function _parseFLAGSresponse(&$str)
    {
        $this->_parseSpace($str, __LINE__, __FILE__);
        $params_arr[] = $this->_arrayfy_content($str);
        $flags_arr = [];
        for ($i = 0; $i < count($params_arr[0]); $i++) {
            $flags_arr[] = $params_arr[0][$i];
        }

        return $flags_arr;
    }

    /**
     * Parses the BODY response
     *
     * @param string the IMAP's server response
     *
     * @return Array containing  the parsed  response
     * @access private
     * @since  1.0
     */

    function _parseBodyResponse(&$str, $command)
    {
        $this->_parseSpace($str, __LINE__, __FILE__);
        while ($str[0] != ')' && $str != '') {
            $params_arr[] = $this->_arrayfy_content($str);
        }

        return $params_arr;
    }

    /**
     * Makes the content an Array
     *
     * @param string the IMAP's server response
     *
     * @return Array containing  the parsed  response
     * @access private
     * @since  1.0
     */
    function _arrayfy_content(&$str)
    {
        $params_arr = [];
        $this->_getNextToken($str, $params);
        if ($params != '(') {
            return $params;
        }
        $this->_getNextToken($str, $params, false, false);
        while ($str != '' && $params != ')') {
            if ($params != '') {
                if ($params[0] == '(') {
                    $params = $this->_arrayfy_content($params);
                }
                if ($params != ' ') {
                    //I don't remove the colons (") to handle the case of retriving " "
                    // If I remove the colons the parser will interpret this field as an imap separator (space)
                    // instead of a valid field so I remove the colons here
                    if ($params == '""') {
                        $params = '';
                    } else {
                        if ($params[0] == '"') {
                            $params = substr($params, 1, strlen($params) - 2);
                        }
                    }
                    $params_arr[] = $params;
                }
            } else {
                //if params if empty (for example i'm parsing 2 quotes ("")
                // I'll append an array entry to mantain compatibility
                $params_arr[] = $params;
            }
            $this->_getNextToken($str, $params, false, false);
        }

        return $params_arr;
    }

    /**
     * Parses the BODY[],BODY[TEXT],.... responses
     *
     * @param string the IMAP's server response
     *
     * @return Array containing  the parsed  response
     * @access private
     * @since  1.0
     */
    function _parseContentresponse(&$str, $command)
    {
        $content = '';
        $this->_parseSpace($str, __LINE__, __FILE__);
        $size = $this->_getNextToken($str, $content);

        return ['CONTENT' => $content, 'CONTENT_SIZE' => $size];
    }

    /**
     * Utility funcion to find the closing parenthesis ")" Position it takes care of quoted ones
     *
     * @param string the IMAP's server response
     *
     * @return int containing  the pos of the closing parenthesis ")"
     * @access private
     * @since  1.0
     */
    function _getClosingBracesPos($str_line, $startDelim = '(', $stopDelim = ')')
    {
        $len = strlen($str_line);
        $pos = 0;
        // ignore all extra characters
        // If inside of a string, skip string -- Boundary IDs and other
        // things can have ) in them.
        if ($str_line[$pos] != $startDelim) {
            if ( ! is_null($this->_logger)) {
                $this->_logger->warning("_getClosingParenthesisPos: must start with a '(' but is a '" . $str_line[$pos]
                                        . "'!:" .
                                        "STR_LINE:$str_line|size:$len|POS: $pos");
            }

            return ($len);
        }
        $stack = 1;
        for ($pos = 1; $pos < $len; $pos++) {
            if ($str_line[$pos] == $stopDelim) {
                --$stack;
                if ($stack == 0) {
                    break;
                }
            } elseif ($str_line[$pos] == '"') {
                $pos++;
                while ($str_line[$pos] != '"' && $pos < $len) {
                    if ($str_line[$pos] == "\\" && $str_line[$pos + 1] == '"') {
                        $pos++;
                    }
                    if ($str_line[$pos] == "\\" && $str_line[$pos + 1] == "\\") {
                        $pos++;
                    }
                    $pos++;
                }
            } elseif ($str_line[$pos] == $startDelim) {
                ++$stack;
            }
        }
        if ($str_line[$pos] != $stopDelim) {
            if ( ! is_null($this->_logger)) {
                $this->_logger->warning("_getClosingBracesPos: must be a $stopDelim but is a '" . $str_line[$pos]
                                        . "'!:POS:$pos|STR_LINE:$str_line");
            }
        }

        if ($pos >= $len) {
            return false;
        }

        return $pos;
    }

    /**
     * Utility funcion to get from here to the end of the line
     *
     * @param string the IMAP's server response
     *
     * @return string containing  the string to the end of the line
     * @access private
     * @since  1.0
     */

    function _getToEOL(&$str, $including = true)
    {
        $len = strlen($str);
        if ($including) {
            for ($i = 0; $i < $len; $i++) {
                if ($str[$i] == "\n") {
                    break;
                }
            }
            $content = substr($str, 0, $i + 1);
            $str = substr($str, $i + 1);

            return $content;

        } else {
            for ($i = 0; $i < $len; $i++) {
                if ($str[$i] == "\n" || $str[$i] == "\r") {
                    break;
                }
            }
            $content = substr($str, 0, $i);
            $str = substr($str, $i);

            return $content;
        }
    }

    /**
     * Fetches the next IMAP token or parenthesis
     *
     * @param string the IMAP's server response
     * @param string the next token
     * @param boolean true: the parenthesis IS a token, false: I consider
     *        all the response in parenthesis as a token
     *
     * @return int containing  the content size
     * @access private
     * @since  1.0
     */
    function _getNextToken(&$str, &$content, $parenthesisIsToken = true, $colonIsToken = true)
    {
        $len = strlen($str);
        $pos = 0;
        $content_size = false;
        $content = false;
        if ($str == '' || $len < 2) {
            $content = $str;

            return $len;
        }
        switch ($str[0]) {
            case '{':
                if (($posClosingBraces = $this->_getClosingBracesPos($str, '{', '}')) == false) {
                    if ( ! is_null($this->_logger)) {
                        $this->_logger->warning("_getClosingBracesPos() error!");
                    }
                }
                if ( ! is_numeric(($strBytes = substr($str, 1, $posClosingBraces - 1)))) {
                    if ( ! is_null($this->_logger)) {
                        $this->_logger->warning("must be a number but is a '" . $strBytes . "'!");
                    }
                }
                if ($str[$posClosingBraces] != '}') {
                    if ( ! is_null($this->_logger)) {
                        $this->_logger->warning("must be a '}'  but is a '" . $str[$posClosingBraces] . "'!");
                    }
                }
                if ($str[$posClosingBraces + 1] != "\r") {
                    if ( ! is_null($this->_logger)) {
                        $this->_logger->warning("must be a '\\r'  but is a '" . $str[$posClosingBraces + 1] . "'!");
                    }
                }
                if ($str[$posClosingBraces + 2] != "\n") {
                    if ( ! is_null($this->_logger)) {
                        $this->_logger->warning("must be a '\\n'  but is a '" . $str[$posClosingBraces + 2] . "'!");
                    }
                }
                $content = substr($str, $posClosingBraces + 3, $strBytes);
                if (strlen($content) != $strBytes) {
                    if ( ! is_null($this->_logger)) {
                        $this->_logger->warning("content size is " . strlen($content)
                                                . " but the string reports a size of $strBytes!");
                    }
                }
                $content_size = $strBytes;
                //Advance the string
                $str = substr($str, $posClosingBraces + $strBytes + 3);
                break;
            case '"':
                if ($colonIsToken) {
                    for ($pos = 1; $pos < $len; $pos++) {
                        if ($str[$pos] == "\"") {
                            break;
                        }
                        if ($str[$pos] == "\\" && $str[$pos + 1] == "\"") {
                            $pos++;
                        }
                        if ($str[$pos] == "\\" && $str[$pos + 1] == "\\") {
                            $pos++;
                        }
                    }
                    if ($str[$pos] != '"') {
                        if ( ! is_null($this->_logger)) {
                            $this->_logger->warning("must be a '\"'  but is a '" . $str[$pos] . "'!");
                        }
                    }
                    $content_size = $pos;
                    $content = substr($str, 1, $pos - 1);
                    //Advance the string
                    $str = substr($str, $pos + 1);
                } else {
                    for ($pos = 1; $pos < $len; $pos++) {
                        if ($str[$pos] == "\"") {
                            break;
                        }
                        if ($str[$pos] == "\\" && $str[$pos + 1] == "\"") {
                            $pos++;
                        }
                        if ($str[$pos] == "\\" && $str[$pos + 1] == "\\") {
                            $pos++;
                        }
                    }
                    if ($str[$pos] != '"') {
                        if ( ! is_null($this->_logger)) {
                            $this->_logger->warning("must be a '\"'  but is a '" . $str[$pos] . "'!");
                        }
                    }
                    $content_size = $pos;
                    $content = substr($str, 0, $pos + 1);
                    //Advance the string
                    $str = substr($str, $pos + 1);

                }
                break;

            case "\r":
                $pos = 1;
                if ($str[1] == "\n") {
                    $pos++;
                }
                $content_size = $pos;
                $content = substr($str, 0, $pos);
                $str = substr($str, $pos);
                break;
            case "\n":
                $pos = 1;
                $content_size = $pos;
                $content = substr($str, 0, $pos);
                $str = substr($str, $pos);
                break;
            case '(':
                if ($parenthesisIsToken == false) {
                    $pos = $this->_getClosingBracesPos($str);
                    $content_size = $pos + 1;
                    $content = substr($str, 0, $pos + 1);
                    $str = substr($str, $pos + 1);
                } else {
                    $pos = 1;
                    $content_size = $pos;
                    $content = substr($str, 0, $pos);
                    $str = substr($str, $pos);
                }
                break;
            case ')':
                $pos = 1;
                $content_size = $pos;
                $content = substr($str, 0, $pos);
                $str = substr($str, $pos);
                break;
            case ' ':
                $pos = 1;
                $content_size = $pos;
                $content = substr($str, 0, $pos);
                $str = substr($str, $pos);
                break;
            default:
                for ($pos = 0; $pos < $len; $pos++) {
                    if ($str[$pos] == ' ' || $str[$pos] == "\r" || $str[$pos] == ')' || $str[$pos] == '('
                        || $str[$pos] == "\n"
                    ) {
                        break;
                    }
                    if ($str[$pos] == "\\" && $str[$pos + 1] == ' ') {
                        $pos++;
                    }
                    if ($str[$pos] == "\\" && $str[$pos + 1] == "\\") {
                        $pos++;
                    }
                }
                //Advance the string
                if ($pos == 0) {
                    $content_size = 1;
                    $content = substr($str, 0, 1);
                    $str = substr($str, 1);
                } else {
                    $content_size = $pos;
                    $content = substr($str, 0, $pos);
                    if ($pos < $len) {
                        $str = substr($str, $pos);
                    } else {
                        //if this is the end of the string... exit the switch
                        break;
                    }
                }
                break;
        }

        return $content_size;
    }

    function _getEXTarray(&$str, $startDelim = '(', $stopDelim = ')')
    {
        /* I let choose the $startDelim  and $stopDelim to allow parsing
           the OK response  so I also can parse a response like this
           * OK [UIDNEXT 150] Predicted next UID
        */
        $this->_getNextToken($str, $parenthesis);
        if ($parenthesis != $startDelim) {
            if ( ! is_null($this->_logger)) {
                $this->_logger->warning("must be a '$startDelim' but is a '$parenthesis' !");
            }
        }
        $parenthesis = '';
        $struct_arr = [];
        while ($parenthesis != $stopDelim && $str != '') {
            // The command
            $this->_getNextToken($str, $token);
            $token = strtoupper($token);

            if (($ret = $this->_retrParsedResponse($str, $token)) != false) {
                //$struct_arr[$token] = $ret;
                $struct_arr = array_merge($struct_arr, $ret);
            }

            $parenthesis = $token;
        }//While

        return $struct_arr;
    }

    function _retrParsedResponse(&$str, $token, $previousToken = null)
    {
        switch ($token) {
            case 'RFC822.SIZE' :
                return [$token => $this->_parseOneStringResponse($str, __LINE__, __FILE__)];
                break;

            case 'RFC822' :
            case 'BODY' :
                return [$token => $this->_parseContentresponse($str, $token)];
                break;

            case 'FLAGS' :
            case 'PERMANENTFLAGS' :
                return [$token => $this->_parseFLAGSresponse($str)];
                break;

            case 'EXPUNGE' :
                return false;
                break;

            case 'UID' :
            case 'UIDNEXT' :
            case 'UIDVALIDITY' :
            case 'UNSEEN' :
            case 'MESSAGES' :
            case 'UIDNEXT' :
            case 'UIDVALIDITY' :
            case 'UNSEEN' :
            case 'INTERNALDATE' :
                return [$token => $this->_parseOneStringResponse($str, __LINE__, __FILE__)];
                break;

            case 'BODY' :
            case 'BODYSTRUCTURE' :
                return [$token => $this->_parseBodyResponse($str, $token)];
                break;

            case 'RECENT' :
                if ($previousToken != null) {
                    $aux['RECENT'] = $previousToken;

                    return $aux;
                } else {
                    return [$token => $this->_parseOneStringResponse($str, __LINE__, __FILE__)];
                }
                break;

            case 'EXISTS' :
                return [$token => $previousToken];
                break;

            case 'READ-WRITE' :
            case 'READ-ONLY' :
                return [$token => $token];
                break;

            case 'MESSAGE' :
                $mused = $this->_parseOneStringResponse($str, __LINE__, __FILE__);
                $mmax = $this->_parseOneStringResponse($str, __LINE__, __FILE__);

                return [$token => ["MUSED" => $mused, "MMAX" => $mmax]];
                break;

            case 'FETCH' :
                $this->_parseSpace($str, __LINE__, __FILE__);
                // Get the parsed pathenthesis
                $struct_arr = $this->_getEXTarray($str);

                return $struct_arr;
                break;

            case 'CAPABILITY' :
                $this->_parseSpace($str, __LINE__, __FILE__);
                $str_line = rtrim(substr($this->_getToEOL($str, false), 0));
                $struct_arr['CAPABILITIES'] = explode(' ', $str_line);

                return [$token => $struct_arr];
                break;

            case 'STATUS' :
                $mailbox = $this->_parseOneStringResponse($str, __LINE__, __FILE__);
                $this->_parseSpace($str, __LINE__, __FILE__);
                $ext = $this->_getEXTarray($str);
                $struct_arr['MAILBOX'] = $this->utf_7_decode($mailbox);
                $struct_arr['ATTRIBUTES'] = $ext;

                return [$token => $struct_arr];
                break;

            case 'LIST' :
                $this->_parseSpace($str, __LINE__, __FILE__);
                $params_arr = $this->_arrayfy_content($str);

                $this->_parseSpace($str, __LINE__, __FILE__);
                $this->_getNextToken($str, $hierarchydelim);

                $this->_parseSpace($str, __LINE__, __FILE__);
                $this->_getNextToken($str, $mailbox_name);

                $result_array = [
                    'NAME_ATTRIBUTES'    => $params_arr,
                    'HIERACHY_DELIMITER' => $hierarchydelim,
                    "MAILBOX_NAME"       => $this->utf_7_decode($mailbox_name)
                ];

                return [$token => $result_array];
                break;

            case 'SEARCH' :
                $str_line = rtrim(substr($this->_getToEOL($str, false), 1));
                $struct_arr['SEARCH_LIST'] = explode(' ', $str_line);
                if (count($struct_arr['SEARCH_LIST']) == 1 && $struct_arr['SEARCH_LIST'][0] == '') {
                    $struct_arr['SEARCH_LIST'] = null;
                }

                return [$token => $struct_arr];
                break;

            case 'OK' :
                $str_line = rtrim(substr($this->_getToEOL($str, false), 1));
                $result_array[] = ['COMMAND' => $token, 'EXT' => $str_line];

                return $result_array;
                break;

            case 'NO' :
                $str_line = rtrim(substr($this->_getToEOL($str, false), 1));
                $result_array[] = @['COMMAND' => $token, 'EXT' => $str_line];

                return $result_array;
                break;

            case 'BAD' :
                $str_line = rtrim(substr($this->_getToEOL($str, false), 1));
                $result_array[] = ['COMMAND' => $token, 'EXT' => $str_line];

                return $result_array;
                break;

            case 'BYE' :
                $str_line = rtrim(substr($this->_getToEOL($str, false), 1));
                $result_array[] = ['COMMAND' => $command, 'EXT' => $str_line];

                return $result_array;
                break;

            case '':
                if ( ! is_null($this->_logger)) {
                    $this->_logger->warning('Empty string.');
                }
                break;

            case '(':
                if ( ! is_null($this->_logger)) {
                    $this->_logger->warning("Unexpected '('.");
                }
                break;

            case ')':
                break;

            case "\r\n":
                if ( ! is_null($this->_logger)) {
                    $this->_logger->warning('Unexpected line break.');
                }
                break;

            case ' ':
                // this can happen and we just ignore it
                // This happens when - for example - fetch returns more than 1 parammeter
                // for example you ask to get RFC822.SIZE and UID
                break;

            default:
                $body_token = strtoupper(substr($token, 0, 5));
                $rfc822_token = strtoupper(substr($token, 0, 7));

                if ($body_token == 'BODY[' || $body_token == 'BODY.' || $rfc822_token == 'RFC822.') {
                    return [$token => $this->_parseContentresponse($str, $token)];
                } else {
                    if ( ! is_null($this->_logger)) {
                        $this->_logger->warning("UNIMPLEMMENTED! I don't know the parameter '$token' !");
                    }
                }
                break;
        }

        return false;
    }

    /*
    * Verifies that the next character IS a space
    */
    function _parseSpace(&$str, $line, $file, $printError = true)
    {
        /*
            This code repeats a lot in this class
            so i make it a function to make all the code shorter
        */
        $this->_getNextToken($str, $space);
        if ($space != ' ') {
            if ( ! is_null($this->_logger)) {
                $this->_logger->warning("must be a ' ' but is a '$space'. ( $file:$line)");
            }
        }

        return $space;
    }

    function _parseString(&$str, $char, $line, $file)
    {
        /*
            This code repeats a lot in this class
            so i make it a function to make all the code shorter
        */
        $this->_getNextToken($str, $char_aux);
        if (strtoupper($char_aux) != strtoupper($char)) {
            if ( ! is_null($this->_logger)) {
                $this->_logger->warning("must be a $char but is a '$char_aux'. ( $file:$line)");
            }
        }

        return $char_aux;
    }

    function _genericImapResponseParser(&$str, $cmdid = null)
    {
        $result_array = [];
        $this->_getNextToken($str, $token);

        while ($token != $cmdid && $str != '') {
            if ($token == '+') {
                //if the token  is + ignore the line
                // TODO: verify that this is correct!!!
                $this->_getToEOL($str);
                $this->_getNextToken($str, $token);
            }

            $this->_parseString($str, ' ', __LINE__, __FILE__);

            $this->_getNextToken($str, $token);
            if ($token == '+') {
                $this->_getToEOL($str);
                $this->_getNextToken($str, $token);
            } else {
                if (is_numeric($token)) {
                    // The token is a NUMBER so I store it
                    $msg_nro = $token;
                    $this->_parseSpace($str, __LINE__, __FILE__);

                    // I get the command
                    $this->_getNextToken($str, $command);

                    if (($ext_arr = $this->_retrParsedResponse($str, $command, $msg_nro)) == false) {
                        //  if this bogus response cis a FLAGS () or EXPUNGE response
                        // the ignore it
                        if ($command != 'FLAGS' && $command != 'EXPUNGE') {
                            if ( ! is_null($this->_logger)) {
                                $this->_logger->warning('bogus response!');
                            }
                        }
                    }
                    $result_array[] = ['COMMAND' => $command, 'NRO' => $msg_nro, 'EXT' => $ext_arr];
                } else {
                    // OK the token is not a NUMBER so it MUST be a COMMAND
                    $command = $token;

                    /* Call the parser return the array
                        take care of bogus responses!
                    */

                    if (($ext_arr = $this->_retrParsedResponse($str, $command)) === false) {
                        if ( ! is_null($this->_logger)) {
                            $this->_logger->warning("bogus response! (COMMAND:$command)");
                        }
                    }
                    $result_array[] = ['COMMAND' => $command, 'EXT' => $ext_arr];
                }
            }
            $this->_getNextToken($str, $token);

            $token = strtoupper($token);
            if ($token != "\r\n" && $token != '') {
                if ( ! is_null($this->_logger)) {
                    $this->_logger->warning("PARSE ERROR! must be a '\\r\\n' here  but is a '$token'! (getting the next line)|STR:|$str|");
                }
            }
            $this->_getNextToken($str, $token);

            if ($token == "+") {
                //if the token  is + ignore the line
                // TODO: verify that this is correct!!!
                $this->_getToEOL($str);
                $this->_getNextToken($str, $token);
            }
        }//While
        // OK we finish the UNTAGGED Response now we must parse the FINAL TAGGED RESPONSE
        //TODO: make this a litle more elegant!

        $this->_parseSpace($str, __LINE__, __FILE__, false);
        $this->_getNextToken($str, $cmd_status);
        $str_line = rtrim(substr($this->_getToEOL($str), 1));

        $response['RESPONSE'] = ['CODE' => $cmd_status, 'STR_CODE' => $str_line, 'CMDID' => $cmdid];

        $ret = $response;
        if ( ! empty($result_array)) {
            $ret = array_merge($ret, ['PARSED' => $result_array]);
        }

        if (isset($status_arr)) {
            $status['STATUS'] = $status_arr;
            $ret = array_merge($ret, $status);
        }

        return $ret;
    }

    function utf_7_encode($str)
    {
        if ($this->_useUTF_7 == false) {
            return $str;
        }

        return mb_convert_encoding($str, 'UTF7-IMAP');
    }

    function utf_7_decode($str)
    {
        if ($this->_useUTF_7 == false) {
            return $str;
        }
        $internal = mb_internal_encoding();

        return mb_convert_encoding($str, $internal, 'UTF7-IMAP');
    }
}//Class

