<?php

/**
 * HTTP Cookies and its repository.
 *
 * @author  Yoshida, Hideyasu   2004/09
 * @version 1.0
 * @package fw.http
 */

require_once('fw/session_manager.csp');

/**
 * A formal specification of Cookies can be found in Netscape
 * cookie draft specific.
 *
 * Persistent client state HTTP Cookies
 * ( http://wp.netscape.com/newsref/std/cookie_spec.html )
 *
 * @package fw.http
 */
class CB_Cookie
{
    /**
     * @var string
     * @access private
     */
    var $_name = null;
    /**
     * @access private
     */
    var $_value = null;
    /**
     * @access private
     */
    var $_comment = null;
    /**
     * @access private
     */
    var $_domain = null;
    /**
     * @access private
     */
    var $_expires = null;
    /**
     * @access private
     */
    var $_path = null;
    /**
     * @access private
     */
    var $_secure = false;
    /**
     * @access private
     */
    var $_version = null;

    /**
     * Constructor.
     */
    function __construct()
    {
    }

    /**
     * Parses the Set-Cookie value.
     *
     * @param string $host   the host.
     * @param string $path   the path.
     * @param string $header the Set-Cookie received from the
     *                       server.
     */
    function parse($host, $path, $header)
    {
        $this->_domain = $host;
        $this->_path = $path;

        $cookies = explode(';', $header);
        foreach ($cookies as $cookie) {
            $tokens = explode('=', $cookie);
            if ( ! is_array($tokens) || count($tokens) < 2) {
                continue;
            }
            $key = trim($tokens[0]);
            $value = trim($tokens[1]);
            if ( ! is_null($value)
                 && preg_match('/^"?(.*)"?$/', $value, $regs)
            ) {
                $value = $regs[1];
            }

            if (is_null($this->_name)) {
                $this->_name = $key;
                $this->_value = $value;
                continue;
            }

            switch (strtolower($key)) {
                case 'comment':
                    $this->_comment = $value;
                    break;
                case 'domain':
                    $this->_domain = $value;
                    break;
                case 'expires':
                    $this->_expires = $this->_parseDate($value);
                    break;
                case 'max-age':
                    $value = intval($value);
                    if (0 != $value) {
                        $this->_expires = time() + $value;
                    }
                    break;
                case 'path':
                    $this->_path = $value;
                    break;
                case 'secure':
                    $this->_secure = true;
                    break;
                case 'version':
                    $this->_version = intval($value);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * Parses a date value.
     *
     * @access private
     *
     * @param string $value to parse.
     *
     * @return mixed null if $value could not be parsed using
     * the supported date format, int a timestamp otherwise.
     */
    function _parseDate($value)
    {
        if (preg_match('/([A-Za-z]+),? (\d+)-([A-Za-z]+)-(\d+) (\d+):(\d+):(\d+) GMT/',
            $value, $regs)
        ) {
            $day = intval($regs[2]);
            switch ($regs[3]) {
                case 'Jan':
                    $month = 1;
                    break;
                case 'Feb':
                    $month = 2;
                    break;
                case 'Mar':
                    $month = 3;
                    break;
                case 'Apr':
                    $month = 4;
                    break;
                case 'May':
                    $month = 5;
                    break;
                case 'Jun':
                    $month = 6;
                    break;
                case 'Jul':
                    $month = 7;
                    break;
                case 'Aug':
                    $month = 8;
                    break;
                case 'Sep':
                    $month = 9;
                    break;
                case 'Oct':
                    $month = 10;
                    break;
                case 'Nov':
                    $month = 11;
                    break;
                case 'Dec':
                    $month = 12;
                    break;
            }
            $year = intval($regs[4]);
            $hour = intval($regs[5]);
            $minute = intval($regs[6]);
            $second = intval($regs[7]);

            return gmmktime($hour, $minute, $second, $month, $day, $year);
        }

        return null;
    }

    /**
     * Performs a {@link CB_Cookie} validation.
     *
     * @param string $host the host.
     * @param string $path the path.
     *
     * @return bool FALSE if the cookie is invalid, FALSE otherwise.
     */
    function validate($host, $path)
    {
        if (false !== strpos($host, '.')) {
            if ($this->_domain != substr($host, -strlen($this->_domain))) {
                $domain = $this->_domain;
                if ('.' == $domain{0}) {
                    $domain = substr($domain, 1);
                }
                if ($domain != $host) {
                    return false;
                }
            }
        } else {
            if ($host != $this->_domain) {
                return false;
            }
        }

        if ($this->_path != substr($path, 0, strlen($this->_path))) {
            return false;
        }

        if (false !== strpos($host, '.')) {
            $domain = $this->_domain;
            if ('.' != $domain{0} && $host != $domain) {
                $domain = '.' . $domain;
            }

            $dots = substr_count($domain, '.');

            if ($this->_isSpecialDomain()) {
                if (2 > $dots) {
                    return false;
                }
            } else {
                if (3 > $dots) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * @access private
     */
    var $_special_domains
        = [
            '.com',
            '.edu',
            '.gov',
            '.mil',
            '.net',
            '.org',
            '.int'
        ];

    /**
     * Checks if the given domain is the special domain.
     *
     * @access private
     * @return bool TRUE if the specified domain is "special",
     * FALSE otherwise.
     */
    function _isSpecialDomain()
    {
        foreach ($this->_special_domains as $special_domain) {
            if ($special_domain == substr($this->_domain,
                    -strlen($special_domain))
            ) {
                return true;
            }
        }

        return false;
    }

    /**
     * Return TRUE if the cookie should be submitted with a request
     * with given attributes, FALSE otherwise.
     *
     * @param string $host   the host.
     * @param string $path   the path.
     * @param bool   $secure TRUE if the request is using a secure
     *                       connection.
     *
     * @return bool
     */
    function match($host, $path, $secure)
    {
        if ( ! $this->_domainMatch($host)) {
            return false;
        }
        if ( ! $this->_pathMatch($path)) {
            return false;
        }
        if ($this->_secure) {
            return $secure;
        }

        return true;
    }

    /**
     * Performs a domain-match.
     *
     * @access private
     *
     * @param string $host to check.
     *
     * @return bool TRUE if the specified host matches the domain,
     * FALSE otherwise.
     */
    function _domainMatch($host)
    {
        if ($this->_domain == $host) {
            return true;
        } elseif ('.' == $this->_domain{0}) {
            return $this->_domain == substr($host, -strlen($this->_domain));
        }

        return false;
    }

    /**
     * Performs a path-match.
     *
     * @access private
     *
     * @param string $path to check.
     *
     * @return bool TRUE if the paths match, FALSE otherwise.
     */
    function _pathMatch($path)
    {
        if ($this->_path == substr($path, 0, strlen($this->_path))) {
            return true;
        }

        return 1 == substr_count($this->_path, '/')
               && 1 == substr_count($path, '/');
    }

    /**
     * Returns FALSE if the cookie should be described at the end
     * of the session, TRUE otherwise.
     *
     * @return bool
     */
    function isPersistent()
    {
        return ! is_null($this->_expires);
    }

    /**
     * Returns TRUE if this cookie has expired.
     *
     * @return bool
     */
    function isExpired()
    {
        return ! is_null($this->_expires) && $this->_expires <= time();
    }

    /**
     * Return a textual representation of the cookie.
     *
     * @return string
     */
    function toString()
    {
        return $this->_name . '=' . $this->_value;
    }

    /**
     * Returns a hash code.
     *
     * @return string
     */
    function hashCode()
    {
        return md5($this->_domain . '+' . $this->_path . '+' . $this->_name);
    }
}

/**
 * Manages a {@link CB_Cookie}.
 *
 * @abstract
 * @package fw.http
 */
class CB_CookieManager
{
    /**
     * @var CB_Cookie[] $_cookies
     * @access private
     */
    var $_cookies = [];

    /**
     * Constructor.
     */
    function __construct()
    {
    }

    /**
     * Adds a {@link CB_Cookie}.
     *
     * @param CB_Cookie $cookie the parsed cookie from
     *                          the Set-Cookie header.
     */
    function addCookie($cookie)
    {
    }

    /**
     * Parses the Set-Cookie value.
     *
     * @param string $host   the host.
     * @param string $path   the path.
     * @param string $header the Set-Cookie received from the
     *                       server.
     *
     * @return bool TRUE if it can parses the Set-Cookie value, FALSE otherwise.
     */
    function parseCookie($host, $path, $header)
    {
        $cookie = new CB_Cookie();
        $cookie->parse($host, $path, $header);
        if ( ! $cookie->validate($host, $path)) {
            return false;
        }
        $this->addCookie($cookie);

        return true;
    }

    /**
     * Find cookies applicable to the given URI and build the
     * Cookie header from them.
     *
     * @param string $host   the host.
     * @param string $path   the path.
     * @param bool   $secure TRUE if the request is using a secure
     *                       connection.
     *
     * @return mixed       NULL if do not find cookies applicable to
     *                     given URI, otherwise string of the Cookie header.
     */
    function findCookies($host, $path, $secure)
    {
    }

    /**
     * Returns a string suitable for sending in a Cookie header
     *
     * @access private
     *
     * @param CB_Cookie[] $cookies array of {@link CB_Cookie} to be
     * formatted as string.
     *
     * @return string
     */
    function _makeCookieString(& $cookies)
    {
        if (0 < count($cookies)) {
            $cookie = array_shift($cookies);
            $str = $cookie->toString();
            foreach (array_keys($cookies) as $key) {
                $cookie = $cookies[$key];
                $str .= '; ' . $cookie->toString();
            }

            return $str;
        }

        return null;
    }

    /**
     * Save cookies.
     */
    function saveCookies()
    {
    }

    /**
     * Check if the lifetime of the cookie has expired, and delete.
     */
    function checkExpiredCookies()
    {
    }

}

/**
 * Cookie manager for command-line
 * (This is effective within 1 process.)
 *
 * @package fw.http
 */
class CB_CookieForSingleProcessManager extends CB_CookieManager
{
    /**
     * Constructor.
     */
    function __construct()
    {
        parent::__construct();
    }

    /**
     * Adds a {@link CB_Cookie}.
     *
     * @param CB_Cookie $cookie the parsed cookie from
     *                          the Set-Cookie header.
     */
    function addCookie($cookie)
    {
        $this->_cookies[$cookie->hashCode()] = $cookie;
    }

    /**
     * Find cookies applicable to the given URI and build the
     * Cookie header from them.
     *
     * @param string $host   the host.
     * @param string $path   the path.
     * @param bool   $secure TRUE if the request is using a secure
     *                       connection.
     *
     * @return mixed     NULL if do not find cookies applicable to
     *                   given URI, otherwise string of the Cookie header.
     */
    function findCookies($host, $path, $secure)
    {
        $this->checkExpiredCookies();

        $cookies = [];
        foreach (array_keys($this->_cookies) as $key) {
            $cookie = $this->_cookies[$key];
            if ($cookie->match($host, $path, $secure)) {
                $cookies[] = $cookie;
            }
        }

        return $this->_makeCookieString($cookies);
    }

    /**
     * Check if the lifetime of the cookie has expired, and delete.
     */
    function checkExpiredCookies()
    {
        $cookies =& $this->_cookies;
        foreach (array_keys($cookies) as $key) {
            $cookie = $cookies[$key];
            if ($cookie->isExpired()) {
                unset($cookies[$key]);
            }
        }
    }

    /**
     * Save cookies.
     */
    function saveCookies()
    {
    }
}

/**
 * Manages a cookie to a PHP session.
 *
 * @package fw.http
 */
class CB_CookiePHPSessionManager extends CB_CookieManager
{
    /**
     * Constructor.
     */
    function __construct()
    {
        parent::__construct();
    }

    /**
     * Adds a {@link CB_Cookie}.
     *
     * @param CB_Cookie $cookie the parsed cookie from
     *                          the Set-Cookie header.
     */
    function addCookie($cookie)
    {
        $this->_cookies[$cookie->hashCode()] = $cookie;
    }

    /**
     * Find cookies applicable to the given URI and build the
     * Cookie header from them.
     *
     * @param string $host   the host.
     * @param string $path   the path.
     * @param bool   $secure TRUE if the request is using a secure
     *                       connection.
     *
     * @return mixed     NULL if do not find cookies applicable to
     *                   given URI, otherwise string of the Cookie header.
     */
    function findCookies($host, $path, $secure)
    {
        if (0 == count($this->_cookies)) {
            $sm = CB_SessionManager::getInstance();
            $page = $sm->getSession('_fw_http');
            if (is_null($cookies = $page->get('cookie'))) {
                $this->_cookies = [];
            } else {
                $this->_cookies = cb_unserialize($cookies,
                    ['allowed_classes' => ['CB_Cookie']]);
            }
        }

        $this->checkExpiredCookies();

        $cookies = [];
        foreach (array_keys($this->_cookies) as $key) {
            $cookie = $this->_cookies[$key];
            if ($cookie->match($host, $path, $secure)) {
                $cookies[] = $cookie;
            }
        }

        return $this->_makeCookieString($cookies);
    }

    /**
     * Save cookies.
     */
    function saveCookies()
    {
        $this->checkExpiredCookies();

        $sm = CB_SessionManager::getInstance();
        $page = $sm->getSession('_fw_http');
        $page->set('cookie', serialize($this->_cookies));
    }

    /**
     * Check if the lifetime of the cookie has expired, and delete.
     */
    function checkExpiredCookies()
    {
        $cookies =& $this->_cookies;
        foreach (array_keys($cookies) as $key) {
            $cookie = $cookies[$key];
            if ($cookie->isExpired()) {
                unset($cookies[$key]);
            }
        }
    }
}


