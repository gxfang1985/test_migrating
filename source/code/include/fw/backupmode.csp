<?php

define('CB_BACKUPMODE_EVENT_PREFIX', 'backupmode_event');
define('CB_BACKUPMODE_SCHEDULE_PREFIX', 'backupmode_schedule');
define('CB_BACKUPMODE_TASK_FILE', 'backupmode_start.csp');

/**
 * Backupmode Framework.
 *
 * @package fw.core
 */
require_once('fw/persistent.csp');
require_once('fw/database.csp');

/**
 * Table definition
 */
class CB_BackupMode extends CB_PersistentBase
{
    function __construct($row)
    {
        parent::__construct($row);
    }

    var $col_start = ['type' => 'datetime'];
    var $col_end = ['type' => 'datetime'];
    var $col_message = ['type' => 'char'];
}

/**
 * Interface class for backupmode drivers.
 *
 * @abstract
 * @package fw.core
 */
class CB_BackupModeBaseDriver
{
    /**
     * When http request occurs and cb_get_backupmode() returns backupmode information not FALSE,
     * this method will be called with backupmode infomation as the parameter.
     * And after executing this method, die() will be called.
     *
     * @param array $info ['start'] CB_DateTime
     *                    $info['end'] CB_DateTime
     *                    $info['message'] string
     */
    function onHttpRequest($info)
    {
        ;
    }

    /**
     * When commandline request occurs and cb_get_backupmode() returns backupmode information not FALSE,
     * this method will be called with backupmode infomation as the parameter.
     * And after executing this method, die() will be called.
     *
     * @param array $info ['start'] CB_DateTime
     *                    $info['end'] CB_DateTime
     *                    $info['message'] string
     */
    function onCommandLineRequest($info)
    {
        ;
    }

    /**
     * Before cb_set_backupmode() called, this method will be called.
     */
    function beforeBackupModeStart()
    {
        ;
    }

    /**
     * After cb_set_backupmode() called, this method will be called.
     */
    function afterBackupModeStart()
    {
        ;
    }

    /**
     * Before cb_remove_backupmode() called, this method will be called.
     */
    function beforeBackupModeEnd()
    {
        ;
    }

    /**
     * After cb_remove_backupmode() called, this method will be called.
     */
    function afterBackupModeEnd()
    {
        ;
    }
}

/**
 * If in backupmode, returns backupmode information, else returns FALSE.
 *
 * @return mixed array $ret['start'] CB_DateTime or NULL
 *                     $ret['end'] CB_DateTime or NULL
 *                     $ret['message'] string or NULL
 *               or FALSE
 */
function cb_get_backupmode()
{
    require_once('fw/database.csp');
    require_once('fw/date.csp');

    global $G_config_common;
    if ($G_config_common->get('BackupMode', 'disable')) {
        return false;
    }

    global $G_container_base;
    $conn = $G_container_base->getInstance('dbconn');

    $query = "SELECT col_start,col_end,col_message FROM tab_cb_backupmode";
    $query = $conn->select_format($query, 0, -1, CB_DATABASE_NO_LOCK);
    $ret = $conn->query($query);
    if ($ret === false) {
        $conn->throwServerError($query);
    }

    $row = $conn->fetch_row($ret);
    if (is_array($row)) {
        $ret = [];

        if (is_null($row[0])) {
            $ret['start'] = null;
        } else {
            $datetime = new CB_DateTime();
            $datetime->parse($row[0]);
            $ret['start'] = $datetime;
        }
        if (is_null($row[1])) {
            $ret['end'] = null;
        } else {
            $datetime = new CB_DateTime();
            $datetime->parse($row[1]);
            $ret['end'] = $datetime;
        }
        $ret['message'] = $row[2];

        return $ret;
    } else {
        return false;
    }
}

/**
 * To enter backupmode, called.
 *
 * @param array $info ['start'] CB_DateTimeEx, if needed
 *                    $info['end'] CB_DateTimeEx, if needed
 *                    $info['message'] stringEx, if needed
 */
function cb_set_backupmode($info)
{
    require_once('fw/database.csp');
    require_once('fw/date.csp');

    $mnt = cb_get_backupmode_driver();

    $mnt->beforeBackupModeStart();

    global $G_container_base;
    $conn = $G_container_base->getInstance('dbconn');

    $query = "DELETE FROM tab_cb_backupmode;";
    $ret = $conn->query($query);
    if ($ret === false) {
        $conn->throwServerError($query);
    }

    $columns = '';
    $values = '';
    $delim = '';
    if (array_key_exists('start', $info)
        && is_a($info['start'], 'CB_DateTimeEx')
    ) {
        $datetimeex = $info['start'];
        $columns .= $delim . 'col_start';
        $values .= $delim . '\'' . $datetimeex->format() . '\'';
        $delim = ',';
    }
    if (array_key_exists('end', $info) && is_a($info['end'], 'CB_DateTimeEx')) {
        $datetimeex = $info['end'];
        $columns .= $delim . 'col_end';
        $values .= $delim . '\'' . $datetimeex->format() . '\'';
        $delim = ',';
    }
    if (array_key_exists('message', $info) && is_string($info['message'])) {
        $message = $info['message'];
        $columns .= $delim . 'col_message';
        $values .= $delim . '\'' . $conn->escape($message) . '\'';
        $delim = ',';
    }
    $query = "INSERT INTO tab_cb_backupmode (${columns}) VALUES (${values});";
    $ret = $conn->query($query);
    if ($ret === false) {
        $conn->throwServerError($query);
    }

    $mnt->afterBackupModeStart();
}

/**
 * To exit backupmode mode, called.
 */
function cb_remove_backupmode()
{
    require_once('fw/database.csp');
    require_once('fw/date.csp');

    $mnt = cb_get_backupmode_driver();

    $mnt->beforeBackupModeEnd();

    global $G_container_base;
    $conn = $G_container_base->getInstance('dbconn');

    $query = "DELETE FROM tab_cb_backupmode;";
    $ret = $conn->query($query);
    if ($ret === false) {
        $conn->throwServerError($query);
    }

    $mnt->afterBackupModeEnd();
}

function cb_register_backupmode_schedule(
    $name,
    $command,
    $period,
    $message = null
) {
    require_once('fw/schedule.csp');

    if ( ! is_numeric($period)) {
        return false;
    }

    $ss = CB_SchedulingService::getInstance();
    $taskname = CB_BACKUPMODE_SCHEDULE_PREFIX . ":$name";
    $arguments = "--period='$period'";
    if (is_string($message)) {
        $arguments .= " --message='$message'";
    }

    return $ss->registerRepeatEvent($taskname,
        CB_BACKUPMODE_TASK_FILE,
        $command,
        $arguments,
        CB_BACKUPMODE_SCHEDULE_PREFIX);
}

function cb_register_backupmode_event($name, $start, $period, $message = null)
{
    require_once('fw/schedule.csp');
    require_once('fw/date.csp');

    if ( ! is_numeric($period)) {
        return false;
    }
    if ( ! is_a($start, 'CB_DateTimeEx')) {
        return false;
    }
    $ts_start = new CB_TimestampEx();
    $ts_start->setDateTime($start);

    $ss = CB_SchedulingService::getInstance();
    $taskname = CB_BACKUPMODE_EVENT_PREFIX . ":$name";
    $arguments = "--period='$period'";
    if (is_string($message)) {
        $arguments .= " --message='$message'";
    }

    return $ss->registerOnceEvent($taskname,
        CB_BACKUPMODE_TASK_FILE,
        $ts_start,
        $arguments,
        CB_BACKUPMODE_EVENT_PREFIX);
}

function cb_backupmode_schedule_list()
{
    require_once('fw/schedule.csp');

    $ss = CB_SchedulingService::getInstance();
    $list = $ss->listEvents(CB_BACKUPMODE_SCHEDULE_PREFIX);
    $keys = array_keys($list);
    $ret = [];
    foreach ($keys as $key) {
        $col = $list[$key];
        $info = [];
        $info['command'] = $col->get('command');
        $arg = $col->get('arguments');
        if (preg_match("#--period='([0-9]*)'#", $arg, $regs)) {
            $info['period'] = $regs[1];
        }
        $key = preg_replace('/^' . CB_BACKUPMODE_SCHEDULE_PREFIX . ':/',
            '', $key);
        $ret[$key] = $info;
    }

    return $ret;
}

function cb_backupmode_event_list()
{
    require_once('fw/schedule.csp');
    require_once('fw/date.csp');

    $ss = CB_SchedulingService::getInstance();
    $list = $ss->listEvents(CB_BACKUPMODE_EVENT_PREFIX);
    $keys = array_keys($list);
    $ret = [];
    foreach ($keys as $key) {
        $col = $list[$key];
        $info = [];
        $start = $col->get('execution');
        $ts_start = new CB_TimestampEx($start);
        $info['start'] = $ts_start->getDateTime();
        $arg = $col->get('arguments');
        if (preg_match("#--period='([0-9]*)'#", $arg, $regs)) {
            $info['period'] = $regs[1];
        }
        $key = preg_replace('/^' . CB_BACKUPMODE_EVENT_PREFIX . ':/', '',
            $key);
        $ret[$key] = $info;
    }

    return $ret;
}

function cb_unregister_backupmode_schedule($name)
{
    require_once('fw/schedule.csp');
    $ss = CB_SchedulingService::getInstance();

    return $ss->unregisterEvent(CB_BACKUPMODE_SCHEDULE_PREFIX . ":$name",
        CB_BACKUPMODE_SCHEDULE_PREFIX);
}

function cb_unregister_backupmode_event($name)
{
    require_once('fw/schedule.csp');
    $ss = CB_SchedulingService::getInstance();

    return $ss->unregisterEvent(CB_BACKUPMODE_EVENT_PREFIX . ":$name",
        CB_BACKUPMODE_EVENT_PREFIX);
}


