<?php

/**
 * エラーページを表示して終了する. 無引数で呼び出すと Internal Error.
 * NEVER RETURN.
 *
 * @param string $code      The error code.
 * @param array  $diagnosis Parameters for diagnosis message.
 * @param array  $cause     Parameters for cause message.
 * @param array  $counter   Parameters for counter-measure message.
 * @param array  $developer Parameters for developer information.
 */
function cb_throw_error(
    $code = 'FW00001',
    $diagnosis = null,
    $cause = null,
    $counter = null,
    $developer = null,
    $alternative_resources = null
) {
    require_once('fw/error_handler.csp');
    $bt = debug_backtrace(false);
    $handler = CB_ErrorHandler::getInstance();
    $handler->errorExit($code, $diagnosis, $cause, $counter, $developer, $bt,
        $alternative_resources);
}

/**
 * @param int    $http_status_code
 * @param string $http_request_url
 * @param string $curl_error_code
 * @param string $curl_error_message
 */
function cb_http_error_to_log_file(
    $http_status_code = null,
    $http_request_url = null,
    $curl_error_code = null,
    $curl_error_message = null
) {
    require_once('fw/error_handler.csp');
    $backtrace = debug_backtrace(false);
    $handler = CB_ErrorHandler::getInstance();

    $error_format
        = "status_code(%s), url(%s), error_code(%s), error_message(%s)";
    $output_error = sprintf($error_format, $http_status_code, $http_request_url,
        $curl_error_code, $curl_error_message);

    $method_caller_info = current($backtrace);
    $file = cb_at($method_caller_info, "file", "");
    $line = cb_at($method_caller_info, "line", "");

    $handler->logPhpError("http_error", $output_error, $file, $line,
        $backtrace);
}

/**
 * Graceful exit function.  This function suppresses any output to
 * avoid appending garbage data after downloading contents, but
 * commits databases and/or filemanagers.
 *
 * Typically one should call this after CB_ServerFile::download()
 * or after exporting some data in CSV format.
 *
 * @param int $status
 * The exit status, or <var>null</var> to do nothing before exit.
 */
function cb_safe_exit($status = null)
{
    ob_start();
    require(cb_basedir() . '/code/include/append.csp');
    ob_end_clean();

    if (is_null($status)) {
        exit();
    } else {
        exit($status);
    }
}

/**
 * Switch to display named page instead of current one, then exit.
 * The page name must be followed by ".csp" .
 *
 * @param string $__page__ The script name deployed in doc_root, with
 *                         filename extension.
 * @param int    $__status__
 *                         The exit status, or <var>null</var> to do nothing before exit.
 *
 * @return             NEVER return from this function.
 */
function cb_switch_page($__page__, $__status__ = null)
{
    // discard half outputs
    while (ob_get_level() > 0) {
        ob_end_clean();
    }
    ob_start();

    // change current page name
    cb_set_pagename(substr($__page__, 0, -4));

    // display switched page
    $__prepend__ = cb_basedir() . '/code/doc_root/' . dirname($__page__)
                   . '/_prepend.csp';
    $__append__ = cb_basedir() . '/code/doc_root/' . dirname($__page__)
                  . '/_append.csp';

    if (file_exists($__prepend__)) {
        include($__prepend__);
    }

    require(cb_basedir() . '/code/doc_root/' . $__page__);

    if (file_exists($__append__)) {
        include($__append__);
    }
    require(cb_basedir() . '/code/include/append.csp');

    // do call exit instead of cb_safe_exit since we've done
    // postprocess by including 'append.csp'.
    if (is_null($__status__)) {
        exit();
    } else {
        exit($__status__);
    }
}

/**
 * Issue 'Location' HTTP header to redirect, then safely exit the
 * script execution.  This function will call {@link cb_safe_exit}
 * after the header is issued.
 * <br>
 * NEVER RETURN.
 *
 * @param string $url A Fully Qualified URL such as 'http://hoge.com/scripts/php.exe/foo'.
 */
function cb_redirect_to_url($url, $strip_fragment = true)
{
    if ($strip_fragment) {
        $pos = strrpos($url, '#');
        if ($pos !== false) {
            $url = substr($url, 0, $pos);
        }
    }

    global $G_state_set;
    $G_state_set->set('redirect_to', $url);
    cb_safe_exit();
}


/**
 * Issue 'Location' HTTP header to redirect, then safely exit the
 * script execution.  This function will call {@link cb_safe_exit}
 * after the header is issued.
 * <br>
 * NEVER RETURN.
 *
 * @param string $page
 *                               The destination page.
 * @param array  $args
 *                               An associative array of GET parameters, or <var>null</var>.<br>
 *                               e.g.) array('uid'=>20, 'view'=>'foo')
 * @param string $fragment
 *                               Optional fragment of the URL.  If not NULL, the returned URL will
 *                               be followed by '#' . urlencode($fragment)
 * @param string $postfix        Optional postfix string after $page.
 * @param bool   $ignore_referer Ingore REFERER request header.
 */
function cb_redirect(
    $page,
    $args = null,
    $fragment = null,
    $postfix = null,
    $ignore_referer = false
) {
    if ( ! is_null($fragment)) {
        $dummy = '__dummy';
        if (is_null($args)) {
            $args = [$dummy => 1];
        } else {
            while (true) {
                if ( ! array_key_exists($dummy, $args)) {
                    $args[$dummy] = 1;
                    break;
                }
                $dummy = '_' . $dummy;
            }
        }
    }

    cb_redirect_to_url(cb_get_full_url($page, $args, $fragment, $postfix,
        $ignore_referer), false);
}

/**
 * @return array
 * @see CB_ErrorHandler::handlerForPhpError
 */
function cb_get_fatal_errors()
{
    require_once('fw/error_code.csp');

    return [
        // Error code on PHP => Error code on Garoon
        E_ERROR         => E_PHP_ERROR,
        E_PARSE         => E_PHP_PARSE,
        E_CORE_ERROR    => E_PHP_CORE_ERROR,
        E_COMPILE_ERROR => E_PHP_COMPILE_ERROR
    ];
}

/* error.iniの情報を取得し、それを返す
 * @return array|bool error.iniから取得した情報
 *                    error.iniが存在しない、force_stopの項目が1の場合、FALSEを返す
 */
function cb_detect_error_ini_info()
{
    // guard when $G_error_config is boolean
    // In this case, Garoon can't find error.ini file
    global $G_error_config;
    if ($G_error_config === false) {
        return false;
    }

    // gaurd when force_stop in [settings] = 1, stop put out log
    if ($G_error_config->get('settings', 'force_stop') === '1') {
        return false;
    }

    //if php has not domain id, directory name is undefined-domain
    $domain = CB_CyDECUtil::getInstance()->getDomainID();

    return [
        "domain" => $domain,
        "time"   => isset($_SERVER['REQUEST_TIME']) ? $_SERVER['REQUEST_TIME']
            : time()
    ];

}

/*
 * 指定されたディレクトリに指定されたファイル名で$messageを書き出す
 */
function cb_write_error_log($file, $message)
{
    $logger
        = \grn\grn\TextLogger::createInstanceForceUseLogFileName("php_error",
        $file);
    $logger->shouldNotCleanUp();
    $logger->log($message);
}
