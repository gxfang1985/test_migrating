<?php
declare(strict_types=1);

namespace grn\fw;

class EncodedWord
{
    /** @var string */
    private $charset;

    /** @var string */
    private $encoding;

    /** @var string */
    private $text;

    /** @var string */
    private $decoded_text;

    /**
     * EncodedWord constructor.
     * See. http://www.faqs.org/rfcs/rfc2047.html
     *
     * @param string $charset
     * @param string $text
     * @param string $encoding
     */
    public function __construct(string $charset, string $encoding, string $text)
    {
        $this->charset = strtolower($charset);
        $this->encoding = strtolower($encoding);
        $this->text = $text;
        $this->decoded_text = $this->decodeWord();
    }

    /**
     * @return string
     */
    private function decodeWord()
    {
        if ($this->encoding === 'q') {
            return mb_convert_encoding($this->text, '8bit', 'quoted-printable');
        }
        if ($this->encoding === 'b') {
            return base64_decode($this->text);
        }

        return '';
    }

    /**
     * @param string $encoding_order
     * @param string $force_encoding
     *
     * @return string
     */
    public function encodeToInternalEncoding(
        /* string */
        $encoding_order,
        /* string */
        $force_encoding
    ) {
        $charset = $this->charset;
        if ( ! is_null($force_encoding)) {
            $charset = ($force_encoding == 'auto')
                ? mb_detect_encoding($this->decoded_text, $encoding_order)
                : $force_encoding;
        }

        $internal = mb_internal_encoding();

        return cb_encode($this->decoded_text, $internal, $charset);
    }

    /**
     * @param EncodedWord $target
     *
     * @return bool
     */
    public function isSameEncode(EncodedWord $target): bool
    {
        return $this->encoding === $target->getEncoding() && $this->charset === $target->getCharset();
    }

    /**
     * @return string
     */
    public function getEncoding(): string
    {
        return $this->encoding;
    }

    /**
     * @return string
     */
    public function getCharset(): string
    {
        return $this->charset;
    }

    /**
     * @param EncodedWord $decoded_word
     */
    public function merge(EncodedWord $decoded_word): void
    {
        $text = $this->getText();
        $merge_text = $decoded_word->getText();
        // RFC 4648 http://tools.ietf.org/html/rfc4648.html
        if (0 < strlen($text) && substr($text, -1) !== '='
            && 0 < strlen($merge_text)
            && substr($merge_text, -1) !== '='
        ) {
            $this->text = $text . $merge_text;
            $this->decoded_text = $this->decodeWord();
        } else {
            $this->decoded_text .= $decoded_word->getDecodedText();
            $this->text = '';
        }
    }

    /**
     * @return string
     */
    public function getDecodedText(): string
    {
        return $this->decoded_text;
    }

    /**
     * @return string
     */
    public function getText(): string
    {
        return $this->text;
    }
}
