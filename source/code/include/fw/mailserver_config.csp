<?php

class CB_MailServerConfig
{
    private static $_instance;
    private $_config;

    private function __construct()
    {
        global $G_config_grn;
        $this->_config = $G_config_grn;
    }

    /**
     * @return CB_MailServerConfig
     */
    public static function getInstance()
    {
        if (is_null(self::$_instance)) {
            self::$_instance = new static();
        }

        return self::$_instance;
    }

    /**
     * @return bool
     */
    public function isEnableBuiltin()
    {
        if ($this->_config->get('Mail', 'enable_builtin')) {
            return true;
        }

        return false;
    }

    /**
     * @return string  return FALSE if not written
     */
    public function getBuiltinHost()
    {
        return $this->_config->get('Mail', 'builtin_host');
    }

    /**
     * @return string  return FALSE if not written
     */
    protected function getBlackListAddress()
    {
        return $this->_config->get('Mail', 'blacklist_address');
    }

    /**
     * @param string $subnet
     * @param string $ip
     *
     * @return bool
     */
    private function ipIsWithinSubnet($subnet, $ip)
    {
        list ($net, $mask) = explode('/', $subnet);

        return (ip2long($ip) & ~((1 << (32 - $mask)) - 1)) == ip2long($net);
    }

    /**
     * @param string $host
     *
     * @return bool
     */
    public function isValidHost($host)
    {
        $host = cb_trim($host);
        if (strlen($host) === 0) {
            return false;
        }

        $subnet_list_string = $this->getBlackListAddress();

        if ($subnet_list_string === false
            || strlen($subnet_list_string) === 0
        ) {
            return true;
        }

        if (strpos($host, ':') !== false) {
            // IPv6 address or invalid address
            // Black list doesn't support IPv6.
            return false;
        }

        $addrs = gethostbynamel($host);
        if ($addrs === false) {
            return false;
        }

        $subnets = explode(',', $subnet_list_string);
        foreach ($subnets as $subnet) {
            foreach ($addrs as $addr) {
                if ($this->ipIsWithinSubnet($subnet, $addr)) {
                    return false;
                }
            }
        }

        return true;
    }
}
