<?php

/**
 * The object-relational mapper.
 *
 * @package fw.persistent
 */

// NOTE: Persistent classes (classes that inherit CB_PersistentBase)
//       may have transient properties by giving them names that
//       start with neither 'col_' nor 'idx_'.
// NOTE: Transient properties should be initialized with some value.
//       That gives better performance for this O-R mapping
//       implementation.
// Example:
// class CB_Foo extends CB_PersistentBase
// {
//     var $col_name = array( 'type' => 'char' );
//     var $_temporary_name = '';    // initialize!
// }

/**
 * This is an extension on top of the persistent layer.
 */
require_once('fw/database.csp');

/**
 * A character (or string) that separates suffixes from class names
 * in the names of tables generated by cb_class2table function.
 */
define('CB_PERSISTENT_NAMESEPARATOR', '___');

/**
 * Implements a mapping between PHP classes <-> RDB tables.
 * All persistent classes should inherit this base class.
 *
 * @author  Yamamoto, Hirotaka  2003/06
 * @version 1.0
 * @package fw.persistent
 * @abstract
 */
class CB_PersistentBase
{
    /**
     * @access private
     * @var CB_Row
     */
    var $__row = null;
    /**
     * @access private
     */
    var $__transient_vars = [];

    /**
     * Constructor for persistent instances.  Let <var>$row</var> be
     * <var>null</var> to create transient instances.  You will need
     * to assign <var>null</var> into a temporary variable since PHP
     * does not allow literals to be referenced by '&'.
     *
     * @param CB_Row $row
     *  A {@link CB_Row} instance of a database table.
     */
    function __construct($row)
    {
        $this->__row = $row;
    }

    function isTransient()
    {
        return is_null($this->__row);
    }

    /* mappings to CB_Row API */
    function getOID($force = true)
    {
        if (is_null($this->__row)) {
            return false;
        } else {
            return $this->__row->getOID($force);
        }
    }

    /**
     * @access protected
     */
    function getTempId()
    {
        if (is_null($this->__row)) {
            return null;
        }

        return $this->__row->getTempId();
    }

    /**
     * @return CB_TableInfo
     */
    function getTableInfo()
    {
        $info = null;
        if (is_null($this->__row)) {
            return $info;
        }

        $info = $this->__row->getTableInfo();

        return $info;
    }

    function registerNow()
    {
        if (is_null($this->__row)) {
            return false;
        }

        return $this->__row->registerNow();
    }

    function updateNow()
    {
        if (is_null($this->__row)) {
            return false;
        }

        return $this->__row->updateNow();
    }

    function delete()
    {
        if (is_null($this->__row)) {
            return false;
        }

        return $this->__row->delete();
    }

    function set($prop_name, $prop_value)
    {
        if (is_null($this->__row)) {
            $this->__transient_vars[$prop_name] = $prop_value;

            return true;
        }

        return $this->__row->set($prop_name, $prop_value);
    }

    /**
     * @param string $prop_name
     *
     * @return CB_Row|mixed
     */
    function get($prop_name)
    {
        $value = false;
        if (is_null($this->__row)) {
            if (array_key_exists($prop_name, $this->__transient_vars)) {
                return $this->__transient_vars[$prop_name];
            } else {
                return $value;
            }
        }

        $value = $this->__row->get($prop_name);;

        return $value;
    }

    function getId($prop_name)
    {
        $id = false;
        if (is_null($this->__row)) {
            if (array_key_exists($prop_name, $this->__transient_vars)) {
                return $this->__transient_vars[$prop_name];
            } else {
                return $id;
            }
        }

        $id = $this->__row->getId($prop_name);

        return $id;
    }

    function lock()
    {
        $this->__row->lock();
    }
}


/**
 * Base class for all persistent read-only classes.
 * Classes that inherit this class never allow property modification.
 *
 * @package fw.persistent
 * @abstract
 */
class CB_ReadOnlyBase extends CB_PersistentBase
{
    function __construct($row)
    {
        parent::__construct($row);
    }

    /**
     * protected API to set properties.  Application writers MUST NOT
     * access this method.
     *
     * @access protected
     */
    function _setPrivately($prop_name, $prop_value)
    {
        if (is_null($this->__row)) {
            $this->__transient_vars[$prop_name] = $prop_value;

            return;
        }

        return $this->__row->_set($prop_name, $prop_value);
    }

    /**
     * protected API to delete object.  Application writers MUST NOT
     * access this method.
     *
     * @access protected
     */
    function _deletePrivately()
    {
        if (is_null($this->__row)) {
            return false;
        }

        return $this->__row->_delete();
    }
}

/**
 * Generate table type information from persistent classes.
 * This function will return a {@link CB_TableInfo} instance
 * that represents a table whose name is
 * "${class_name} . CB_PERSISTENT_NAMESEPARATOR . ${suffix}"
 * if $suffix is not null string.  When not, the table name is
 * simply "${class_name}".
 *
 * Since CB_PERSISTENT_NAMESEPARATOR is currently '$', letting
 * $class_name and $suffix be 'foo' and '0', the table name becomes
 * 'foo$0'.
 *
 * @param CB_TableManager|GRN_TableManager $table_manager
 * @param string                           $class_name
 *  The name of a persistent class that defines type of the table.
 * @param string                           $suffix
 *  Optional suffix string of the table name.
 *
 * @return CB_TableInfo An instance of {@link CB_TableInfo}.
 */
function cb_class2table_generic($table_manager, $class_name, $suffix = '')
{
    static $_parsed = [];

    $table_name = $class_name;
    if (strlen($suffix) > 0) {
        $table_name .= CB_PERSISTENT_NAMESEPARATOR . $suffix;
    }

    $table_info = $table_manager->createTableInfo($table_name);

    if (array_key_exists($table_name, $_parsed)) {
        $info = $_parsed[$table_name];
    } else {
        global $G_container_base;
        $parser = $G_container_base->getInstance('class2table_parser');
        $info = $parser->parse($class_name, $suffix);
        $_parsed[$table_name] = $info;
    }

    $table_info->_setClassName($class_name);
    if ($info['_readonly']) {
        $table_info->_setReadOnly();
    }
    $table_info->_setColumnInfo($info['_column_info']);
    $table_info->_setIndexInfo($info['_idx_info']);

    return $table_info;
}

/**
 * A specific version of cb_class2table_generic().
 * This will pass the table manager for user-level transaction
 * to cb_class2table_generic()'s first parameter.
 *
 * @param string $class_name
 *  The name of a persistent class that defines type of the table.
 * @param string $suffix
 *  Optional suffix string of the table name.
 *
 * @return CB_TableInfo
 */
function cb_class2table($class_name, $suffix = '')
{
    static $_table_list = [];

    if (array_key_exists($class_name, $_table_list)
        && array_key_exists($suffix, $_table_list[$class_name])
    ) {
        return $_table_list[$class_name][$suffix];
    }

    global $G_container_base;
    $parser = $G_container_base->getInstance('class2table_parser');
    $info = $parser->parse($class_name, $suffix);
    $tm = null;
    if (array_key_exists('_app_id', $info) && ! is_null($info['_app_id'])) {
        $app_id = $info['_app_id'];
        require_once('grn/application.csp');
        $locator = GRN_ApplicationLocator::instance();
        $tm = $locator->getTableManager($app_id);
    } else {
        global $G_container_base;
        $tm = $G_container_base->getInstance('table_manager');
    }

    $table_info = cb_class2table_generic($tm,
        $class_name, $suffix);
    $_table_list[$class_name][$suffix] = $table_info;

    return $table_info;
}

/**
 * This class is parser for class2table.
 *
 * @package fw.persistent
 */
class CB_Class2TableParser
{
    /**
     * @access private
     */
    var $_parsed = [];

    /**
     * execute parse
     *
     * @param string $class_name
     * @param string $suffix
     *
     * @return array
     */
    function parse($class_name, $suffix = '')
    {
        $class_name = strtolower($class_name);
        $suffix = strtolower($suffix);

        if (array_key_exists($class_name, $this->_parsed)) {
            return $this->_parsed[$class_name];
        }

        if ( ! array_key_exists($class_name, $this->_parsed)) {
            $class_info = [];
            $class_info['_class_name'] = $class_name;
            $class_info['_column_info'] = [];
            $class_info['_idx_info'] = [];
            $class_info['_app_id'] = null;

            $vars = get_class_vars($class_name);
            if (is_array($vars)) {
                foreach ($vars as $val_name => $info) {
                    // parse column definitions
                    if (strncmp($val_name, 'col_', 4) === 0) {
                        $col_name = substr($val_name, 4);
                        if (strlen($col_name) === 0) {
                            continue;
                        }

                        $class_info['_column_info'][$col_name] = $info;
                    }

                    // parse index definitions
                    if (strncmp($val_name, 'idx_', 4) === 0) {
                        $idx_name = substr($val_name, 4);
                        if (strlen($idx_name) === 0) {
                            continue;
                        }

                        $class_info['_idx_info'][$idx_name] = $info;
                    }

                    if (strncmp($val_name, '_app_id', 7) === 0) {
                        $class_info['_app_id'] = $info;
                    }
                }
            }


            // set read-only flag
            $class_info['_readonly'] = false;
            while (($class_name = get_parent_class($class_name))) {
                if (strcasecmp('CB_ReadOnlyBase', $class_name) === 0) {
                    $class_info['_readonly'] = true;
                }
            }
        }
        $this->_parsed[$class_name] = $class_info;

        return $class_info;
    }
}


