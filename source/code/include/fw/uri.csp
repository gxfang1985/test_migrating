<?php

/**
 * Uniform Resource Identifier (URI).
 *
 * @author  Yoshida, Hideyasu   2004/09
 * @version 1.0
 * @package fw.http
 */

/**
 * Represents a Uniform Resource Identifier (URI) reference.
 *
 * @package fw.http
 */
class CB_URI
{
    /**
     * @access private
     */
    var $_scheme = null;
    /**
     * @access private
     */
    var $_specific = null;
    /**
     * @access private
     */
    var $_authority = null;
    /**
     * @access private
     */
    var $_path = null;
    /**
     * @access private
     */
    var $_query = null;
    /**
     * @access private
     */
    var $_fragment = null;
    /**
     * @access private
     */
    var $_user_info = null;
    /**
     * @access private
     */
    var $_host = null;
    /**
     * @access private
     */
    var $_port = -1;
    /**
     * @access private
     */
    var $_is_opaque = false;

    /**
     * @access private
     */
    function _initialize()
    {
        $this->_scheme = null;
        $this->_specific = null;
        $this->_authority = null;
        $this->_path = null;
        $this->_query = null;
        $this->_fragment = null;

        $this->_user_info = null;
        $this->_host = null;
        $this->_port = -1;

        $this->_is_opaque = false;
    }

    /**
     * @access private
     *
     * @param string $authority The authority component of URI.
     */
    function _parseAuthority($authority)
    {
        $user_info =& $this->_user_info;
        $host =& $this->_host;
        $port =& $this->_port;

        if (is_null($authority) || 0 == strlen($authority)) {
            return;
        }

        $idx = strpos($authority, '@');
        if (false === $idx) {
            $host = $authority;
        } else {
            $user_info = substr($authority, 0, $idx);
            $host = substr($authority, $idx + 1);
        }

        $result = $this->_parseIPV6($host);
        if (false === $result) {
            $idx = strpos($host, ':');
            if (false !== $idx) {
                $port = intval(substr($host, $idx + 1));
                $host = substr($host, 0, $idx);
            }
        } else {
            $host = $result['host'];
            if (isset($result['port'])) {
                $port = intval($result['port']);
            }
        }
    }

    /**
     * @access private
     *
     * @param string $uri The string to be parsed into a URI.
     */
    function _parse($uri)
    {
        $scheme =& $this->_scheme;
        $specific =& $this->_specific;
        $authority =& $this->_authority;
        $path =& $this->_path;
        $query =& $this->_query;
        $fragment =& $this->_fragment;

        $is_opaque =& $this->_is_opaque;

        $idx = strpos($uri, ':');
        if (false === $idx) {
            $is_opaque = false;

            $idx = strrpos($uri, '#');
            if (false === $idx) {
                $specific = $uri;
            } else {
                $specific = substr($uri, 0, $idx);
                $fragment = substr($uri, $idx + 1);
            }

            $idx = strrpos($specific, '?');
            if (false === $idx) {
                $path = $specific;
            } else {
                $path = substr($specific, 0, $idx);
                $query = substr($specific, $idx + 1);
            }

            return;
        }

        $scheme = substr($uri, 0, $idx);
        $specific = substr($uri, $idx + 1);

        $idx = strrpos($specific, '#');
        if (false !== $idx) {
            $fragment = substr($specific, $idx + 1);
            $specific = substr($specific, 0, $idx);
        }

        if (2 < strlen($specific) && 0 == strpos($specific, '//')) {
            $is_opaque = false;
            $authority = substr($specific, 2);
        } else {
            $is_opaque = true;

            return;
        }

        $idx = strpos($authority, '/');
        if (false === $idx) {
            $this->_parseAuthority($authority);

            return;
        }

        $path = substr($authority, $idx);
        $authority = substr($authority, 0, $idx);
        $this->_parseAuthority($authority);

        $idx = strpos($path, '?');
        if (false !== $idx) {
            $query = substr($path, $idx + 1);
            $path = substr($path, 0, $idx);
        }
    }

    function _parseIPV6($host)
    {
        if (1 == preg_match('/^\[([0-9a-fA-F:]{2,39})\](\:([0-9]+))?/', $host,
                $matches)
        ) {
            $retVal = ['host' => '[' . $matches[1] . ']'];
            if (isset($matches[3])) {
                $retVal['port'] = $matches[3];
            }

            return $retVal;
        }

        return false;
    }

    /**
     * Creates a {@link CB_URI} object by parsing the given string.
     *
     * @param string $uri The string to be parsed into a URI.
     *
     * @return object CB_URI The new URI.
     */
    public static function static_createInstance($uri)
    {
        $obj = new CB_URI($uri);

        return $obj;
    }

    /**
     * Constructor.
     */
    function __construct()
    {
        $args = func_get_args();
        $args_num = func_num_args();

        $str = '';
        if (0 == $args_num) {
            return;
        } elseif (1 == $args_num) {
            $str = $args[0];
        } elseif (3 == $args_num) {
            if ( ! is_null($args[0])) {
                $str .= $args[0] . ':';
            }
            if ( ! is_null($args[1])) {
                $str .= $args[1];
            }
            if ( ! is_null($args[2])) {
                $str .= '#' . $args[2];
            }
        } elseif (5 == $args_num) {
            if ( ! is_null($args[0])) {
                $str .= $args[0] . ':';
            }
            if ( ! is_null($args[1])) {
                $str .= '//' . $args[1];
            }
            if ( ! is_null($args[2])) {
                $str .= $args[2];
            }
            if ( ! is_null($args[3])) {
                $str .= '?' . $args[3];
            }
            if ( ! is_null($args[4])) {
                $str .= '#' . $args[4];
            }
        }

        $this->_initialize();
        $this->_parse($str);
    }

    /**
     * Returns the content of this URI as a string.
     *
     * @param bool $is_fragment TRUE if without a fragment.
     *
     * @return string The string form of this URI.
     */
    function toString($is_fragment = true)
    {
        $scheme =& $this->_scheme;
        $specific =& $this->_specific;
        $authority =& $this->_authority;
        $path =& $this->_path;
        $query =& $this->_query;
        $fragment =& $this->_fragment;

        $str = '';
        if ( ! is_null($scheme)) {
            $str = $scheme . ':';
        }
        if ($this->isOpaque()) {
            if ( ! is_null($specific)) {
                $str .= $specific;
            }
            if ( ! is_null($fragment)) {
                $str .= '#' . $fragment;
            }

            return $str;
        }
        if ( ! is_null($authority)) {
            $str .= '//' . $authority;

            if (0 < strpos($path, '/')) {
                $str .= '/';
            }
        }
        if ( ! is_null($path)) {
            $str .= $path;
        }
        if ( ! is_null($query)) {
            $str .= '?' . $query;
        }
        if ( ! is_null($fragment) && $is_fragment) {
            $str .= '#' . $fragment;
        }

        return $str;
    }

    /**
     * Returns the scheme component of this URI.
     *
     * @return string The scheme component of this URI,
     *                or null if the scheme is undefined.
     */
    function getScheme()
    {
        return $this->_scheme;
    }

    /**
     * Returns the decoded scheme-specific part of this URI.
     *
     * @return string The decoded scheme-specific part of this URI.
     */
    function getSchemeSpecificPart()
    {
        return $this->_specific;
    }

    /**
     * Returns the decoded authority component of this URI.
     *
     * @return string The decoded authority component of this URI,
     *                or null if the authority is undefined.
     */
    function getAuthority()
    {
        return $this->_authority;
    }

    /**
     * Returns the decoded path component of this URI.
     *
     * @return string The decoded path component of this URI,
     *                or null if the path is undefined.
     */
    function getPath()
    {
        return $this->_path;
    }

    /**
     * Returns the decoded query component of this URI.
     *
     * @return string The decoded query component of this URI,
     *                or null if the query is undefined.
     */
    function getQuery()
    {
        return $this->_query;
    }

    /**
     * Returns the decoded fragment component of this URI.
     *
     * @return string The decoded fragment component of this URI,
     *                or null if the fragment is undefined.
     */
    function getFragment()
    {
        return $this->_fragment;
    }

    /**
     * Returns the decoded user-information component of this URI.
     *
     * @return string The decoded user-information component of this URI,
     *                or null if the user information is undefined.
     */
    function getUserInfo()
    {
        return $this->_user_info;
    }

    /**
     * Returns the host component of this URI.
     *
     * @return string The host component of this URI,
     *                or null if the host is undefined.
     */
    function getHost()
    {
        return $this->_host;
    }

    /**
     * Returns the port number of this URI.
     *
     * @return int The port component of this URI,
     *             or -1 if the port is undefined.
     */
    function getPort()
    {
        return $this->_port;
    }

    /**
     * Tells whether or not this URI is absolute.
     *
     * @return bool TRUE if, and only if, this URI is absolute.
     */
    function isAbsolute()
    {
        return ( ! is_null($this->_scheme));
    }

    /**
     * Tells whether or not this URI is opaque.
     *
     * @return bool TRUE if, and only if, this URI is opaque.
     */
    function isOpaque()
    {
        return $this->_is_opaque;
    }

    /**
     * @access private
     *
     * @param string $path       The path.
     * @param bool   $is_get_dir The flag for removing a current directory.
     */
    function _normalize($path, $is_get_dir)
    {
        if (is_null($path) || 0 == ($length = strlen($path))) {
            return null;
        }

        $is_abs = (0 === strpos($path, '/'));
        $tokens = $this->_tokenize($path);
        $dirs = [];
        $is_dir = false;
        $back = 0;
        $depth = 0;
        $str = '';

        while (false !== ($token = current($tokens))) {
            next($tokens);

            if ('/' == $token) {
                $is_dir = true;
                continue;
            }

            if ('.' == $token) {
                continue;
            }

            if ('..' == $token) {
                if (0 == $depth) {
                    $back++;
                } else {
                    $depth--;
                    array_pop($dirs);
                }
                continue;
            }

            $is_dir = false;
            $depth++;
            array_push($dirs, $token);
        }

        if ($is_abs) {
            $str = '/';
        }

        for ($i = 0; $i < $back; $i++) {
            $str .= '../';
        }

        while (false !== ($dir = current($dirs))) {
            $str .= $dir;
            if (false !== next($dirs)) {
                $str .= '/';
            }
        }

        $length = strlen($str);
        if ($is_dir && 0 < $length && $length - 1 != strpos($str, '/')) {
            $str .= '/';
        }

        if ($is_get_dir) {
            $idx = strrpos($str, '/');
            if (-1 != $idx) {
                $str = substr($str, 0, $idx + 1);
            }
        }

        return $str;
    }

    /**
     * Normalizes this URI's path.
     *
     * @return object CB_URI A URI equivalent to this URI,
     *                       but whose path is in normal form.
     */
    function normalize()
    {
        $scheme =& $this->_scheme;
        $authority =& $this->_authority;
        $path =& $this->_path;
        $query =& $this->_query;
        $fragment =& $this->_fragment;

        if (is_null($path)) {
            return $this;
        }

        $obj = new CB_URI($scheme,
            $authority,
            $this->_normalize($path, false),
            $query,
            $fragment);

        return $obj;
    }

    /**
     * Constructs a new URI by parsing the given string and
     * then resolving it against this URI.
     *
     * @param mixed $uri The URI to be relativized against this URI.
     *
     * @return object CB_URI The resulting URI; This returns <var>null</var>
     *                       when the given string violates RFC 2396.
     */
    function resolve($uri)
    {
        $obj = null;
        $type = gettype($uri);

        if ('string' == $type) {
            $uri = new CB_URI($uri);
        } elseif ('object' == $type) {
            if ( ! is_a($uri, 'CB_URI')) {
                return $obj;
            }
        } else {
            return $obj;
        }

        $scheme = [];
        array_push($scheme, $this->getScheme());
        array_push($scheme, $uri->getScheme());
        $authority = [];
        array_push($authority, $this->getAuthority());
        array_push($authority, $uri->getAuthority());
        $path = [];
        array_push($path, $this->getPath());
        array_push($path, $uri->getPath());
        $query = [];
        array_push($query, $this->getQuery());
        array_push($query, $uri->getQuery());
        $fragment = [];
        array_push($fragment, $this->getFragment());
        array_push($fragment, $uri->getFragment());

        if ($uri->isAbsolute() || $this->isOpaque()) {
            return $uri;
        }

        if ( ! is_null($fragment[1])) {
            if ((is_null($scheme[1]) || 0 == strlen($scheme[1]))
                && (is_null($authority[1]) || 0 == strlen($authority[1]))
                && (is_null($query[1]) || 0 == strlen($query[1]))
                && (is_null($path[1]) || 0 == strlen($path[1]))
            ) {
                $obj = new CB_URI($scheme[0],
                    $authority[0],
                    $this->_normalize($path[0], false),
                    $query[0],
                    $fragment[1]);

                return $obj;
            }
        }

        $idx = 1;
        if (is_null($authority[1]) || 0 == strlen($authority[1])) {
            $idx = 0;
        }

        $dir = '';
        if ( ! ( ! is_null($path[1]) && 0 === strpos($path[1], '/'))) {
            $dir = $this->_normalize($path[0], true);
        }

        $obj = new CB_URI($scheme[0],
            $authority[$idx],
            $this->_normalize($dir . $path[1], false),
            $query[1],
            $fragment[1]);

        return $obj;
    }

    /**
     * Relativizes the given URI against this URI.
     *
     * @param mixed $uri The URI to be relativized against this URI.
     *
     * @return object URI The resulting URI; This returns <var>null</var>
     *                    when the given string violates RFC 2396.
     */
    function relativize($uri)
    {
        $obj = null;
        $type = gettype($uri);

        if ('string' == $type) {
            $uri = new CB_URI($uri);
        } elseif ('object' == $type) {
            if ( ! is_a($uri, 'CB_URI')) {
                return $obj;
            }
        } else {
            return $obj;
        }

        $scheme = [];
        array_push($scheme, $this->getScheme());
        array_push($scheme, $uri->getScheme());
        $authority = [];
        array_push($authority, $this->getAuthority());
        array_push($authority, $uri->getAuthority());
        $path = [];
        array_push($path, $this->_normalize($this->getPath(), false));
        array_push($path, $this->_normalize($uri->getPath(), false));

        if ($this->isOpaque() || $uri->isOpaque()
            || $scheme[0] !== $scheme[1]
            || $authority[0] !== $authority[1]
            || 0 != strpos($path[1], $path[0])
        ) {
            $obj = new CB_URI($uri->toString());

            return $obj;
        }

        if (is_null($path[0]) || 0 < strpos($path[0], '/')) {
            $path[0] = '/' . $path[0];
        }
        if (is_null($path[1]) || 0 < strpos($path[1], '/')) {
            $path[1] = '/' . $path[1];
        }

        $dirs = [];
        array_push($dirs, $this->_tokenize($path[0]));
        array_push($dirs, $this->_tokenize($path[1]));

        $count = [];
        array_push($count, count($dirs[0]));
        array_push($count, count($dirs[1]));

        if ($count[0] > $count[1]) {
            $idx = 1;
        } else {
            $idx = 0;
        }

        for ($i = 0; $i < $count[$idx]; $i++) {
            if ($dirs[0][$i] != $dirs[1][$i]) {
                break;
            }
        }

        $str = '';
        for ($j = $count[0] - 1; $j >= $i; $j--) {
            if ('/' == $dirs[0][$j]) {
                $str .= '../';
            }
        }

        for ($j = $i; $j < $count[1]; $j++) {
            $str .= $dirs[1][$j];
        }

        if ( ! is_null($uri->getFragment())) {
            $str .= '#' . $uri->getFragment();
        }

        $obj = new CB_URI($str);

        return $obj;
    }

    /**
     * @access private
     *
     * @param string $path The path.
     */
    function _tokenize($path)
    {
        $tokens = [];
        $dirs = explode('/', $path);
        if (is_array($dirs)) {
            if (0 == strlen($dirs[0])) {
                array_push($tokens, '/');
                array_shift($dirs);
            }

            $is_empty = false;
            if (0 == strlen($dirs[count($dirs) - 1])) {
                $is_empty = true;
                array_pop($dirs);
            }

            while (false !== ($dir = current($dirs))) {
                array_push($tokens, $dir);
                array_push($tokens, '/');
                next($dirs);
            }

            if ( ! $is_empty) {
                array_pop($tokens);
            }
        }

        return $tokens;
    }

    /**
     * Tests this URI for equality with another object.
     *
     * @param mixed $uri The URI to be relativized against this URI.
     *
     * @return bool TRUE if, and only if, the given object is a URI
     *              that is identical to this URI.
     */
    function equals($uri)
    {
        $type = gettype($uri);

        if ('string' == $type) {
            $uri = new CB_URI($uri);
        } elseif ('object' == $type) {
            if ( ! is_a($uri, 'CB_URI')) {
                return null;
            }
        } else {
            return null;
        }

        $scheme = [];
        array_push($scheme, $this->_scheme);
        array_push($scheme, $uri->getScheme());

        if (is_null($scheme[0])) {
            if ( ! is_null($scheme[1])) {
                return false;
            }
        } elseif (0 != strcmp($scheme[0], $scheme[1])) {
            return false;
        }

        if ($this->_is_opaque) {
            $specific = [];
            array_push($specific, $this->_specific);
            array_push($specific, $uri->getSchemeSpecificPart());

            if (is_null($specific[0])) {
                if ( ! is_null($specific[1])) {
                    return false;
                }
            } elseif (0 != strcmp($specific[0], $specific[1])) {
                return false;
            }

            $fragment = [];
            array_push($fragment, $this->_fragment);
            array_push($fragment, $uri->getFragment());

            if (is_null($fragment[0])) {
                if ( ! is_null($fragment[1])) {
                    return false;
                }
            } elseif (0 != strcmp($fragment[0], $fragment[1])) {
                return false;
            }
        }

        $authority = [];
        array_push($authority, $this->_authority);
        array_push($authority, $uri->getAuthority());

        if (is_null($authority[0])) {
            if ( ! is_null($authority[1])) {
                return false;
            }
        } elseif (0 != strcmp($authority[0], $authority[1])) {
            return false;
        }

        $path = [];
        array_push($path, $this->_normalize($uri->getPath(), false));
        array_push($path, $this->_normalize($uri->getPath(), false));

        if (is_null($path[0])) {
            if ( ! is_null($path[1])) {
                return false;
            }
        } elseif (0 != strcmp($path[0], $path[1])) {
            return false;
        }

        unset($fragment);
        $fragment = [];
        array_push($fragment, $this->_fragment);
        array_push($fragment, $uri->getFragment());

        if (is_null($fragment[0])) {
            if ( ! is_null($fragment[1])) {
                return false;
            }
        } elseif (0 != strcmp($fragment[0], $fragment[1])) {
            return false;
        }

        return true;
    }

}


