<?php

/**
 * 経路
 *
 * @author  Hideyasu YOSHIDA 2005/12
 * @version 1.0
 * @package grn.workflow
 */

require_once('workflow/model.csp');

use grn\workflow\CustomizationUtil;

/**
 * 経路クラス
 */
class GRN_Workflow_Paths extends GRN_Workflow_Model
{
    /**
     * シングルトンの取得
     *
     * @return GRN_Workflow_Paths
     */
    public static function getInstance()
    {
        static $_instance = null;
        if (is_null($_instance)) {
            $_instance = new GRN_Workflow_Paths();
        }

        return $_instance;
    }

    /**
     * コンストラクタ
     */
    function __construct()
    {
        parent::__construct('tab_grn_workflow_path');

        $this->_columns_info = [
            'necessary' => [
                'col_name',
                'col_foreign_key'
            ],
            'usual'     => [
                'col_type',
                'col_description',
                'col_richeditor',
                'col_creator',
                'col_creator_name',
                'col_creator_foreign_key',
                'col_ctime',
                'col_modifier',
                'col_modifier_name',
                'col_modifier_foreign_key',
                'col_mtime'
            ],
            'initial'   => [
                'col_skip' => 0,
                'col_icon' => 0
            ]
        ];

        $this->_aliases = [
            'tab_grn_workflow_form' => 'a',
            'tab_grn_workflow_path' => 'b'
        ];
    }

    /**
     * 経路を取得
     *
     * @param   int   $path_id 経路ID
     * @param   array $columns プロパティを取得するカラム名一覧
     * @param   int   $lock    ロックの種類
     *
     * @return  mixed   プロパティ一覧（カラム名とプロパティ）
     *                  それ以外は失敗
     */
    function &get($path_id, $columns = null, $lock = CB_DATABASE_DEFAULT_LOCK)
    {
        cb_trim_check($path_id, E_GRN_WRKF_INVALID_PATH_ID);

        $condition = cb_queryf($this->_dbconn, "{$this->_table_name}._id='@S'",
            $path_id);
        $join_key = ['col_creator', 'col_modifier'];
        $rows = $this->_selectRecordsLeftJoinUser($columns, '_id', 0, 1,
            null, $condition, $lock, $join_key);

        $ret = false;
        if (array_key_exists($path_id, $rows)) {
            $ret = $rows[$path_id];
        }

        return $ret;
    }

    /**
     * 経路を取得
     *
     * @param   int   $foreign_key 経路コード
     * @param   array $columns     プロパティを取得するカラム名一覧
     * @param   int   $lock        ロックの種類
     *
     * @return  mixed   FALSEの場合は失敗
     *                  それ以外はプロパティ一覧（カラム名とプロパティ）
     */
    function &getByForeignKey(
        $foreign_key,
        $columns = null,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        cb_trim_check($foreign_key, E_GRN_WRKF_INVALID_PATH_FOREIGN_KEY);

        $condition = cb_queryf($this->_dbconn,
            "{$this->_table_name}.col_foreign_key='@S'", $foreign_key);
        $join_key = ['col_creator', 'col_modifier'];
        $rows = $this->_selectRecordsLeftJoinUser($columns,
            'col_foreign_key', 0, 1, null, $condition, $lock, $join_key);

        $ret = false;
        if (array_key_exists($foreign_key, $rows)) {
            $ret = $rows[$foreign_key];
        }

        return $ret;
    }

    /**
     * 経路一覧を取得
     *
     * @param   mixed $pids         （特定の）経路を取得する場合は経路IDの配列
     *                              それ以外はすべて取得
     * @param   array $columns      プロパティを取得するカラム名一覧
     * @param   int   $type         経路タイプ
     * @param   int   $offset       一覧の先頭オフセット
     * @param   int   $limit        一覧件数
     * @param   int   $lock         ロックの種類
     *
     * @return  array   レコード一覧（経路IDとレコード）
     */
    function &getList(
        $pids = null,
        $columns = null,
        $type = GRN_WORKFLOW_PRIVATE_PATH,
        $offset = 0,
        $limit = -1,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        $condition = [];
        if ($type & GRN_WORKFLOW_PRIVATE_PATH) {
            $condition[] = "({$this->_table_name}.col_type='1')";
        }
        if ($type & GRN_WORKFLOW_PUBLIC_PATH) {
            $condition[] = "({$this->_table_name}.col_type='2')";
        }
        if ($type & GRN_WORKFLOW_SEPARATOR) {
            $condition[] = "({$this->_table_name}.col_type='4')";
        }
        $condition = implode(' OR ', $condition);

        if (is_array($pids) && 0 < count($pids)) {
            foreach ($pids as $key => $value) {
                $pids[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
            }
            $pids = implode(',', $pids);
            if (0 < strlen($condition)) {
                $condition = " AND ({$condition})";
            }
            $condition = "({$this->_table_name}._id IN (${pids})){$condition}";
        }

        $join_key = ['col_creator', 'col_modifier'];
        $order_by
            = "{$this->_table_name}.col_list_index, {$this->_table_name}._id";
        $ret = $this->_selectRecordsLeftJoinUser($columns, '_id', $offset,
            $limit, $order_by, $condition, $lock, $join_key);

        return $ret;
    }

    /**
     * 経路一覧を取得
     *
     * @param   mixed   $foreign_keys   （特定の）経路を取得する場合は外部キーの配列
     *                                  それ以外はすべて取得
     * @param   array   $columns        プロパティを取得するカラム名一覧
     * @param   boolean $public         共有経路のみ取得フラグ
     * @param   int     $offset         一覧の先頭オフセット
     * @param   int     $limit          一覧件数
     * @param   int     $lock           ロックの種類
     *
     * @return  array   レコード一覧（外部キーとレコード）
     */
    function &getListByForeignKeys(
        $foreign_keys = null,
        $columns = null,
        $offset = 0,
        $limit = -1,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        $condition = null;
        if (is_array($foreign_keys) && 0 < count($foreign_keys)) {
            foreach ($foreign_keys as $key => $value) {
                $foreign_keys[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
            }
            $foreign_keys = implode(',', $foreign_keys);
            $condition
                = "({$this->_table_name}.col_foreign_key IN (${foreign_keys}))";
        }

        $join_key = ['col_creator', 'col_modifier'];
        $order_by
            = "{$this->_table_name}.col_list_index, {$this->_table_name}._id";
        $ret = $this->_selectRecordsLeftJoinUser($columns,
            'col_foreign_key', $offset, $limit, $order_by, $condition, $lock,
            $join_key);

        return $ret;
    }

    /**
     * 経路を変更
     *
     * @param   int   $path_id    経路ID
     * @param   array $properties プロパティ一覧（カラム名とプロパティ）
     */
    function modify($path_id, $properties)
    {
        cb_trim_check($path_id, E_GRN_WRKF_INVALID_PATH_ID);
        if ( ! is_array($properties) || 0 == count($properties)) {
            assert('FALSE');
        }
        if (array_key_exists('col_description', $properties)
            && array_key_exists('col_richeditor', $properties)
            && $properties['col_richeditor'] == 1
        ) {
            require_once('grn/controller.csp');
            $properties['col_description']
                = grn_wash_script_without_style_attribute($properties['col_description']);
        }

        $condition = cb_queryf($this->_dbconn, "_id='@S'", $path_id);
        $this->_updateRecords($condition, $properties);
    }

    /**
     * レコードを追加
     *
     * @param   array $properties プロパティ一覧（カラム名とプロパティ）
     *
     * @return  string  プライマリID
     */
    function &add($properties)
    {
        if ( ! is_array($properties) || 0 == count($properties)) {
            cb_throw_error(E_GRN_WRKF_EMPTY_PROPERTIES);
        }
        if (array_key_exists('col_description', $properties)
            && array_key_exists('col_richeditor', $properties)
            && $properties['col_richeditor'] == 1
        ) {
            require_once('grn/controller.csp');
            $properties['col_description']
                = grn_wash_script_without_style_attribute($properties['col_description']);
        }

        $ret = $this->_insertRecords(array_keys($properties), [$properties]);

        return $ret;
    }

    /**
     * 経路を削除
     *
     * @param   int $path_id 経路ID
     */
    function remove($path_id)
    {
        cb_trim_check($path_id, E_GRN_WRKF_INVALID_PATH_ID);

        $condition = cb_queryf($this->_dbconn, "_id='@S'", $path_id);
        $this->_deleteRecords($condition);
    }

    /**
     * 経路を一括削除
     *
     * @param   mixed $pids     （特定の）経路を一括削除する場合は経路IDの配列
     *                          それ以外はすべて削除
     */
    function removeList($pids = null)
    {
        $condition = null;
        if (is_array($pids) && 0 < count($pids)) {
            foreach ($pids as $key => $value) {
                $pids[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
            }
            $pids = implode(',', $pids);
            $condition = "_id IN (${pids})";
        }

        $this->_deleteRecords($condition);
    }

    /**
     * 経路総数を取得
     *
     * @param   boolean $public 共有経路のみを取得フラグ
     *
     * @return  int     経路総数
     */
    function getCount($type = GRN_WORKFLOW_PRIVATE_PATH)
    {
        $conditions = [];
        if ($type & GRN_WORKFLOW_PRIVATE_PATH) {
            $conditions[] = "'1'";
        }
        if ($type & GRN_WORKFLOW_PUBLIC_PATH) {
            $conditions[] = "'2'";
        }
        if ($type & GRN_WORKFLOW_SEPARATOR) {
            $conditions[] = "'4'";
        }
        $condition = implode(',', $conditions);
        $condition = "col_type IN({$condition})";

        return $this->_countRecord($condition);
    }
}

/**
 * 経路ステップクラス
 */
class GRN_Workflow_PathSteps extends GRN_Workflow_Model
{
    /**
     * シングルトンの取得
     *
     * @return GRN_Workflow_PathSteps
     */
    public static function getInstance()
    {
        static $_instance = null;
        if (is_null($_instance)) {
            $_instance = new GRN_Workflow_PathSteps();
        }

        return $_instance;
    }

    /**
     * コンストラクタ
     */
    function __construct()
    {
        parent::__construct('tab_grn_workflow_pathstep');

        $this->_columns_info = [
            'necessary' => [
                'col_path',
                'col_role',
                'col_acceptance_type'
            ],
            'usual'     => [
                'col_type',
                'col_code',
                'col_skip',
                'col_applicant',
                'col_deny_change_path'
            ],
            'initial'   => ['col_change_path' => 0]
        ];

        $this->_aliases = [
            'tab_grn_workflow_path'     => 'a',
            'tab_grn_workflow_pathstep' => 'b'
        ];
    }

    /**
     * 経路ステップを取得
     *
     * @param   int   $path_step_id 経路ステップID
     * @param   array $columns      プロパティを取得するカラム名一覧
     * @param   int   $lock         ロックの種類
     *
     * @return  array   プロパティ一覧（カラム名とプロパティ）
     *                  それ以外の場合は失敗
     */
    function &get(
        $path_id,
        $path_step_id,
        $columns = null,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        cb_trim_check($path_step_id, E_GRN_WRKF_INVALID_PATH_STEP_ID);

        $condition = cb_queryf($this->_dbconn, "_id='@S'", $path_step_id);
        if (0 < strlen($path_id)) {
            $condition = cb_queryf($this->_dbconn,
                "({$condition}) AND (col_path='@S')", $path_id);
        }

        $rows = $this->_selectRecords($columns, '_id', 0, 1, null, $condition,
            $lock);

        $ret = false;
        if (array_key_exists($path_step_id, $rows)) {
            $ret = $rows[$path_step_id];
        }

        return $ret;
    }

    /**
     * 経路ステップ一覧を取得
     *
     * @param   mixed $psids        （特定の）経路ステップを取得する場合は経路ステップIDの配列
     *                              それ以外はすべて取得
     * @param   array $columns      プロパティを取得するカラム名一覧
     * @param   int   $type
     * @param   int   $offset       一覧の先頭オフセット
     * @param   int   $limit        一覧件数
     * @param   int   $lock         ロックの種類
     *
     * @return  array   レコード一覧（経路ステップIDとレコード）
     */
    function &getList(
        $path_id = null,
        $psids = null,
        $type = null,
        $columns = null,
        $offset = 0,
        $limit = -1,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        $condition = [];
        if (0 < strlen($path_id)) {
            $condition[] = cb_queryf($this->_dbconn, "(col_path='@S')",
                $path_id);
        }
        if (is_array($psids) && 0 < count($psids)) {
            foreach ($psids as $key => $value) {
                $psids[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
            }
            $psids = implode(',', $psids);
            $condition[] = "(_id IN (${psids}))";
        }
        if (0 < strlen($type)) {
            $condition[] = cb_queryf($this->_dbconn, "col_type='@S'", $type);
        }
        $condition = implode(' AND ', $condition);

        $ret = $this->_selectRecords($columns, '_id', $offset, $limit,
            'col_type,col_list_index,_id', $condition, $lock);

        return $ret;
    }

    /**
     * 経路ステップを変更
     *
     * @param   int   $path_step_id 経路ステップID
     * @param   array $properties   プロパティ一覧（カラム名とプロパティ）
     */
    function modify($path_step_id, $properties)
    {
        cb_trim_check($path_step_id, E_GRN_WRKF_INVALID_PATH_STEP_ID);
        if ( ! is_array($properties) || 0 == count($properties)) {
            assert('FALSE');
        }

        $condition = cb_queryf($this->_dbconn, "_id='@S'", $path_step_id);
        $this->_updateRecords($condition, $properties);
    }

    /**
     * 経路ステップを削除
     *
     * @param   int $path_step_id 経路ステップID
     */
    function remove($path_step_id)
    {
        cb_trim_check($path_step_id, E_GRN_WRKF_INVALID_PATH_STEP_ID);

        $condition = cb_queryf($this->_dbconn, "_id='@S'", $path_step_id);
        $this->_deleteRecords($condition);
    }

    /**
     * 経路ステップを一括削除
     *
     * @param   mixed $ids      （特定の）経路ステップを一括削除する場合は経路ステップIDの配列
     *                          それ以外はすべて削除
     */
    function removeList($psids = null)
    {
        $condition = null;
        if (is_array($psids) && 0 < count($psids)) {
            foreach ($psids as $key => $value) {
                $psids[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
            }
            $psids = implode(',', $psids);
            $condition = "_id IN (${psids})";
        }

        $this->_deleteRecords($condition);
    }

    /**
     * 経路ステップを一括削除
     *
     * @param   mixed $ids      （特定の）経路ステップを一括削除する場合は経路ステップIDの配列
     *                          それ以外はすべて削除
     */
    function removeListByPathId($path_id)
    {
        cb_trim_check($path_id, E_GRN_WRKF_INVALID_PATH_ID);

        $condition = cb_queryf($this->_dbconn, "col_path='@S'", $path_id);
        $this->_deleteRecords($condition);
    }

    /**
     * 経路ステップ総数を取得
     *
     * @return  int     経路ステップ総数
     */
    function getCount($path_id = null)
    {
        $condition = null;
        if (0 < strlen($path_id)) {
            $condition = cb_queryf($this->_dbconn, "col_path='@S'", $path_id);
        }

        return $this->_countRecord($condition);
    }

    /**
     * @param array $properties
     * @param bool  $is_importing
     *
     * @return string
     */
    function &add($properties, $is_importing = false)
    {
        if ( ! is_array($properties) || 0 == count($properties)) {
            cb_throw_error(E_GRN_WRKF_EMPTY_PROPERTIES);
        }

        $properties['col_code']
            = CustomizationUtil::trimCode($properties['col_code']);
        if ($is_importing && ! is_null($properties['col_code'])
            && strlen($properties['col_code']) > 0
            && ! CustomizationUtil::validateCode($properties['col_code'])
        ) {
            cb_throw_error(E_GRN_WRKF_INVALID_PATH_STEP_CODE_VALUE);
        }

        if ($this->isDuplicationPathStepCode($properties['col_path'],
            [$properties['col_code']])
        ) {
            require_once('workflow/error_code.csp');
            if ($is_importing) {
                cb_throw_error(E_GRN_WRKF_IMPORT_COLLISION_PATH_STEP_CODE);
            }
            cb_throw_error(E_GRN_WRKF_COLLISION_PATH_STEP_CODE);
        }

        $ret = $this->_insertRecords(array_keys($properties), [$properties]);

        return $ret;
    }

    /**
     * @param int      $col_path
     * @param array    $codes
     * @param int|NULL $path_id
     *
     * @return bool
     */
    public function isDuplicationPathStepCode(
        $col_path,
        $codes,
        $path_id = null
    ) {
        foreach ($codes as $key => $code) {
            if (strlen(cb_trim($code)) == 0) {
                unset($codes[$key]);
            }
        }

        if (empty($codes)) {
            return false;
        }

        $database = $this->_dbconn;
        $query
            = "SELECT COUNT(1) as total  FROM {$this->_table_name}  WHERE col_path= '@S' AND col_code COLLATE utf8mb4_bin IN (@A) ";
        if ( ! is_null($path_id)) {
            $query .= "AND _id <> '@S' ";
            $query = cb_queryf($database, $query, $col_path, $codes, $path_id);
        } else {
            $query = cb_queryf($database, $query, $col_path, $codes);
        }
        $result = $database->query($query);
        $row = $database->fetch_assoc($result);

        return $row['total'] > 0 ? true : false;
    }
}

/**
 * 経路ステップメンバークラス
 */
class GRN_Workflow_PathStepMembers extends GRN_Workflow_Model
{
    var $_member_table_name = null;

    /**
     * コンストラクタ
     */
    function __construct($table_name)
    {
        $this->_columns_info = [
            'necessary' => [
                'col_path_step',
                'col_member'
            ]
        ];

        parent::__construct($table_name);
    }

    /**
     * メンバー情報を取得
     *
     * @param   int   $member_id メンバーID
     * @param   array $columns   プロパティを取得するカラム名一覧
     * @param   int   $lock      ロックの種類
     *
     * @return  array   プロパティ一覧（カラム名とプロパティ）
     *                  それ以外の場合は失敗
     */
    function &get($member_id, $columns = null, $lock = CB_DATABASE_DEFAULT_LOCK)
    {
        cb_trim_check($member_id, E_GRN_WRKF_INVALID_MEMBER_ID);

        $condition = cb_queryf($this->_dbconn, "_id='@S'", $member_id);
        $rows = $this->_selectRecords($columns, '_id', 0, 1, null,
            $condition, $lock);
        $ret = false;
        if (array_key_exists($member_id, $rows)) {
            $ret = $rows[$member_id];
        }

        return $ret;
    }

    /**
     * メンバー情報を変更
     *
     * @param   int   $member_id  メンバーID
     * @param   array $properties プロパティ一覧（カラム名とプロパティ）
     */
    function modify($member_id, $properties)
    {
        cb_trim_check($member_id, E_GRN_WRKF_INVALID_MEMBER_ID);
        if ( ! is_array($properties) || 0 == count($properties)) {
            assert('FALSE');
        }

        $condition = cb_queryf($this->_dbconn, "_id='@S'", $member_id);
        $this->_updateRecords($condition, $properties);
    }

    function &getList(
        $psids,
        $columns,
        $offset = 0,
        $limit = -1,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        if ( ! is_array($psids) || 0 == count($psids)) {
            // 経路ステップが空
            cb_throw_error(E_GRN_WRKF_EMPTY_PATH_STEP);
        }
        if ( ! is_array($columns) || 0 == count($columns)) {
            assert('FALSE');
        }

        foreach ($psids as $key => $value) {
            $psids[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
        }
        $psids = implode(',', $psids);
        $condition = "col_path_step IN({$psids})";

        $columns = $this->_formatColumns($columns, $this->_aliases);
        $from
            = "{$this->_table_name} AS b LEFT JOIN {$this->_member_table_name} AS c ON b.col_member=c._id";
        $order_by = 'c.col_list_index,c._id';
        $query
            = "SELECT {$columns} FROM {$from} WHERE {$condition} ORDER BY {$order_by}";
        $query = $this->_dbconn->select_format($query, $offset, $limit,
            $lock);
        $result = $this->_dbconn->query($query);
        if (false === $result) {
            $this->_dbconn->throwError(['query' => "failed query on SELECT: {$query}"]);
        }

        $rows = [];
        while ($row = $this->_dbconn->fetch_assoc($result)) {
            if ( ! array_key_exists($row['col_path_step'], $rows)) {
                $rows[$row['col_path_step']] = [];
            }
            $rows[$row['col_path_step']][$row['_id']] = $row;
        }

        return $rows;
    }

    /**
     * 経路ステップユーザーを一括削除
     *
     * @param   int   $path_step_id     経路ステップID
     * @param   mixed $mids             （特定の）メンバーを一括削除する場合はメンバーIDの配列
     *                                  それ以外はすべて削除
     */
    function removeSpecificList($path_step_id, $mids = null)
    {
        cb_trim_check($path_step_id, E_GRN_WRKF_INVALID_PATH_STEP_ID);

        $condition = cb_queryf($this->_dbconn, "col_path_step='@S'",
            $path_step_id);
        if (is_array($mids) && 0 < count($mids)) {
            foreach ($mids as $key => $value) {
                cb_trim_check($value, E_GRN_WRKF_INVALID_MEMBER_ID);
                $mids[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
            }
            $mids = implode(',', $mids);
            $condition = "({$condition}) AND (col_member IN (${mids}))";
        }

        $this->_deleteRecords($condition);
    }
}

/**
 * 経路ステップユーザークラス
 */
class GRN_Workflow_PathStepUsers extends GRN_Workflow_PathStepMembers
{
    /**
     * シングルトンの取得
     *
     * @return GRN_Workflow_PathStepUsers
     */
    public static function getInstance()
    {
        static $_instance = null;
        if (is_null($_instance)) {
            $_instance = new GRN_Workflow_PathStepUsers();
        }

        return $_instance;
    }

    /**
     * コンストラクタ
     */
    function __construct()
    {
        parent::__construct('tab_grn_workflow_pathstepuser');

        $this->_aliases = [
            'tab_grn_workflow_pathstep'     => 'a',
            'tab_grn_workflow_pathstepuser' => 'b',
            'tab_cb_user'                   => 'c'
        ];

        $this->_member_table_name = 'tab_cb_user';
    }

    function _selectRecordsInnerJoinUser(
        $columns = null,
        $key = '_id',
        $offset = 0,
        $limit = -1,
        $order_by = 'col_list_index,_id',
        $condition = null,
        $lock = CB_DATABASE_NO_LOCK
    ) {
        if ( ! is_array($columns)) {
            $columns = [];
        }
        if (false === array_search($key, $columns)) {
            $columns[] = $key;
        }

        $join = "";
        $column_key = array_search("col_member", $columns);
        if ($column_key !== false) {
            $join
                = " INNER JOIN tab_cb_user AS c ON (b.{$value}=c._id AND c.col_deleted IS NULL)";
        }

        $columns = implode(',b', $columns);
        $columns = "b." . $columns;

        if (0 < strlen($condition)) {
            $condition = " WHERE ({$condition})";
        }

        if (0 < strlen($order_by)) {
            $order_by = " ORDER BY {$order_by}";
        }

        $query
            = "SELECT {$columns} FROM {$this->_table_name} AS b {$join} {$condition}{$order_by}";
        $query = $this->_dbconn->select_format($query, $offset, $limit, $lock);
        $result = $this->_dbconn->query($query);
        if (false === $result) {
            $this->_dbconn->throwError(['query' => "failed query on SELECT: {$query}"]);
        }

        $rows = [];
        while ($row = $this->_dbconn->fetch_assoc($result)) {
            $rows[$row[$key]] = $row;
        }

        return $rows;
    }

    /**
     * メンバー情報を取得
     *
     * @param int   $member_id メンバーID
     * @param array $columns   プロパティを取得するカラム名一覧
     * @param int   $lock      ロックの種類
     *
     * @return array            プロパティ一覧(カラム名とプロパティ)
     *                           それ以外の場合は失敗
     */
    function &get($member_id, $columns = null, $lock = CB_DATABASE_DEFAULT_LOCK)
    {
        cb_trim_check($member_id, E_GRN_WRKF_INVALID_MEMBER_ID);

        $condition = cb_queryf($this->_dbconn, "b._id='@S'", $member_id);
        $rows = $this->_selectRecordsInnerJoinUser($columns, '_id', 0, 1,
            null, $condition, $lock);
        $ret = false;
        if (array_key_exists($member_id, $rows)) {
            $ret = $rows[$member_id];
        }

        return $ret;
    }

    function &getList(
        $psids,
        $columns,
        $offset = 0,
        $limit = -1,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        if ( ! is_array($psids) || 0 == count($psids)) {
            // 経路ステップが空
            cb_throw_error(E_GRN_WRKF_EMPTY_PATH_STEP);
        }
        if ( ! is_array($columns) || 0 == count($columns)) {
            assert('FALSE');
        }

        foreach ($psids as $key => $value) {
            $psids[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
        }
        $psids = implode(',', $psids);
        $condition = "b.col_path_step IN({$psids})";

        $columns = $this->_formatColumns($columns, $this->_aliases);
        $from
            = "{$this->_table_name} AS b INNER JOIN {$this->_member_table_name} AS c ON (b.col_member=c._id AND c.col_deleted IS NULL)";
        $order_by = 'c.col_position,c._id';
        $query
            = "SELECT {$columns} FROM {$from} WHERE {$condition} ORDER BY {$order_by}";
        $query = $this->_dbconn->select_format($query, $offset, $limit,
            $lock);
        $result = $this->_dbconn->query($query);
        if (false === $result) {
            $this->_dbconn->throwError(['query' => "failed query on SELECT: {$query}"]);
        }

        $rows = [];
        while ($row = $this->_dbconn->fetch_assoc($result)) {
            if ( ! array_key_exists($row['col_path_step'], $rows)) {
                $rows[$row['col_path_step']] = [];
            }
            $rows[$row['col_path_step']][$row['_id']] = $row;
        }

        return $rows;
    }
}

/**
 * 経路ステップ組織クラス
 */
class GRN_Workflow_PathStepGroups extends GRN_Workflow_PathStepMembers
{
    /**
     * シングルトンの取得
     *
     * @return GRN_Workflow_PathStepGroups
     */
    public static function getInstance()
    {
        static $_instance = null;
        if (is_null($_instance)) {
            $_instance = new GRN_Workflow_PathStepGroups();
        }

        return $_instance;
    }

    /**
     * コンストラクタ
     */
    function __construct()
    {
        parent::__construct('tab_grn_workflow_pathstepgroup');

        $this->_aliases = [
            'tab_grn_workflow_pathstep'      => 'a',
            'tab_grn_workflow_pathstepgroup' => 'b',
            'tab_cb_group'                   => 'c'
        ];

        $this->_member_table_name = 'tab_cb_group';
    }
}

/**
 * 経路ステップスタティックロールクラス
 */
class GRN_Workflow_PathStepStaticRoles extends GRN_Workflow_PathStepMembers
{
    /**
     * シングルトンの取得
     *
     * @return GRN_Workflow_PathStepStaticRoles
     */
    public static function getInstance()
    {
        static $_instance = null;
        if (is_null($_instance)) {
            $_instance = new GRN_Workflow_PathStepStaticRoles();
        }

        return $_instance;
    }

    /**
     * コンストラクタ
     */
    function __construct()
    {
        parent::__construct('tab_grn_workflow_pathstepstaticrole');

        $this->_columns_info = [
            'necessary' => [
                'col_path_step',
                'col_member'
            ],
            'initial'   => ['col_chief' => 0]
        ];

        $this->_aliases = [
            'tab_grn_workflow_pathstep'           => 'a',
            'tab_grn_workflow_pathstepstaticrole' => 'b',
            'tab_cb_role'                         => 'c'
        ];

        $this->_member_table_name = 'tab_cb_role';
    }
}

/**
 * 経路ステップダイナミックロールクラス
 */
class GRN_Workflow_PathStepDynamicRoles extends GRN_Workflow_PathStepMembers
{
    /**
     * シングルトンの取得
     *
     * @return GRN_Workflow_PathStepDynamicRoles
     */
    public static function getInstance()
    {
        static $_instance = null;
        if (is_null($_instance)) {
            $_instance = new GRN_Workflow_PathStepDynamicRoles();
        }

        return $_instance;
    }

    /**
     * コンストラクタ
     */
    function __construct()
    {
        parent::__construct('tab_grn_workflow_pathstepdynamicrole');

        $this->_aliases = [
            'tab_grn_workflow_pathstep'            => 'a',
            'tab_grn_workflow_pathstepdynamicrole' => 'b'
        ];
    }

    /**
     * （経路に所属する）ユーザー情報一覧を取得
     *
     * @param   int    $path_id 経路ID
     * @param   array  $columns プロパティを取得するカラム名一覧（テーブル名とカラム名一覧）
     * @param   string $key     ユーザー情報一覧のキー
     * @param   int    $offset  一覧の先頭オフセット
     * @param   int    $limit   一覧件数
     * @param   int    $lock    ロックの種類
     *
     * @return  array   ユーザー情報一覧（ユーザーIDとユーザー情報）
     */
    function &getList(
        $psids,
        $columns,
        $offset = 0,
        $limit = -1,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        if ( ! is_array($psids) || 0 == count($psids)) {
            assert('FALSE');
        }
        if ( ! is_array($columns) || 0 == count($columns)) {
            assert('FALSE');
        }

        foreach ($psids as $key => $value) {
            $psids[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
        }
        $psids = implode(',', $psids);
        $condition = "col_path_step IN({$psids})";

        $rows = $this->_selectRecords($columns, '_id', 0, 1, null, $condition,
            $lock);

        $sorted_rows = [];
        foreach ($rows as $row) {
            if ( ! array_key_exists($row['col_path_step'], $rows)) {
                $sorted_rows[$row['col_path_step']] = [];
            }
            $sorted_rows[$row['col_path_step']][$row['col_member']] = $row;
        }

        return $sorted_rows;
    }
}


