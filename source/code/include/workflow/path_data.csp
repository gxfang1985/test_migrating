<?php

/**
 * 経路データ
 *
 * @author  Hideyasu YOSHIDA 2006/01
 * @version 1.0
 * @package grn.workflow
 */

require_once('workflow/model.csp');

/**
 * 経路ステップデータクラス
 */
class GRN_Workflow_PathStepDatas extends GRN_Workflow_Model
{
    /**
     * シングルトンの取得
     *
     * @return GRN_Workflow_PathStepDatas
     */
    public static function getInstance()
    {
        static $_instance = null;
        if (is_null($_instance)) {
            $_instance = new GRN_Workflow_PathStepDatas();
        }

        return $_instance;
    }

    /**
     * コンストラクタ
     */
    function __construct()
    {
        $this->_columns_info = [
            'necessary' => [
                'col_petition',
                'col_role'
            ],
            'usual'     => [
                'col_activate',
                'col_finished',
                'col_path_step',
                'col_type',
                'col_acceptance_type',
                'col_skip',
                'col_applicant',
                'col_deny_change_path',
                'col_change_path'
            ]
        ];

        parent::__construct('tab_grn_workflow_pathstepdata');
    }

    /**
     * 経路ステップデータを取得
     *
     * @param   int   $path_step_data_id 経路ステップデータID
     * @param   array $columns           プロパティを取得するカラム名一覧
     * @param   int   $lock              ロックの種類
     *
     * @return  mixed   プロパティ一覧（カラム名とプロパティ）
     *                  それ以外は失敗
     */
    function &get(
        $path_step_data_id,
        $columns = null,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        cb_trim_check($path_step_data_id, E_GRN_WRKF_INVALID_PATH_STEP_DATA_ID);

        $condition = cb_queryf($this->_dbconn, "_id='@S'", $path_step_data_id);
        $rows = $this->_selectRecords($columns, '_id', 0, 1, null,
            $condition, $lock);

        $ret = false;
        if (array_key_exists($path_step_data_id, $rows)) {
            $ret = $rows[$path_step_data_id];
        }

        return $ret;
    }

    /**
     * 経路ステップデータ一覧を取得
     *
     * @param   mixed $psdids       （特定の）経路ステップデータを取得する場合は経路ステップデータIDの配列
     *                              それ以外はすべて取得
     * @param   array $columns      プロパティを取得するカラム名一覧
     * @param   int   $offset       一覧の先頭オフセット
     * @param   int   $limit        一覧件数
     * @param   int   $lock         ロックの種類
     *
     * @return  array   レコード一覧（経路IDとレコード）
     */
    function &getList(
        $psdids = null,
        $columns = null,
        $offset = 0,
        $limit = -1,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        $condition = null;
        if (is_array($psdids) && 0 < count($psdids)) {
            foreach ($psdids as $key => $val) {
                $psdids[$key] = cb_queryf($this->_dbconn, "'@S'", $val);
            }
            $psdids = implode(',', $psdids);
            $condition = "_id IN (${psdids})";
        }

        $ret = $this->_selectRecords($columns, '_id', $offset, $limit,
            'col_list_index,_id', $condition, $lock);

        return $ret;
    }

    /**
     * 経路ステップデータ一覧を取得
     *
     * @param   int   $petition_id 申請ID
     * @param   array $columns     プロパティを取得するカラム名一覧
     * @param   int   $offset      一覧の先頭オフセット
     * @param   int   $limit       一覧件数
     * @param   int   $lock        ロックの種類
     *
     * @return  array   プロパティ一覧（カラム名とプロパティ）
     */
    function getListByPetitionId(
        $petition_id,
        $columns = null,
        $offset = 0,
        $limit = -1,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        cb_trim_check($petition_id, E_GRN_WRKF_PETITION_INVALID_ID);

        $condition = cb_queryf($this->_dbconn, "col_petition='@S'",
            $petition_id);

        return $this->_selectRecords($columns, '_id', $offset, $limit,
            'col_list_index,_id', $condition, $lock);
    }

    function getSpecificList(
        $pids,
        $columns = null,
        $offset = 0,
        $limit = -1,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        $conditino = null;
        foreach ($pids as $key => $value) {
            $pids[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
        }
        $pids = implode(',', $pids);
        $condition = "col_petition IN($pids)";

        return $this->_selectRecords($columns, '_id', $offset, $limit,
            'col_petition,col_list_index,_id', $condition, $lock);
    }

    /**
     * 経路ステップデータを変更
     *
     * @param   int   $path_step_data_id 経路ステップデータID
     * @param   array $properties        プロパティ一覧（カラム名とプロパティ）
     */
    function modify($path_step_data_id, $properties)
    {
        cb_trim_check($path_step_data_id, E_GRN_WRKF_INVALID_PATH_STEP_DATA_ID);
        if ( ! is_array($properties) || 0 == count($properties)) {
            assert('FALSE');
        }

        $condition = cb_queryf($this->_dbconn, "_id='@S'", $path_step_data_id);
        $this->_updateRecords($condition, $properties);
    }

    function modifyList($psdids = null, $properties)
    {
        if ( ! is_array($properties) || 0 == count($properties)) {
            assert('FALSE');
        }

        $condition = null;
        if (is_array($psdids) && 0 < count($psdids)) {
            foreach ($psdids as $key => $val) {
                $psdids[$key] = cb_queryf($this->_dbconn, "'@S'", $val);
            }
            $psdids = implode(',', $psdids);
            $condition = "_id IN (${psdids})";
        }

        $this->_updateRecords($condition, $properties);
    }

    /**
     * 経路ステップデータを削除
     *
     * @param   int $path_step_data_id 経路ID
     */
    function remove($path_step_data_id)
    {
        cb_trim_check($path_step_data_id, E_GRN_WRKF_INVALID_PATH_STEP_DATA_ID);

        $condition = cb_queryf($this->_dbconn, "_id='@S'", $path_step_data_id);
        $this->_deleteRecords($condition);
    }

    /**
     * 経路ステップデータを一括削除
     *
     * @param   mixed $psdids       （特定の）経路ステップデータを一括削除する場合は経路ステップデータIDの配列
     *                              それ以外はすべて削除
     */
    function removeList($psdids = null)
    {
        $condition = null;
        if (is_array($psdids) && 0 < count($psdids)) {
            foreach ($psdids as $key => $value) {
                $psdids[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
            }
            $psdids = implode(',', $psdids);
            $condition = "_id IN (${psdids})";
        }

        $this->_deleteRecords($condition);
    }


    /**
     * Get List By Petition Id With Extra Info
     *
     * @param array $petition_ids
     * @param int   $offset
     * @param int   $limit
     * @param int   $lock
     *
     * @return array
     */
    function getListByPetitionIdEx(
        $petition_ids,
        $offset = 0,
        $limit = -1,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        $query
            = "SELECT p._id pid, pd._id, pd.col_petition, pd.col_activate, pd.col_finished, pd.col_path_step, "
              .
              "       pd.col_type,pd.col_acceptance_type,pd.col_role,pd.col_skip,pd.col_applicant, "
              .
              "       pd.col_deny_change_path,pd.col_change_path, a._id aid, i._id iid, a.col_view "
              .
              "FROM (" .
              "(" .
              "tab_grn_workflow_petition p " .
              "LEFT JOIN " . $this->_table_name . " pd "
              . "ON p._id = pd.col_petition " .
              ") " .
              "LEFT JOIN tab_grn_workflow_itemdata i on p._id = i.col_petition "
              .
              ") " .
              "LEFT JOIN tab_grn_workflow_accesschangedata a on i._id = a.col_item_data and pd._id = a.col_path_step_data "
              .
              "WHERE pd.col_petition IN (" . cb_queryf($this->_dbconn, "@S",
                implode(',', $petition_ids)) . ") " .
              "ORDER BY pd.col_list_index, pd._id ";
        $query = $this->_dbconn->select_format($query, $offset, $limit, $lock);
        $result = $this->_dbconn->query($query);
        if (false === $result) {
            $this->_dbconn->throwError(['query' => "failed query on SELECT: {$query}"]);
        }

        $rows = [];
        while ($row = $this->_dbconn->fetch_assoc($result)) {
            $pid = $row['pid'];
            $id = $row['_id'];
            $aid = $row['aid'];
            $iid = $row['iid'];
            $view = $row['col_view'];
            unset($row['iid']);
            unset($row['col_view']);
            unset($row['aid']);
            if (array_key_exists($pid, $rows)) {
                if (array_key_exists($id, $rows[$pid]['path_steps'])) {
                    $rows[$pid]['path_steps'][$id]['items'][] = [
                        'iid'  => $iid,
                        'aid'  => $aid,
                        'view' => $view
                    ];
                } else {
                    $rows[$pid]['path_steps'][$id] = $row;
                    $rows[$pid]['path_steps'][$id]['items'][] = [
                        'iid'  => $iid,
                        'aid'  => $aid,
                        'view' => $view
                    ];
                }
            } else {
                //$rows[$pid] = $row;
                $rows[$pid]['path_steps'][$id] = $row;
                $rows[$pid]['path_steps'][$id]['items'][] = [
                    'iid'  => $iid,
                    'aid'  => $aid,
                    'view' => $view
                ];
            }
        }

        $this->_dbconn->free_result($result);

        return $rows;
    }
}

/**
 * 経路ステップデータユーザークラス
 */
class GRN_Workflow_PathStepDataUsers extends GRN_Workflow_Model
{
    /**
     * シングルトンの取得
     *
     * @return GRN_Workflow_PathStepDataUsers
     */
    public static function getInstance()
    {
        static $_instance = null;
        if (is_null($_instance)) {
            $_instance = new GRN_Workflow_PathStepDataUsers();
        }

        return $_instance;
    }

    /**
     * コンストラクタ
     */
    function __construct()
    {
        $this->_columns_info = [
            'necessary' => [
                'col_path_step_data',
                'col_user',
                'col_display_name',
                'col_foreign_key'
            ],
            'usual'     => [
                'col_result',
                'col_ptime',
                'col_comment'
            ]
        ];

        $this->_aliases = [
            'tab_grn_workflow_pathstepdata'     => 'a',
            'tab_grn_workflow_pathstepdatauser' => 'b',
            'tab_cb_user'                       => 'c'
        ];

        parent::__construct('tab_grn_workflow_pathstepdatauser');
    }

    function _formatColumnsSetNull(
        $table_infos,
        $table_aliases,
        $set_null_columns
    ) {
        $cb_user = $table_aliases['tab_cb_user'];
        $values = [];
        foreach ($table_infos as $table_name => $column_infos) {
            $table_alias = $table_aliases[$table_name];
            foreach ($column_infos as $column_name => $column_alias) {
                if (isset($set_null_columns[$table_name][$column_name])) {
                    $values[$column_alias]
                        = sprintf('CASE WHEN %s.col_deleted IS NULL THEN %s.%s END AS %s',
                        $cb_user, $table_alias, $column_name, $column_alias);
                } else {
                    $values[$column_alias]
                        = "{$table_alias}.{$column_name} AS {$column_alias}";
                }
            }
        }

        return implode(',', $values);
    }

    function &get(
        $path_step_data_id,
        $user_id,
        $columns,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {

        cb_trim_check($path_step_data_id, E_GRN_WRKF_INVALID_PATH_STEP_DATA_ID);
        cb_trim_check($user_id, E_GRN_WRKF_INVALID_USER_ID);

        $condition = cb_queryf($this->_dbconn, "_id='@S'", $path_step_data_id);
        $join_key = ['col_user', 'col_agent_user'];
        $rows = $this->_selectRecordsLeftJoinUser($columns, '_id', 0, 1,
            null, $condition, $lock, $join_key);

        $ret = false;
        if (array_key_exists($path_step_data_id, $rows)) {
            $ret = $rows[$path_step_data_id];
        }

        return $ret;
    }

    function getListByPathStepDataIds(
        $psids,
        $columns = null,
        $offset = 0,
        $limit = -1,
        $lock = CB_DATABASE_DEFAULT_LOCK
    ) {
        if ( ! is_array($columns) || 0 == count($columns)) {
            assert('FALSE');
        }

        $condition = null;
        foreach ($psids as $key => $value) {
            $psids[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
        }
        $psids = implode(',', $psids);
        $condition = "b.col_path_step_data IN($psids)";

        $set_null_columns = [
            'tab_grn_workflow_pathstepdatauser' => ['col_user' => 'col_user'],
            'tab_cb_user'                       => [
                '_id'              => '_id',
                'col_display_name' => 'col_display_name',
                'col_position'     => 'col_position',
                'col_valid'        => 'col_valid'
            ]
        ];
        $columns = $this->_formatColumnsSetNull($columns,
            $this->_aliases, $set_null_columns);
        $columns .= ',CASE WHEN ac.col_deleted IS NULL THEN b.col_agent_user END AS col_agent_user';
        $from
            = 'tab_grn_workflow_pathstepdatauser AS b FORCE INDEX (idx_psd_p_u) LEFT JOIN tab_cb_user AS c ON b.col_user=c._id';
        $from .= '  LEFT JOIN tab_cb_user AS ac ON b.col_agent_user=ac._id';
        $order_by = 'b.col_path_step_data,b.col_position,b.col_user';
        $query
            = "SELECT {$columns} FROM {$from} WHERE {$condition} ORDER BY {$order_by}";
        $query = $this->_dbconn->select_format($query, $offset,
            $limit, $lock);
        $result = $this->_dbconn->query($query);
        if (false === $result) {
            $this->_dbconn->throwError(['query' => "failed query on SELECT: {$query}"]);
        }

        $rows = [];
        while ($row = $this->_dbconn->fetch_assoc($result)) {
            $rows[$row['pid']] = $row;
        }

        return $rows;
    }

    function modify($path_step_data_user_id, $properties)
    {
        cb_trim_check($path_step_data_user_id,
            E_GRN_WRKF_INVALID_TRANSACTOR_ID);

        if ( ! is_array($properties) || 0 == count($properties)) {
            assert('FALSE');
        }

        $condition = cb_queryf($this->_dbconn, "_id='@S'",
            $path_step_data_user_id);
        $this->_updateRecords($condition, $properties);
    }

    /**
     * 経路ステップデータユーザーを変更
     *
     * @param   int   $path_step_data_id 経路ステップデータID
     * @param   int   $user_id           ユーザーID
     * @param   array $properties        プロパティ一覧（カラム名とプロパティ）
     */
    function modifySpecific($path_step_data_id, $user_id, $properties)
    {
        cb_trim_check($path_step_data_id, E_GRN_WRKF_INVALID_PATH_STEP_DATA_ID);
        cb_trim_check($user_id, E_GRN_WRKF_INVALID_USER_ID);

        if ( ! is_array($properties) || 0 == count($properties)) {
            assert('FALSE');
        }

        $condition = cb_queryf($this->_dbconn,
            "col_path_step_data='@S' AND col_user='@S'", $path_step_data_id,
            $user_id);
        $this->_updateRecords($condition, $properties);
    }

    /**
     * 経路ステップデータユーザーを変更 （_id を直接指定）
     *
     * @param   int   $pathstepdatauser_id 経路ステップデータユーザーID
     * @param   array $properties          プロパティ一覧（カラム名とプロパティ）
     */
    function modifySpecificByPsduId($pathstepdatauser_id, $properties)
    {
        cb_trim_check($pathstepdatauser_id, E_GRN_WRKF_INVALID_TRANSACTOR_ID);

        if ( ! is_array($properties) || 0 == count($properties)) {
            assert('FALSE');
        }

        $condition = cb_queryf($this->_dbconn, "_id='@S'",
            $pathstepdatauser_id);
        $this->_updateRecords($condition, $properties);
    }

    function removeList($psduids = null)
    {
        if (is_array($psduids) && 0 < count($psduids)) {
            foreach ($psduids as $key => $value) {
                cb_trim_check($value, E_GRN_WRKF_INVALID_TRANSACTOR_ID);
                $psduids[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
            }
            $psduids = implode(',', $psduids);
            $condition = "_id IN (${psduids})";
        }

        $this->_deleteRecords($condition);
    }

    /**
     * 経路ステップデータユーザーを一括削除
     *
     * @param   int   $path_step_data_id    経路ステップID
     * @param   mixed $uids                 （特定の）ユーザーを一括削除する場合はユーザーIDの配列
     *                                      それ以外の場合はすべて削除
     */
    function removeSpecificList($path_step_data_id, $uids = null)
    {
        cb_trim_check($path_step_data_id, E_GRN_WRKF_INVALID_PATH_STEP_DATA_ID);

        $condition = cb_queryf($this->_dbconn, "col_path_step_data='@S'",
            $path_step_data_id);
        if (is_array($uids) && 0 < count($uids)) {
            foreach ($uids as $key => $value) {
                cb_trim_check($value, E_GRN_WRKF_INVALID_USER_ID);
                $uids[$key] = cb_queryf($this->_dbconn, "'@S'", $value);
            }
            $uids = implode(',', $uids);
            $condition = "({$condition}) AND (col_user IN (${uids}))";
        }

        $this->_deleteRecords($condition);
    }
}


