[[概要|section:abstract]]
メールライブラリは国際化に対応したメールの送受信、作成、解析機能を提供します。
 ライブラリを使用するユーザーは各国の文字コードを意識せずにメールを作成できます。

[[設計|section:design]]
このライブラリでは、メール構造をそのまま利用できることと、利用者の手間を省くことを目標としました。
 ライブラリAPIはメーラーのユースケースから検討しています。

[[ユースケース|head:]]

メール作成時
#任意の言語のメールアドレスでFrom/To/Cc/Bcc/etc..を設定できる
#任意の言語のメールアドレスで本文を設定できる
#ユーザーはファイルを添付できる
#新しいヘッダを追加できる

メール送信時
#メールを1通送信できる
#メールを複数連続して送信できる
#エラーコードを確認できる
#エラーメッセージを確認できる
#ログを確認できる
#指定した国に適切なchar-setで送信できる

メール受信時
#メールの数を確認できる
#未読のメールを確認できる
#全てのメールを受信できる
#受信するメールを指定できる
#メールのサイズを確認できる
#サーバーからメールを削除できる
#エラーコードを確認できる
#エラーメッセージを確認できる
#ログを確認できる

メール受信後
#From/To/Cc/Bcc/etc..を確認できる
#本文を確認できる
#添付ファイルを確認できる
#メールソースを確認できる
#日付を確認できる


[[キャラクタ・エンコーディングの指定|head:]]
メールライブラリでは直接文字コードを扱うのではなく、[[ロケールコード|doc:dev/guideline/i18n/locale]]で指定します。
メールライブラリがロケールにあった文字コードを選択します。
日本語(ja)では、ISO-2022-JPが選択されます。

[[添付ファイルの転送エンコーディング|head:]]
メールライブラリは、添付ファイルを転送するためにバイナリをテキストにエンコーディングします。
デフォルトでbase64が使われますが、オプションでquoted-printableまたはuuencodeを使うことができます。
また、UTF-8のテキストファイルの転送エンコーディングはロケールによって固定されており、日本語ではbase64で、欧文ではquotes-printableが使われます。

[[キャラクタ・エンコーディングの自動認識|head:]]
メールライブラリはメールのキャラクタ・エンコーディングを認識する時に、mbstringで設定されたデフォルトの認識順序を使わず、
独自の順序で認識します。
この順序は、common.iniファイルの[Mail]セクションのmail_encoding_orderで設定されます。

[[軽量コンテナ|head:]]
実装の変更ができるよう、軽量コンテナを採用しました。送受信の実装部分は簡単に変更できます。

[[クラス構成|section:class]]
クラスは大きく分けて''コア''、''メッセージ''、''実装''に分類されます。''実装''は各プロトコルの具象クラスです。
 実装クラスは軽量コンテナで管理されているため、ユーザーが直接インスタンスを作成することはありません。

[[html]]
<table class="cb_doc_table" border="1">
 <tr>
  <th>分類</th>
  <th>クラス名</th>
  <th>役割と機能</th>
 </tr>

 <tr>
  <td nowrap rowspan="5">コア</td>
  <td nowrap>[[az:fw.mail:CB_MailErrorListener]]</td>
  <td>
   エラーを取得するリスナーのインタフェース<br>
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailService]]</td>
  <td>
   接続/切断を定義するインタフェース<br>
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailSender]]</td>
  <td>
   送信のためのインタフェースを定義する<br>
   [[az:fw.mail:CB_MailMessage]]を受け取り、送信処理を行う。
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailStore]]</td>
  <td>
   メールドロップホストのインタフェースを定義する<br>
   メールボックス内のメールの操作は[[az:fw.mail:CB_MailFolder]]を使用する。
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailFolder]]</td>
  <td>
   メールボックスのインタフェースを定義する
  </td>
 </tr>

 <tr>
  <td nowrap rowspan="8">メッセージ</td>
  <td nowrap>[[az:fw.mail:CB_MailComposer]]</td>
  <td>
  [[az:fw.mail:CB_MailComposer]]を作成するクラス<br>
  メッセージを作成する場合はこのクラスを使用する。
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailParser]]</td>
  <td>
  メールソースを解析し、[[az:fw.mail:CB_MailMessage]]を作成するクラス<br>
  既存のメールソースを解析する場合はこのクラスを使用する。
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailMessage]]</td>
  <td>
  メールメッセージを表すクラス<br>
  直接インスタンス化はせず、[[az:fw.mail:CB_MailComposer]]、[[az:fw.mail:CB_MailParser]]、[[az:fw.mail:CB_MailFolder]]から得る。
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailPart]]</td>
  <td>
  メールパートのインタフェースを定義する
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailSinglePart]]</td>
  <td>
  メールパートの具象クラス
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailMultiPart]]</td>
  <td>
  マルチパートの具象クラス
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailHeader]]</td>
  <td>
  メールヘッダーを表現するクラス
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailAddress]]</td>
  <td>
  名前とメールアドレスを表現するクラス
  </td>
 </tr>

 <tr>
  <td nowrap rowspan="13">実装</td>
  <td nowrap>[[az:fw.mail:CB_MailLazyMessage]]</td>
  <td>
  最初に読み込みアクセスが行われるまでサーバーからデータを取得しない、
  怠惰な動作を実装するためのメッセージクラス<br>
  POP3、IMAPの実装で使用される。
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailSMTPSenderBase]]</td>
  <td>
   SMTPに共通する操作を実装した[[az:fw.mail:CB_MailSender]]のサブクラス<br>
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailSMTPSender_Transactional]]</td>
  <td>
   トランザクションをサポートする[[az:fw.mail:CB_MailSMTPSenderBase]]の具象クラス<br>
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailSMTPSender_NotTransactional]]</td>
  <td>
   トランザクションを無視する[[az:fw.mail:CB_MailSMTPSenderBase]]の具象クラス<br>
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailSMTPProtocol]]</td>
  <td>
   SMTPプロトコルハンドラ<br>
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailPOP3Store]]</td>
  <td>
   POP3を実装した[[az:fw.mail:CB_MailStore]]の具象クラス<br>
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailPOP3Folder]]</td>
  <td>
   POP3を実装した[[az:fw.mail:CB_MailFolder]]の具象クラス<br>
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailPOP3Message]]</td>
  <td>
   POP3を実装した[[az:fw.mail:CB_MailMessage]]の具象クラス<br>
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailPOP3Protocol]]</td>
  <td>
   POP3プロトコルハンドラ<br>
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailIMAPStore]]</td>
  <td>
   IMAPを実装した[[az:fw.mail:CB_MailStore]]の具象クラス<br>
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailIMAPFolder]]</td>
  <td>
   IMAPを実装した[[az:fw.mail:CB_MailFolder]]の具象クラス<br>
  </td>
 </tr>

 <tr>
  <td nowrap>[[az:fw.mail:CB_MailIMAPMessage]]</td>
  <td>
   IMAPを実装した[[az:fw.mail:CB_MailMessage]]の具象クラス<br>
  </td>
 </tr>
 
 <tr>
  <td nowrap>[[az:fw.mail:CB_MailIMAPProtocol]]</td>
  <td>
   IMAPプロトコルハンドラ<br>
  </td>
 </tr>

</table>
[[/html]]

[[チュートリアル|section:tutorial]]

[[メールを送信する|head:]]
まず、[[az:fw.mail:CB_MailComposer]]のインスタンスを作成し、From,To等の情報を追加します。
 
[[src]]
<?php

// シンプルなテキストメールを作成する
$cp = new CB_MailComposer();

$cp->setFrom( new CB_MailAddress('taro@hoge.jp') );
$cp->addTo( new CB_MailAddress('hanako@fuga.jp') );

$subject = 'サンプルメール';
$cp->setSubject( mb_convert_kana($subject) );

$text = '日本語の文章';
$cp->setTextBody( mb_convert_kana( $text ) );

?>
[[/src]]

メールアドレスとしてCB_MailAddressクラスのオブジェクトを渡します。
上の例では省略してありますが、以下のように2番目の引数に名前を設定することもできます。

[[src]]
$cp->setFrom( new CB_MailAddress('taro@hoge.jp', '山田太郎') );
[[/src]]

日本語のメールではISO-2022-JPエンコーディングが使われます。
ISO-2022-JPではいわゆる「半角カタカナ」を扱うことができないため、テキストに半角カタカナが含まれる可能性がある場合は、mb_convert_kana関数を使って全角に変換してください。

作成したメッセージを送信するために、[[az:fw.mail:CB_MailSender]]のインスタンスを取得します。
 SMTPプロトコル実装の識別子は''mail_smtp''です。
 
[[src]]
<?php

// CB_MailSenderオブジェクトの取得
$mt =& $G_container_base->getInstance( 'mail_smtp' );

?>
[[/src]]

上記で作成した[[az:fw.mail:CB_MailSender]]オブジェクトを使ってメッセージを送信します。
[[az:fw.mail:CB_MailComposer]]から出来上がったメッセージを取得するには''CB_MailComposer::getMailMessage()''を使用します。

[[src]]
<?php

// 接続情報の設定
$conn_info = array();

// ホスト名
$conn_info['hostname']   = 'localhost';
$conn_info['auth']   = 'none';

// 作成したCB_MailMessageオブジェクトの取得
$msg = $cp->getMailMessage();

// 送信するメールを指定
$msgs = array();
$msgs[] =& $msg;

if ($mt->connect( $conn_info ) === false) {
 // 接続に失敗
}

// メールの送信
$ret_num = $mt->sendMails( $msgs, 'ja');

// コミット
$mt->commit();

?>
[[/src]]

''CB_MailSender::connect()''の接続情報には次のパラメータが含まれます。

[[html]]
<table class="cb_doc_table" border="1">
 <tr>
  <th>名前</th>
  <th>説明</th>
  <th>デフォルト</th>
 </tr>

 <tr>
  <td nowrap>hostname</td>
  <td>
   接続先のホスト名。
  </td>
  <td>
    localhost
  </td>
 </tr>

 <tr>
  <td nowrap>domain</td>
  <td>
   クライアントのドメイン名。
   これは、SMTPのHELOコマンドおよびDIGEST-MD5認証に使われます。
   通常は省略しても構いませんが、複数ドメインで運用されるメールサーバーでDIGEST-MD5認証を行う場合は必要です。
   また、Sendmailなどサーバーがドメイン名(realm)を通知しないDIGEST-MD5認証ではデフォルトのドメイン名として使われます。
  </td>
  <td>
    localhost
  </td>
 </tr>

 <tr>
  <td nowrap>port</td>
  <td>
   接続先のポート番号。
  </td>
  <td>
   メール送信プロトコルのデフォルトポート番号（SMTPでは25）。
  </td>
 </tr>

 <tr>
  <td nowrap>uid</td>
  <td>
   ユーザーID。
  </td>
  <td>
   空文字列。
  </td>
 </tr>

 <tr>
  <td nowrap>password</td>
  <td>
   パスワード。
  </td>
  <td>
   空文字列。
  </td>
 </tr>

 <tr>
  <td nowrap>auth</td>
  <td>
   認証方法。
  </td>
  <td>
   認証無し（"NONE"）。
  </td>
 </tr>

 <tr>
  <td nowrap>timeout</td>
  <td>
   接続タイムアウト（秒）。
  </td>
  <td>
    30秒
  </td>
 </tr>
</table>
[[/html]]

認証方法（auth）は"LOGIN","PLAIN","CRAM-MD5","DIGEST-MD5","NTLM"がサポートされています。
"NONE"を指定した場合は認証を行いません。
また、"AUTO"を指定すると、自動的に認証方法が選択されます（LOGINやPLAINなどネットワーク上にパスワードが流れる認証を避けたい場合は推奨しません）。
なお、認証方法名は大文字小文字を区別しません。

CB_MailSender::sendMails()メソッドは複数のメールを送信できます。
トランザクションを無視する実装[[az:fw.mail:CB_MailSMTPSender_NotTransactional]]では即座にメールが送信されます。
エラーがあった場合は送信を中断し、実際に送信されたメールの数が戻り値となります。
トランザクション対応の実装[[az:fw.mail:CB_MailSMTPSender_Transactional]]ではメールの送信が予約され、予約されたメールの数が戻り値となります。
この際、実際にメールが送信されるのは、''CB_MailSender::commit()''が呼び出された時です。

CB_MailSender::sendMails()メソッドの2番目の引数は[[ロケールコード|doc:dev/guideline/i18n/locale]]です。
メールライブラリは指定されたロケールコードにあったエンコードを用いて送信します。
日本(ja)の場合はISO-2022-JPです。ただし、作成したメールに既定のエンコーディングで利用できない文字が存在する場合はUTF-8で送信します。

[[エラーメッセージ|head:]]
[[az:fw.mail:CB_MailService]]のサブクラスでは[[az:fw.mail:CB_MailErrorListener]]を使ってエラーメッセージを受け取ることができます。
デフォルトでは、何もしないエラーリスナーが設定されていますが、''CB_MailService::setErrorListener()''メソッドでユーザーのエラーリスナーに変更することができます。

[[src]]
<?php

// ユーザーのエラーリスナーの定義
class My_ErrorListener extends CB_MailErrorListener
{
    function error( $errno, $msg )
    {
      echo "Code: $errorno, Message:$msg\n";
    }
}

// CB_MailSenderオブジェクトの取得
$mt =& $G_container_base->getInstance( 'mail_smtp' );

// エラーリスナーの設定
$mt->setErrorListener( new My_ErrorListener() );

?>

$errnoが正の場合は、サーバーによって返されたプロトコルエラーを表します。
SMTPではエラーコードになりますが、IMAP、POP3にはエラーコードがないため、常に1となります。
このとき、$msgにはサーバーによって返されたテキストがそのままの形で入ります。

$errnoが-1の場合は、ネットワークの入出力エラーなどクライアント側で発生したエラーを表します。
$msgには人間が読むことができるエラーメッセージが入ります。

[[/src]]

[[メールを受信する|head:]]
まず、[[az:fw.mail:CB_MailStore]]のインスタンスを作成し、接続情報を設定します。
POP3で接続する場合はmail_pop3を、IMAPで接続する場合はmail_imapを指定します。
''CB_MailStore::connect()''メソッドの引数の接続情報はCB_MailSenderと同様ですが、POP3、IMAPでは認証は必須です。
認証方法に"NONE"を選択することはできません。

POP3の認証方法は、"USER","APOP","LOGIN","PLAIN","CRAM-MD5","DIGEST-MD5"がサポートされています。

IMAPの認証方法は、"USER","LOGIN","PLAIN","CRAM-MD5","DIGEST-MD5"がサポートされています。

[[src]]
<?php

// CB_MailStoreオブジェクトの取得
$ms =& $G_container_base->getInstance( 'mail_pop3' );

$conn_info['hostname']   = SAMPLE_HOST;

$conn_info['port']       = CB_MAIL_PORT_POP3;

// ユーザーIDとパスワード
$conn_info['uid']        = SAMPLE_USER;
$conn_info['password']   = SAMPLE_PASS;

//$conn_info['auth']   = 'APOP';

?>
[[/src]]

CB_MailStore::connect()メソッドでメールストアへ接続し、メールフォルダを取得します。
[[az:fw.mail:CB_MailFolder]]のインスタンスはCB_MailStore::getDefaultFolder()メソッドで取得できます。

[[src]]
<?php
// メールストアへ接続
if ($ms->connect( $conn_info ) === false) {
 // エラー処理
}

// フォルダの取得
if (($folder =& $ms->getDefaultFolder()) === false) {
 // エラー処理
}

?>
[[/src]]

[[az:fw.mail:CB_MailFolder]]の持つメソッドで、フォルダ内のメールのサイズと数を取得できます。

[[src]]
<?php
// フォルダ内のメールの数を取得
$cnt = $folder->getMessageCount();

for( $i=1; $i<=$cnt; $i++ ){
    // メッセージの取得
    if (($msg = $folder->getMessage($i)) === false) {
      // エラー処理
    }

    // メッセージのサイズの取得
    if (($size = $folder->getMessageSize($i)) === false) {
      // エラー処理
    }

    // メッセージの削除
    if ($folder->deleteMessage($i) === false) {
      // エラー処理
    }
}
?>
[[/src]]

メールの取得はCB_MailFolder::getAllMessages()によっても可能です。

[[src]]
<?php
// 全てのメールを取得
$msgs = $folder->getAllMessages();

foreach( $msgs as $msg ){
    // メッセージのサイズの取得
    if (($size = $msg->getSize($i)) === false) {
      // エラー処理
    }
}
?>
[[/src]]

ただし、メモリの使用量の面から、大量のメールを扱う場合は前者の方法を推奨します。

[[未読メールを扱う|head:]]
ライブラリは新しくサーバーに届いたメールを未読メールとして管理します。未読メールを扱う場合は次の3つのメソッドを使います。
 CB_MailFolder::getUnseenMessageNumbers()メソッドは未読メールの番号を配列として返します。
 CB_MailFolder::getNextUnseenMessage()メソッドは未読メールを1通ずつ取り出し、メッセージIDと[[az:fw.mail:CB_MailMessage]]を配列として返します。
 CB_MailFolder::deleteSeenMessages()メソッドは既読メールをメールサーバーから削除します。ここでいう既読メールとはCB_MailFolder::getNextUnseenMessage()メソッドで取得したメールを指します。CB_MailFolder::getMessage()メソッドで取得したメールは既読メールにはなりません。
 getNextUnseenMessage()で取得したあと、メールサイズが大きい等の理由で
メールを未読状態へ戻す場合、CB_MailFolder::setUnseen()メソッドを使用し
てください。このメソッドは指定されたメールを未読状態へ戻します。
 また、CB_MailFolder::deleteMessage()メソッドで削除した場合、管理が正
しく動作しない可能性があります。削除する場合は
CB_MailFolder::deleteSeenMessages()メソッドを使用してください。
 CB_MailStoreはトランザクション管理された実装を提供することができます。
実際には、''CB_MailStore::commit()''メソッドが呼ばれるまではメールは削除されません。
また、メールの未読・既読状態もトランザクション管理されます。
すなわち、''CB_MailStore::commit()''メソッドが呼ばれないままプログラムが終了すると、メッセージの既読・未読状態が保存されません。

[[メールの削除|head:]]
受信後、メールフォルダ内のメールを削除する場合は、次のメソッドを使用します。

[[src]]
<?php
// 指定したメールの削除
$folder->deleteMessage( $msgnum );
// 全てのメールの削除
$folder->deleteAllMessages();
?>
[[/src]]

[[src]]
<?php
// フォルダの取得
$folder =& $ms->getDefaultFolder();
$cnt = $folder->getMessageCount();

// 未読メールの数を取得
$unseen_num = $folder->getUnseenMessageNumbers();
echo '受信フォルダ内のメッセージ数 = '.$cnt.'通（ 新着: '.count($unseen_num).'通 ）<br>';

if ( !count($unseen_num) ){
    echo '新着メールはありません。';
}
else{
    // 未読メールを取得します。
    while( !is_null( $retval = $folder->getNextUnseenMessage() ) )
    {
        $msg =& $retval['message'];
        $id  =  $retval['id'];
        // メールの処理
    }

//未読メールを削除する
$folder->deleteSeenMessages();
?>
[[/src]]

[[メールの内容へのアクセス|head:]]
CB_MailFolder::getMessage()、CB_MailFolder::getAllMessages()メソッドは[[az:fw.mail:CB_MailMessage]]を返します。[[az:fw.mail:CB_MailMessage]]はメールメッセージを表現するクラスです。
ヘッダーの取得用のメソッドは大きく分けて、2種類あります。全体を取得するものと、各ヘッダーを取得するものです。
ヘッダの値がアドレスのリストであるもの(getFrom,getTo,getCc,getBcc,getReplyTo)は、CB_MailAddressの配列を返します。
getSenderは1つのCB_MailAddressを返し、getSubjectは件名の文字列を返します。

[[src]]
<?php
    // 全てのヘッダーを取得
    $headers = $msg->getAllHeaders();

    // 各ヘッダーを取得
    $from = $msg->getFrom();
    $to = $msg->getTo();
    $cc = $msg->getCc();
    $subject = $msg->getSubject();
?>
[[/src]]

ボディは対象のメールがシングルパートかマルチパートによって処理が異なります。
CB_MailMessage::getAttachedParts()メソッドでパートの数を確認できます。

[[src]]
<?php
    /*
     * 追加されたマルチパートを取得します
     * 戻り値は配列です。
     */
    $parts = $msg->getAttachedParts();

    // 各ヘッダーを取得
    if(  ! count($parts) ){
        $main_part = $msg->getMainPart();
        echo $main_part->getContent();
    }
    else{
        /*
         * 配列に要素がある場合はマルチパートです。
         * getContent()で各パートのデータを取得できます。
         */
        if( $part->getFilename() ){
            echo $part->getFilename();
            /*
             * サンプルでは添付ファイルは非表示です。
             * ファイルなどへ保存してください。
             * $part->getContent();
             */
        }
        else{
            // getContent()でContent-Typeを取得します。
            if ( strncasecmp( $part->getContentType(), 'text/', 5 ) == 0 ){
                echo $part->getContent();
            }
            /*
             * 'message/rfc822'の場合
             */
            elseif( strcasecmp( $part->getContentType(), 'message/rfc822' ) == 0 ){
	        $body =& $part->getContent();
                $msg =& CB_MailParser::static_parse($body);

                // 添付されたメールの情報を取得します
                $addr =& $msg->getFrom();
                echo $addr->address;
                echo $msg->getSubject();
            }
        }
    }
?>
[[/src]]

マルチパートの場合、Content-Typeに注意してください。メールが添付されている場合、CB_MailMessage::getContent()メソッドはCB_MailMessageオブジェクトを返します。

[[メールのキャラクタ・エンコーディング|head:]]
メールの内容やヘッダにアクセスするためのメソッドは、デフォルトではメールに含まれるキャラクタ・エンコーディング情報
(RFC-2047、RFC-2231およびContent-Typeのcharsetパラメータ)をもとに、テキストを認識しています。
また、キャラクタ・エンコーディング情報が不明なテキストは自動認識に頼っています。

しかし、誤ったキャラクタ・エンコーディング情報が含まれるメールがしばしばあります(ISO-2022-JPとなっているに、実際のエンコーディングはSJISが使われている場合など)。
そのようなメッセージを読むために、[[az:fw.mail:CB_MailMessage]]にはキャラクタ・エンコーディングを強制指定するメソッドが用意されています。

キャラクタ・エンコーディングを強制指定するためには、setForceEncodingメソッドを呼び出します。

[[src]]
<?php
    // $msgは受信したメッセージ

    // デフォルトのエンコーディングで送信者名を取得する
    $from = $msg->getFrom();
    $sender_name = $from[0]->name;
    
    // 件名をSJISとして認識する
    $msg->setForceEncoding('SJIS');
    $subject = $msg->getSubject();
    
    // キャラクタ・エンコーディング情報で内容を認識する
    $msg->setForceEncoding(null);
    $main_part = $msg->getMainPart();
    $content = $main_part->getContent();
?>
[[/src]]

エンコーディング名に"auto"を指定すると、キャラクタ・エンコーディング情報を無視して、常に自動認識が使われるようになります。
また、setForceEncodingにnullを渡すことでデフォルトの認識方法に戻ります。

[[HTMLメール|head:]]
メールライブラリは、単純なHTMLメールと、HTMLとテキストの両方を含んだメールを作成することができます。
単純なHTMLメールを作るには、テキストメールを作成する場合に用いたsetTextBodyの代わりにsetHtmlBodyを用います。

[[src]]
<?php

// HTMLメールを作成する
$cp = new CB_MailComposer();

...省略...

$html = <<<EOD
  <html>
    <head>
      <title>HTML文書</title>
      <body>
        <p>本文</p>
      </body>
  </html>
EOD;
$cp->setHtmlBody( $html );

?>
[[/src]]

また、setTextBodyとsetHtmlBodyの両方を使うことで、1つのメールにHTMLとテキストの両方を含めることができます。

[[src]]
<?php

// HTMLメールを作成する
$cp = new CB_MailComposer();

...省略...

$html = <<<EOD
  <html>
    <head>
      <title>HTML文書</title>
      <body>
        <p>本文</p>
      </body>
  </html>
EOD;
$cp->setHtmlBody( $html );
$cp->setTextBody( "本文" );

?>
[[/src]]

こうして作成されたメールには、multipart/alternativeコンテンツタイプとして、HTMLとテキストの両方が含まれます。
このメールをユーザーが受け取ると、多くのメールクライアントではHTMLとテキストのいずれかを選んで表示することが出来ます。
例えば、ユーザーがHTMLの表示を拒否している場合は、テキストだけが表示されます。

HTMLとテキストの両方を含むメールを受信した場合は、CB_MailMessageのgetMainPartはCB_MailMultipart型のオブジェクトを返します。
以下はHTMLメールを処理するコードのサンプルです。

[[src]]
<?php

// $msg: 受信したメール
$part =& $msg->getMainPart();

if (is_a($part, 'CB_MailMultipart')) {
  // HTML,テキストが混在したメール
  $parts =& $part->getMailParts();
  for ($i = 0; $i < count($parts); ++$i) {
    if (strcasecmp($parts[$i]->getContentType(), 'text/plain') == 0) {
      // テキストを処理する
    }
    else if (strcasecmp($parts[$i]->getContentType(), 'text/html') == 0) {
      // HTMLを処理する
    }
  }
}
else {
  // 普通のメールとして処理する
}

?>
[[/src]]

また、HTML以外にWord文書などを含むメールも同様に処理することができます。

[[添付ファイル|head:]]

ファイルを添付するには、以下のようにCB_MailComposerのaddAttachFileを使います。

[[src]]
<?php
 // $comp CB_MailComposer
 // $data ファイルの中身(string)
 $filename = 'ファイル名';
 $content_type = 'application/octet-stream';
 
 $comp->addAttachFile($filename, $data, $content_type);
?>
[[/src]]

これで、$filenameに指定されたファイル名で$dataの内容を持つファイルがメールに添付されます。
$content_typeはメールクライアントがファイルの種類を判断するためのMIMEタイプです。
例えば、JPEG画像であればimage/jpeg、mp3音声であればaudio/mp3という様に指定します。
application/octent-streamは、全てのバイナリファイルに使うことができるMIMEタイプです。

MIMEタイプがmessage/rfc822である場合は、常に7bitのメッセージデータとして扱われます。
通常、メッセージを添付する場合は以下のようにaddAttachMessageを使います。

[[src]]
<?php
 $comp = new CB_MailComposer();
 $comp->setSubject("添付メール");
 $comp->setTextBody("このメッセージを添付します。");
 $message = $comp->getMailMessage();

 $comp = new CB_MailComposer();
 $comp->setSubject("添付したメール");
 $comp->setFrom(new CB_MailAddress("hoge@hoge.net"));
 $comp->setTextBody("このメッセージにはメッセージが添付されています。");
 $comp->addAttachMessage($message);
 $message = $comp->getMailMessage();
?>
[[/src]]

addAttachFileで直接メッセージデータを添付する場合は、base64等でエンコードされず、そのまま内容として添付されるため、
データが7bitのメッセージデータとして正当なものであることを確認してください。
そうでない場合は、application/octet-streamとして添付することで安全に転送できます。

受信メールを処理する際は、テキスト以外のパート、またはContent-Dispositionヘッダまたはファイル名が含まれるパートが添付ファイルと見なされます。
すなわち、メール本文のテキストおよびその代替(multipart/alternative)として含まれるHTMLなどのパートは添付ファイルに含まれません。
以下のコードは、メールに含まれる全ての添付ファイルを処理します。

[[src]]
<?php

// $msg: 受信したメール
$attachments =& $msg->getAttachedParts();

for ($i = 0; $i < count($attachments); ++$i) {
  $part =& $attachments[$i];
  //添付ファイルを処理する
}

?>
[[/src]]

メールライブラリが対応しているファイルの添付形式は、base64,quoted-printable,BinHex4.0,uuencode,xxencodeです。
uuencode,xxencodeは、メール本文に貼り付けられたものも添付ファイルとして取得することができます。
ただし、メールライブラリはメール本文にテキストとして貼り付けられたデータを削除しません。

[[サーバーの接続確認|head:]]
サーバーがSMTP,POP,IMAPの各サービスを提供しているか確認する場合は[[az:fw.mail:CB_MailService]]のisAvailableメソッドを使用します。

[[src]]
<?php
    $ms =& $G_container_base->getInstance( 'mail_pop3' );
    $conn_info = array();
    $conn_info['hostname'] = SAMPLE_HOST;
    $conn_info['auth'] = 'NONE';

    if( !$mt->isAvailable($conn_info) ){
        die('Error: Check mail server or conn_info');
    }
?>
[[/src]]

[[設計・実装上の注意点|section:rationale]]

[[メールのソースの取得|head:]]
[[az:fw.mail:CB_MailMessage]]のgetSourceDataメソッドは、[[az:fw.mail:CB_MailComposer]]によって作られたメッセージと、
それ以外のメッセージとでは意味合いが異なります。

[[az:fw.mail:CB_MailComposer]]によって作成されたメッセージでは、getSourceDataメソッドは毎回データを生成します。
この際、与えられたロケールとバイナリ・エンコーディングに従います。

その他のメッセージでは、getSourceDataの引数は無視され(引数を省略することができる)、オリジナルのメッセージのソースデータが常に返されます。

[[az:fw.mail:CB_MailComposer]]によって作成されたメッセージ以外は「リードオンリー」です。
内部的にはデコード前のオリジナルのデータが保持されており、読み込みアクセス毎にデコードされます。

[[RFC-2231への準拠|head:]]
メールライブラリはRFC-2231に準拠したファイル名をデコードすることができます。
ただし、ファイル名をエンコードする際はRFC-2231に従わず、Subjectヘッダなどと同様の形式で非ASCII文字をエンコードします。
これは、Outlook Express等の主要なメーラーがRFC-2231のデコードに対応していないためです。

また、メールライブラリはRFC-2231に従っていないファイル名も可能な限りデコードします。
Subjectヘッダなどと同様の形式と、ISO-2022-JPやSJISが直接使われている形式にも対応しています。

[[マッキントッシュのファイル|head:]]
apple single/doubleはマッキントッシュのファイル添付形式で、マックバイナリ（マッキントッシュ特有のヘッダ情報）を含んでいます。
ファイルがappledouble（ファイルのヘッダと内容を分ける形式）で添付されていた場合、メールライブラリはヘッダ情報を無視します。
よって、添付ファイルとして得られるデータはファイルの内容のみとなります。
applesingle（ファイルのヘッダと内容を一緒にする形式）で添付されていた場合は、添付ファイルとして得られるデータはヘッダ情報も含みます。

メールライブラリは、BinHex4.0形式をデコードすることができます。このとき、取得できるのはファイルの内容のみです。

[[mailparse|head:]]
MIMEメッセージの解析にはmailparseを使っています。
ただし、mailparseには機能の足りていない部分、あるいはバグがあったため、一部修正しています。

オリジナルのmailparseは2.0b（2004-03-07リリース）を使っています。
以下が修正内容です。詳細な修正箇所はdiff等のツールで確認してください。

[[html]]
<table class="cb_doc_table" border="1">
  <caption>mailparseの修正箇所</caption>
  <thead>
    <tr>
      <th>ソース</th>
      <th>修正内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>mailparse.c, php_mailparse_mime.h, php_mailparse_mime.c</td>
      <td>MimeMessage->data['row-headers']で大文字小文字を変換しないヘッダ名が得られるようにした。</td>
    </tr>
    <tr>
      <td>php_mailparse_mime.c</td>
      <td>RFC2231に従う属性の値が切れてしまうという問題があったため、
      Netscapeのための修正とされるコードをコメントアウトした。</td>
    </tr>
    <tr>
      <td>php_mailparse_mime.c</td>
      <td>MimeMessage->data['charset']のデフォルト'us-ascii'を設定しないようにした。
       これにより、charset属性が無い場合は、この値は単に設定されない。</td>
    </tr>
    <tr>
      <td>php_mailparse_mime.c</td>
      <td>メッセージの最後に改行がないと、最後の行が解析されないという問題を修正した。</td>
    </tr>
    <tr>
      <td>php_mailparse.h, mailparse.c</td>
      <td>mailparse_convert_uuencode,mailparse_mimemessage_extract_binhex,mailparse_quoted_printable_encode関数を追加した。</td>
    </tr>
    <tr>
      <td>mailparse.c</td>
      <td>uuencodeの"end"行を検出しないという問題を修正した。
      mailparse_detect_encoding,mailparse_decode_binhex関数を追加した。
      MAILPARSE_UUE_AUTO,MAILPARSE_UUE_U,MAILPARSE_UUE_X定数を追加した</td>
    </tr>
  </tbody>
</table>
[[/html]]

また、MimeMessageオブジェクトのget_childメソッドの引数が1オリジンになっている（おそらく0オリジンであるべき）という問題はそのままにしてあります。
将来のmailparseのリリースでこの問題が修正された場合、PHP側を修正する必要があります。

新に追加したmailparse_convert_uuencodeという関数は、mailparseの他の部分からは使われていません。
単にPHP5のconvert_uuencodeを代用として加えたものです。
将来PHP5に移行した場合は必要ありません。

[[mailparseソースについて|head:]]
mailparseのソースに関する情報が少ないため、開発者のためにメモを残しておきます。

mailparse.h -PHP関数定義が含まれています。

mailparse.c -MimeMessageオブジェクトの定義、PHP関数の実装などです。uuencodeの関連の実装も含まれます。

php_mailparse_mime.h -MIMEデータを表す構造体が定義されています。これはmimeparse.cでPHPオブジェクトにマッピングされます。

php_mailparse_mime.c -MIMEパーサの実装です。
  php_mimepart_process_line（MIMEの各行を解析する）、
  php_mimepart_process_header（ヘッダを解析する）、
  php_mimeheader_alloc_from_tok（ヘッダに含まれる属性を解析する）、
  php_mimepart_decoder_prepare（内容をデコードする）、
  といった関数の定義があります。

php_mailparse_rfc822.* -字句解析プログラムです。こちらでトークンに分割された後、MIMEパーサが解析するというしくみになっています。

[[リファレンス|section:source]]

[[フレームワークソース|head:]]
[[コアクラス|fw/mail_core.csp]]

[[メッセージクラス|fw/mail_message.csp]]

[[受信クラス|fw/mail_store.csp]]

[[送信クラス|fw/mail_sender.csp]]

[[実装クラス(SMTP)|fw/mail_smtp.csp]]

[[実装クラス(POP3)|fw/mail_pop3.csp]]

[[実装クラス(IMAP)|fw/mail_imap.csp]]

[[実装クラス(IMAPプロトコルハンドラ)|fw/mail_imap_protocol.csp]]


[[サンプル|head:]]
[[developer/demo_mail_send.csp]]

[[developer/demo_mail_recv.csp]]

[[developer/demo_mail_unseen.csp]]
