[[概要|section:abstract]]
[[img:developer/Libxml2-Logo-180x168.gif]]

本ライブラリはXML操作を行うAPIとして、
それぞれ
[[html]]
<a href='http://xmlsoft.org/'>Libxml2ライブラリ</a>
[[/html]]
の
[[html]]
<a href='http://xmlsoft.org/html/libxml-xmlreader.html'>xmlreaderAPI</a>
[[/html]]
および
[[html]]
<a href="http://xmlsoft.org/html/libxml-xmlwriter.html">xmlwriterAPI</a>
[[/html]]
をベースとした、CB_XMLReaderクラスとCB_XMLWriterクラスを提供します。

それぞれのクラスは以下のような機能の提供を目的として設計されています。

#ファイル、文字列バッファ、ネットワークを対象としたXMLデータの入出力
#XMLデータ入力時の構造解析
#XMLデータ入力時の妥当性検証（DTDのみサポート）
#DOMオブジェクトのデータ書き出し
#DOMオブジェクトへのデータ読み込み

[[XMLパーサ（SAX - DOM - XMLReader）|section:parser]]

構造化されたテキストデータであるXMLをアプリケーションが解析して使用するために、様々な
[[html]]
<a href="http://www.atmarkit.co.jp/aig/01xml/parser.html">XMLパーサ</a>
[[/html]]
が存在します。

XMLパーサによってAPIもまちまちですが、代表的な標準APIとして
[[html]]
<a href="http://www.atmarkit.co.jp/aig/01xml/sax.html">SAX</a>
[[/html]]
と
[[html]]
<a href="http://www.atmarkit.co.jp/aig/01xml/dom.html">DOM</a>
[[/html]]
の2つが挙げられます。

また、SAXやDOMほど広まっているわけではありませんが、
両者の欠点を補うAPIとして注目されているのが、
.NETフレームワークの
[[html]]
<a href="http://www.microsoft.com/japan/msdn/library/default.asp?url=/japan/msdn/library/ja/cpguide/html/cpconreadingxmlwithxmlreader.asp">XMLReader</a>
[[/html]]
に代表される「プルパーサ型」のAPIです。

それぞれの比較を以下の表に示します。

[[html]]
<table class="cb_doc_table">
<tr>
<th>
API名
</th>
<th>
特徴
</th>
<th>
短所
</th>
</tr>
<tr>
<td>
SAX
</td>
<td>
解析が進む度に、読み取ったデータの内容を登録されたコールバック関数に通知する。<BR>
特定のタグ以外を読み飛ばすといった処理が比較的簡単に記述でき、またその際、不必要なメモリ領域を確保したりすることがない。<BR>
</td>
<td>
どのタグに対しても同じコールバック関数が呼ばれるため、アプリケーション側でツリー構造を認識するのが難しい。<BR>
</td>
</tr>
<tr>
<td>
DOM
</td>
<td>
パース済みのツリー構造データに対し、ポイントを移動させながらデータを読み取るためのAPIを提供する。<BR>
（DOMはデータを編集するためのAPIも提供している。）<BR>
アプリケーションはツリー構造中を自由に往来しながら、データを読み取ることができる。<BR>
</td>
<td>
ツリー構造全体を保持するため、ストリーム処理ができない。<BR>
要・不要に関わらず、データ量に比例したメモリリソースを消費する。<BR>
</td>
</tr>
<tr>
<td>
XMLReader
</td>
<td colspan=2>
アプリケーションがread()等のメソッドを呼ぶ度に、部分的にパースが実行される。<BR>
（SAXのプッシュ型に対してプル型のストリームパーサ。）<BR>
アプリケーション主導でデータを読み進めていくため、構造を認識しやすい。<BR>
また、ストリームパーサなので、メモリを不必要に消費することがない。<BR>
（ただし、DOMのように往来はできない。）<BR>
</td>
</tr>
</table>
[[/html]]

以上のような比較を基に、アゼリアでは.NETフレームワークのXMLReaderを意識して作成された、
Libxml2のxmlreaderAPIをベースとして採用することにしました。

また、全体のツリーではなく、サブツリーを保持する目的として、DOMを採用いたしました。
本ライブラリは実行中のパーサからDOMオブジェクトを取得する手段を提供します。
(DOMインタフェース自体は、PHP拡張のDOMXML関数によって提供されます。)

SAXは提供いたしません。

[[CB_XMLReaderクラス（チュートリアル）|section:xmlreader]]

[[az:fw.xml:CB_XMLReader]]はXMLストリームパーサの機能を提供します。

以下のようなXMLファイル（sample.xml）が存在するとします。

[[src]]
<?xml version="1.0" encoding="utf-8" ?>

<!-- sample.xml -->

<office name="cybozu">
<person name="A"><keyword>tall</keyword></person>
<person name="B"><keyword>heavy</keyword></person>
<person name="C"><keyword>small</keyword></person>
</office>
[[/src]]

それぞれの「person」の「keyword」の内容を知るためには、以下のようなコードを作成します。

[[src]]
<?php
/**
 * demo_reader_sample.csp
 */

/**
 * 1.インスタンスの作成（空白ノードを削除）
 */
$reader = new CB_XMLReader(CB_XML_PARSE_NOBLANKS);

/**
 * 2.オープンするファイルパスを絶対パスで記述する
 */
$reader->openFile(cb_basedir().'/code/doc_root/developer/xml/sample.xml');

/**
 * XML宣言（<?xml version="1.0" encoding="utf-8" ?>）はオープン時に解析される
 */

/**
 * 3.コメントノード（<!-- sample.xml -->）へ移動
 */
$reader->read();

/**
 * 4.getValue()でコメントを取得
 */
$value = $reader->getValue();
echo "コメント:$value<BR>";

/**
 * officeタグへ移動
 */
$reader->read();

/**
 * 5.getAttribute()でname属性を取得
 */
$attr = $reader->getAttribute('name');
echo "会社名:$attr<BR>";

/**
 * 6.各personタグ毎の処理
 */
while($reader->read() && strcmp($reader->getNodeName(),"person") == 0) {
    $attr = $reader->getAttribute('name');
    echo "人名:$attr";
    
    /**
     * keywordタグへ移動
     */
    $reader->read();
    if (strcmp($reader->getNodeName(),"keyword") == 0) {
        echo " => キーワード名:";
        
        /**
         * 7.テキストノードへ移動
         */
        $reader->read();
        
        /**
         * 8.getValue()でテキスト値を取得
         */
        $value = $reader->getValue();
        echo "$value<BR>";
        
        /**
         * 9.keyword終了タグへ移動
         */
        $reader->read();
    }
    
    /**
     * person終了タグへ移動
     */
    $reader->read();
}

/**
 * 10.クローズ
 */
$reader->close();

?>
[[/src]]

[[html]]
<a href="demo_reader_sample">ブラウザ出力結果</a>
[[/html]]

[[1.インスタンスの作成（空白ノードを削除）|head:]]

コンストラクタでインスタンスを作成します。
コンストラクタでは、次の定数を|（ビット和）演算子で連結して指定し、
パーサの設定を行うことが出来ます。

[[src]]
/**
 * 外部定義DTDをロードします
 */
define( "CB_XML_PARSE_DTDLOAD",          12 );
/**
 * DTDをもとにXMLデータの妥当性を検証します
 */
define( "CB_XML_PARSE_DTDVALID",         16 );
/**
 * ERRORレベルのエラーをレポートしません
 */
define( "CB_XML_PARSE_NOERROR",          32 );
/**
 * WARNINGレベルのエラーをレポートしません
 */
define( "CB_XML_PARSE_NOWARNING",        64 );
/**
 * 空白ノード（タグ間の改行や空白）をノードとして扱いません
 */
define( "CB_XML_PARSE_NOBLANKS",        256 );
[[/src]]

サンプルコードでは、CB_XML_PARSE_NOBLANKSを指定することにより、
「重要でない」空白や改行をスキップする設定にしています。
（属性値やエレメント値に混入する空白・改行は「重要」であり、
このモードを設定していてもスキップしません。）

特に、改行やインデントなどの書式を保ったままXMLデータを処理したい場合でなければ、
この定数を指定するようにして下さい。

[[2.オープンするファイルパスを絶対パスで記述する|head:]]

ファイルパスを指定してXMLファイルを開きたい場合は、openFile()メソッドを使用します。
第一引数に絶対ファイルパスを指定します。

[[3.コメントノード（<!-- sample.xml -->）へ移動|head:]]

read()メソッドは、パースを実行し次のノードへポインタを進めます。
正常にポイントできた場合は数値1を返却します。

ポイントするノードの種類には以下のような種類があり、
getNodeType()メソッドの返却値により特定することができます。

[[src]]
/**
 * 初期状態、もしくは終了状態でノードにポイントされてない状態です
 */
define( "CB_XML_NONE",                    0 );
/**
 * エレメント開始タグ（空要素タグを含む）を表します
 */
define( "CB_XML_ELEMENT",                 1 );
/**
 * テキストデータを表します
 */
define( "CB_XML_TEXT",                    3 );
/**
 * CDATAセクションを表します
 */
define( "CB_XML_CDATA",                   4 );
/**
 * PIセクションを表します
 */
define( "CB_XML_PI",                      7 );
/**
 * コメントを表します
 */
define( "CB_XML_COMMENT",                 8 );
/**
 * DTDを表します
 */
define( "CB_XML_DOC_TYPE",               10 );
/**
 * 空白を表します
 */
define( "CB_XML_WHITESPACE",             14 );
/**
 * エレメント終了タグを表します
 */
define( "CB_XML_END_ELEMENT",            15 );
[[/src]]

[[4.getValue()でコメントを取得|head:]]

getValue()メソッドでノードの値を取得することができます。
値を持ち得るノードは、TEXT、CDATA、COMMENT、WHITESPACEです。

エレメントの値を取得する場合は、read()で1つ読み進めて、
TEXTノードにポイントしたところで実行しなければならないことに注意して下さい。

なお、値が存在しない場合にはFALSEが返却されます。

[[5.getAttribute()でname属性を取得|head:]]

getAttribute()メソッドでノードの指定した名前の属性値を取得することができます。
属性値を持ち得るノードは、ELEMENT、PIです。値が存在しない場合にはFALSEが返却されます。

getAttributes()メソッドで、全ての属性値を連想配列で取得することもできます。
値が存在しない場合は空の配列が返却されます。

[[6.各personタグ毎の処理|head:]]

getNodeName()メソッドを使用してエレメントタグ名が'person'かどうかを判定しています。
getNodeName()メソッドは、ELEMENT、PI、END_ELEMENTノードの場合は、タグ名を、
そうでない場合は、ノード型を示す識別子を返却します。

[[7.テキストノードへ移動|head:]]
エレメントのテキスト値は一つのノードとなります。4.の説明を参照して下さい。

[[8.getValue()でテキスト値を取得|head:]]
エレメントのテキスト値を取得する際の注意は、4.の説明を参照して下さい。

[[9.keyword終了タグへ移動|head:]]
エレメントの終了タグは一つのノードとなることに注意して下さい。

[[10.クローズ|head:]]
close()メソッドは、パーサの全リソースを解放します。
ただし、コンストラクタで指定したフラグや、
setErrorListener()メソッドで設定されたエラーリスナは含みません。

以下はより一般化されたノードダンププログラムの例です。

[[src]]
<?php
/**
 * demo_reader_sample2.csp
 */

/**
 * より一般化されたノードダンププログラム
 */
function dumpfile($file)
{
    $reader = new CB_XMLReader();
    
    /**
     * オープン
     */
    $reader->openFile($file);
    
    /**
     * 1を返却している間は続ける
     */
    while($reader->read()) {
        $name = $reader->getNodeName();
        echo "ノード名:$name<BR>";
        
        /**
         * ノード型判定
         */
        $type = $reader->getNodeType();
        switch($type) {
        case CB_XML_NONE:
            $typename = "NONE";
            break;
        case CB_XML_ELEMENT:
            $typename = "ELEMENT";
            break;
        case CB_XML_TEXT:
            $typename = "TEXT";
            break;
        case CB_XML_CDATA:
            $typename = "CDATA";
            break;
        case CB_XML_PI:
            $typename = "PI";
            break;
        case CB_XML_COMMENT:
            $typename = "COMMENT";
            break;
        case CB_XML_DOC_TYPE:
            $typename = "DOC_TYPE";
            break;
        case CB_XML_WHITESPACE:
            $typename = "WHITESPACE";
            break;
        case CB_XML_END_ELEMENT:
            $typename = "END_ELEMENT";
            break;
        }
        echo "ノード型:$typename<BR>";
        
        /**
         * 以下の4つは値を持つ
         */
        if ($type == CB_XML_TEXT ||
            $type == CB_XML_CDATA ||
            $type == CB_XML_COMMENT ||
            $type == CB_XML_WHITESPACE)
        {
            $nodevalue = $reader->getValue();
            if ($nodevalue == "\r\n" || $nodevalue == "\r" || $nodevalue == "\n") {
                $nodevalue = "<BR>";
            }
            echo "ノード値:=>$nodevalue<=<BR>";
        }
        
        /**
         * 以下の2つは属性値を持つ
         */
        if ($type == CB_XML_ELEMENT ||
            $type == CB_XML_PI)
        {
            $nodeattr = $reader->getAttributes();
            echo "ノード属性値:";
            print_r($nodeattr);
            echo "<BR>";
        }
        
        echo "<BR>";
    }
    
    /**
     * 解析エラーの出力
     */
    $errors = $reader->getErrors();
    $count = count($errors);
    for ($i = 0;$i < $count;$i++) {
        echo "error$i => ".$errors[$i]['msg']."<BR>";
    }
    
    /**
     * クローズ
     */
    $reader->close();
}

?>

<HTML><TITLE>ノードダンプ</TITLE><BODY>
<FORM ACTION="demo_reader_sample2" METHOD="post" ENCTYPE="multipart/form-data">
XMLファイル:<INPUT TYPE="file" NAME="xml"><BR>
<BR>
<INPUT TYPE="submit">
</FORM>

<?php
if (isset($_FILES['xml'])) {
    if ($_FILES['xml']['error'] != UPLOAD_ERR_OK) {
        echo "アップロード失敗！<BR>";
    } else {
        dumpfile($_FILES['xml']['tmp_name']);
    }
}
?>
[[/src]]

[[html]]
<a href="demo_reader_sample2">動作させてみる</a>
[[/html]]

[[CB_XMLWriterクラス（チュートリアル）|section:xmlwriter]]

[[az:fw.xml:CB_XMLWriter]]はXMLストリームライターの機能を提供します。

以下はXMLデータをブラウザにHTTPレスポンスとして出力するサンプルコードです。

[[src]]
<?php
/**
 * demo_writer_sample.csp
 */

/**
 * a.書き出し開始
 */
cb_prepare_download('out.xml', 'text/xml', TRUE);

/**
 * 1.インスタンスの作成
 */
$writer = new CB_XMLWriter();

/**
 * 2.標準出力オープン
 */
$writer->open("\t");

/**
 * 3.ドキュメント開始（XML宣言の出力）
 */
$writer->startDocument("UTF-8","1.0","yes");

/**
 * 4.コメント出力
 */
$writer->writeComment(" サンプルです ");

/**
 * 5.ルートエレメント開始
 */
$writer->startElement("root");

/**
 * 6.属性値の追加
 */
$writer->writeAttribute("id","0");

/**
 * 7.子エレメント1開始
 */
$writer->startElement("child1");

/**
 * 8.テキスト出力（エスケープあり）
 */
$writer->writeString("<escape/>");

/**
 * 9.子エレメント1終了
 */
$writer->endElement();

/**
 * 子エレメント2開始
 */
$writer->startElement("child2");

/**
 * 10.テキスト出力（エスケープなし）
 */
$writer->writeRaw("<escape/>");

/**
 * 子エレメント2終了
 */
$writer->endElement();

/**
 * 子エレメント3開始
 */
$writer->startElement("child3");

/**
 * 11.CDATA出力
 */
$writer->writeCDATA("<escape/>");

/**
 * 子エレメント3終了
 */

/**
 * ルートエレメント終了
 */
$writer->endElement();

/**
 * 12.ドキュメント終了
 */
$writer->endDocument();

/**
 * 13.クローズ
 */
$writer->close();

/**
 * b.書き出し終了
 */
cb_safe_exit();

?>
[[/src]]

[[html]]
<a href="demo_writer_sample">ブラウザ出力結果</a>
[[/html]]

出力ソースは以下のようになります。

[[src]]
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!-- サンプルです -->
<root id="0">
	<child1>&lt;escape/&gt;</child1>
	<child2><escape/></child2>
	<child3><![CDATA[<escape/>]]></child3>
</root>
[[/src]]

[[a.書き出し開始|head:]]

HTTPレスポンスにデータを書き出すための準備を行います。
詳しくは
[[html]]
<a href="dev_doc?item=dev%2Fapi%2Fupload_download#download">こちら</a>を
[[/html]]
参照下さい。

[[1.インスタンスの作成|head:]]

コンストラクタでインスタンスを作成します。
コンストラクタは引数をとりません。

[[2.標準出力オープン|head:]]

open()メソッドで標準出力をオープンします。
標準出力に書き出されたデータは、PHPによって、HTTPレスポンス出力等に出力されます。

open()メソッドの引数にはインデント文字列を指定することができます。これを指定した場合、
指定の文字列をインデントとし、文書の整形を行います。
指定しない場合は、整形が行われず、一行で書き出されます。

[[3.ドキュメント開始（XML宣言の出力）|head:]]

startDocument()メソッドでドキュメントを開始します。
このメソッドはXML宣言（<?xml version="1.0" encoding="UTF-8" standalone="yes"?>）
を出力して、ライターの状態をドキュメント開始状態にするとともに、
以降出力されるデータの文字セットを定める役割を担います。

すなわち、以降ライターに出力指定される（内部コーディングの）マルチバイト文字列は全て、
（このメソッドで指定された）UTF-8コーディングに変換され出力されます。例外はありません。

[[4.コメント出力|head:]]

writeComment()メソッドで、コメント文字列を指定し、コメントを出力します。

[[5.ルートエレメント開始|head:]]

startElement()メソッドで、エレメント名を指定し、エレメントを開始します。
開始タグはすぐに出力されるわけではありません。
endElement()でエレメントが閉じられたり、子エレメントが開始されたりするなど、
出力する文字列が決定された段階で、出力されます。

[[6.属性値の追加|head:]]

writeAttribute()メソッドで、属性名と属性値を指定し、
直前に開始されたエレメントに属性を追加します。

[[7.子エレメント1開始|head:]]

あるエレメントが終了される前に、他のエレメントを開始すると、
後から開始されたエレメントは子エレメントとなります。

[[8.テキスト出力（エスケープあり）|head:]]

writeString()メソッドで、指定された文字列を出力します。
エレメントのスコープ内で'<','>'等の文字を出力する場合には、
本メソッドを用いると自動的にエスケープが実行されます。

タグ付けされたテキストを、子エレメントとして登録したい場合など、
エスケープを実行したくない場合には、writeRaw()メソッドを使用して下さい。

[[9.子エレメント1終了|head:]]

endElement()メソッドで直前に開始されたエレメントを終了します。

[[10.テキスト出力（エスケープなし）|head:]]

writeRaw()メソッドで、指定された文字列をエスケープせずに出力します。
タグ付けされたテキスト"<escape/>"は、これにより、"child2"エレメントの子エレメント
として登録されます。

[[11.CDATA出力|head:]]

writeCDATA()メソッドで、指定された文字列をコンテンツとしたCDATAセクションを出力します。

[[12.ドキュメント終了|head:]]

endDocument()メソッドで、ドキュメントを終了します。

[[13.クローズ|head:]]

close()メソッドで、ライターをクローズします。

[[b.書き出し終了|head:]]

出力後処理を行います。
詳しくは
[[html]]
<a href="dev_doc?item=dev%2Fapi%2Fupload_download#download">こちら</a>を
[[/html]]
参照下さい。

[[入出力対象|section:io]]

CB_XMLReaderクラス、CB_XMLWriterクラスは、それぞれ以下のものを入出力対象とすることができます。

[[html]]
<table class="cb_doc_table">
<tr>
<th>
クラス名
</th>
<th>
入出力対象
</th>
</tr>
<tr>
<td>
CB_XMLReader
</td>
<td>
1.絶対ファイルパス（で指定されたファイル）<BR>
2.PHPストリーム（オープン済みファイル・ソケットハンドル）<BR>
3.文字列バッファ<BR>
</td>
</tr>
<tr>
<td>
CB_XMLWriter
</td>
<td>
1.絶対ファイルパス（で指定されたファイル）<BR>
2.PHPストリーム（オープン済みファイル・ソケットハンドル）<BR>
3.標準出力<BR>
</td>
</tr>
</table>
[[/html]]

CB_XMLWriterクラスは、直接的には、文字列バッファを出力対象としません。
しかし、そのような用途が必要な場合には、PHPのアウトプットバッファリング機構を用いて、
標準出力に出力されたデータを、文字列バッファとしてプログラム内に取り込むことが可能です。

入出力を実現するAPIは以下の通りです。

CB_XMLReaderクラス
[[html]]
<table class="cb_doc_table">
<tr>
<th>
メソッド名
</th>
<th>
使用方法
</th>
</tr>
<tr>
<td>
openFile($filepath[,$encoding])
</td>
<td>
$reader->openFile("c:/sample.xml");<BR>
...<BR>
$reader->close()<BR>
</td>
</tr>
<tr>
<td>
openResource($handle[,$encoding])
</td>
<td>
$handle = fopen("c:/sample.xml","r");<BR>
$reader->openResource($handle);<BR>
...<BR>
$reader->close();<BR>
fclose($handle);<BR>
</td>
</tr>
<tr>
<td>
openMemory($buffer[,$encoding])
</td>
<td>
$buffer = "&lt;doc&gt;&lt;contents/&gt&lt/doc&gt";<BR>
$reader->openMemory($buffer);<BR>
...<BR>
$reader->close();<BR>
</td>
</tr>
</table>
[[/html]]

CB_XMLWriterクラス
[[html]]
<table class="cb_doc_table">
<tr>
<th>
メソッド名
</th>
<th>
使用方法
</th>
</tr>
<tr>
<td>
openFile($file[,$indent])
</td>
<td>
$writer->openFile("c:/sample.xml");<BR>
...<BR>
$writer->close()<BR>
</td>
</tr>
<tr>
<td>
openResource($handle[,$indent])
</td>
<td>
$handle = fopen("c:/sample.xml","w");<BR>
$writer->openResource($handle);<BR>
...<BR>
$writer->close();<BR>
fclose($handle);<BR>
</td>
</tr>
<tr>
<td>
open([$indent])
</td>
<td>
ob_start();<BR>
$writer->open();<BR>
...<BR>
$writer->close();<BR>
$buffer = ob_get_clean();<BR>
</td>
</tr>
</table>
[[/html]]

[[文字セット|section:encoding]]

[[1.入力の文字セット|head:]]

XMLデータの文字セットは、通常XML宣言で指定されています。

XML宣言は以下の構造をなしています。

[[src]]
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
[[/src]]

このセクションの"encoding="以降で示される文字列が、XMLの文字セットを表しています。

ただし、このencoding部分は、省略することが可能であり、
そもそもXML宣言自体、省略することが可能です。
（ただし、省略しない場合は、
データの先頭に存在しなければならないという制限があります。）

これは、HTTPヘッダのContent-Typeヘッダなど、XML宣言以外にもXMLの文字セットを
表す手段が存在することを示唆しています。

以上の事柄を考慮し、
CB_XMLReaderはopenFile()、openResource()、openMemory()が実施された際、
以下のようにしてXMLデータの文字セットを決定するように、作成されています。

1.XML宣言のencoding部分が存在する場合は、それをデフォルトの文字セットとする。
存在しない場合はUnicodeをデフォルトとする。

2.XML宣言のencoding部分が存在する場合で、
指定された文字セットが対応できない文字セットであった場合、解析エラーとなる。
（この場合、次の3.で指定しなおす事はできません。）

3.open***()メソッドの第二引数が指定されている場合は、その文字セットを採用する。
指定された文字セットが対応できない文字セットであったり、指定されていない場合は、
デフォルトの文字セットが採用される。

XML宣言での指定より、open***()メソッドでの指定の方が優先することに注意して下さい。

CB_XMLReaderは以下のエンコーディング名、エイリアス名が
XML宣言のencoding部分に指定されている場合、もしくはopen***()メソッドで指定される場合に、
それを対応可能な文字セットとして認識します。大文字・小文字は区別しません。

[[html]]
<table class="cb_doc_table">
<tr>
<th>
エンコーディング名
</th>
<th>
エイリアス名
</th>
</tr>
<tr>
<td>
UTF-8
</td>
<td>
UTF8,UTF_8
</td>
</tr>
<td>
UTF-16LE
</td>
<td>
UTF16LE,UTF_16LE
</td>
</tr>
<td>
UTF-16BE
</td>
<td>
UTF16BE,UTF_16BE
</td>
</tr>
<td>
UTF-16
</td>
<td>
UTF16,UTF_16
</td>
</tr>
<td>
ISO-8859-1
</td>
<td>
ISO88591,ISO_8859_1,LATIN1,LATIN-1,LATIN_1
</td>
</tr>
<td>
ISO-2022-JP
</td>
<td>
ISO2022JP,ISO_2022_JP,JIS
</td>
</tr>
<td>
SHIFT_JIS
</td>
<td>
SJIS,SHIFT-JIS,SHIFTJIS,WINDOWS-31J,WINDOWS_31J,WINDOWS31J
</td>
</tr>
<td>
EUC-JP
</td>
<td>
EUC_JP,EUCJP
</td>
</tr>
<td>
US-ASCII
</td>
<td>
ASCII,US_ASCII,USASCII
</td>
</tr>
</table>
[[/html]]

注）エンコーディング名"SHIFT_JIS"は本来のSHIFT_JISではなく、
"WINDOWS-31J"（CP932）にマッピングされます。

[[2.出力の文字セット|head:]]

CB_XMLWriterが対応可能な文字セットは以下の通りです。
startDocument()メソッドの第一引数には以下のエンコーディング名を指定することが可能です。
指定しない場合は、"UTF-8"が指定されている扱いとなります。

startDocument()メソッドは、指定されたエンコーディング名を
XML宣言のencoding部分に出力し、それ以降UTF8（内部コード）で設定された値を、
指定の文字セットに変換しながら、出力を実施していきます。

[[html]]
<table class="cb_doc_table">
<tr>
<th>
エンコーディング名
</th>
</tr>
<tr>
<td>
UTF-8
</td>
</tr>
<td>
UTF-16LE
</td>
</tr>
<td>
UTF-16BE
</td>
</tr>
<td>
UTF-16
</td>
</tr>
<td>
ISO-8859-1
</td>
</tr>
<td>
ISO-2022-JP
</td>
</tr>
<td>
SHIFT_JIS
</td>
</tr>
<td>
EUC-JP
</td>
<tr>
<td>
US-ASCII
</td>
</tr>
</table>
[[/html]]

注）エンコーディング名"SHIFT_JIS"は、XML宣言には"SHIFT_JIS"と表記されますが、
実際には"WINDOWS-31J"（CP932）で出力が行われます。

[[エラー処理|section:error]]

CB_XMLReaderは、システム全体の異常データへの耐性を考慮し、
「ファイルが存在しない」、「オープンされてない状態でread()が行われた」等の
致命的なエラーを除いて、直接クライアントにエラーを送出することはありません。
解析エラーはアプリケーション自身でハンドリングする必要があります。

CB_XMLReaderは解析エラーをハンドリングするための2通りの方法を提供します。

[[1.エラー情報の取得|head:]]

アプリケーションはgetErrors()メソッドを使用することにより、いつでも、
それまでに発生した全てのエラー情報を取得することができます。

getErrors()メソッドはエラー情報配列のリスト（0から始まる整数値でindex付けされた配列）
を返却します。1つのエラー情報配列は以下の構造をしています。

[[src]]
Array([msg] => エラーメッセージ
	[severity] => エラーレベル
	[baseURI] => オープンしたデータのロケーション情報（メモリデータの場合は設定されない）
	[line] => エラーの発生した行
[[/src]]

エラーレベルは以下の定数で表現されます

[[src]]
/**
 * 妥当性検証に関する警告
 */
define( "CB_XML_VALIDITY_WARNING",        1 );
/**
 * 妥当性検証に関するエラー
 */
define( "CB_XML_VALIDITY_ERROR",          2 );
/**
 * 構造解析に関する警告
 */
define( "CB_XML_WARNING",                 3 );
/**
 * 構造解析に関するエラー
 */
define( "CB_XML_ERROR",                   4 );
[[/src]]

また、コンストラクタでCB_XML_PARSE_NOERROR、
CB_XML_PARSE_NOWARNINGを指定することにより出力するエラーレベルを
設定することが可能です。

[[2.エラーリスナ|head:]]

エラー発生時に実行される処理を、エラーリスナとして登録しておくことが可能です。
リスナを作成するためには一引数のonError()メソッドを実装したクラスを定義します。

onError()の引数にはエラー情報配列が渡されます。
onError()はエラー発生の度に呼ばれ、複数回よばれる可能性があります。

以下はエラーリスナのサンプルです。

[[src]]
<?php
/**
 * demo_reader_errorhandling.csp
 */

class SampleErrorListener
{
    /**
     * エラーが発生した時点でプログラムを中断する
     */
    function onError($error)
    {
        echo "msg => ".$error['msg']."<BR>";
        echo "baseURI => ".$error['baseURI']."<BR>";
        echo "severity => ".$error['severity']."<BR>";
        echo "line => ".$error['line']."<BR>";
        die;
    }
}

/**
 * 妥当性検証を有効にする
 */
$reader = new CB_XMLReader(CB_XML_PARSE_DTDVALID);

/**
 * リスナを登録する
 */
$reader->setErrorListener(new SampleErrorListener());

/**
 * オープンするファイルパスを絶対パスで記述する
 */
$reader->openFile(cb_basedir()."/code/doc_root/developer/xml/sample.xml");

/**
 * ファイルエンドまで解析を行う
 */
while($reader->read());

/**
 * クローズ
 */
$reader->close();

?>
[[/src]]

[[html]]
<a href="demo_reader_errorhandling">ブラウザ出力結果</a>
[[/html]]

[[妥当性検証（DTD）|section:validation]]

CB_XMLReaderはDTDによる妥当性検証（validation）の機能をサポートします。
妥当性検証は、構造解析と並行して行われます。

妥当性検証を有効にするためには、コンストラクタでCB_XML_PARSE_DTDVALIDを指定します。

検証結果は解析後（クローズする前）にisValid()メソッドによってbool値で取得することができます。
また、妥当性検証に関するエラー、
警告メッセージも解析エラーと同様の方法でハンドリングすることができます。
（これらのエラーはCB_XML_PARSE_DTDVALIDが指定されていない場合は発生することがありません。）

以下にサンプルを示します。

[[src]]
<?php
/**
 * demo_reader_validation.csp
 */

/**
 * 妥当性検証を有効にする
 */
$reader = new CB_XMLReader(CB_XML_PARSE_DTDVALID);

/**
 * オープンするファイルパスを絶対パスで記述する
 */
$reader->openFile(cb_basedir()."/code/doc_root/developer/xml/sample.xml");

/**
 * ファイルエンドまで解析を行う
 */
while($reader->read());

/**
 * 検証結果を取得する
 */
$success = $reader->isValid();

if ($success) {
    echo "検証成功<BR>";
} else {
    echo "検証失敗<BR>";
    
    /**
     * エラーをリポートする
     */
    $errors = $reader->getErrors();
    for ($i = 0;$i < count($errors);$i++) {
        echo "error$i => ";
        print_r($errors[$i]);
        echo "<BR>";
    }
}

/**
 * クローズ
 */
$reader->close();

?>
[[/src]]

[[html]]
<a href="demo_reader_validation">ブラウザ出力結果</a>
[[/html]]

なお、CB_XMLReaderは妥当性検証をサポートしますが、
与えられたDTDの構造を解析する機能はサポートしていません。

[[実体参照と外部サブセット|section:entity_ref]]

[[1.実体参照|head:]]

XMLではDTD中に以下のように記述することで、
何回も登場するキーワードを「実体」として定義することができます。

[[src]]
<!DOCTYPE document [
...
<!ENTITY lib "<item>XMLライブラリ</item>">
...
]>
[[/src]]

定義した実体はドキュメント中で以下のように記述することで、参照することができます。

[[src]]
<document>
&lib;はとてもシンプルで高機能なライブラリです。
&lib;を使って簡単にXMLを操作することができます。
</document>
[[/src]]

CB_XMLReaderは、このような参照があった場合、参照先の値を代入し、評価します。
参照先がタグ付テキストであった場合は、それがあたかも始めから文書の一部であったかのように、
テキストの内部まで解析していきます。

すなわち、上のドキュメントを解析した結果は、
以下のドキュメントを解析した結果と等しくなります。

[[src]]
<document>
<item>XMLライブラリ</item>はとてもシンプルで高機能なライブラリです。
<item>XMLライブラリ</item>を使って簡単にXMLを操作することができます。
</document>
[[/src]]

[[2.外部サブセット|head:]]

XMLでは、以下のようにDTD等を外部サブセットとして定義することも可能です。
外部サブセットのパスはスラッシュ区切りの絶対ファイルパス、またはURLで記述する必要があります。

[[src]]
<!DOCTYPE document SYSTEM "C:/InetPub/scripts/cbfw/code/doc_root/developer/xml/sample.dtd">
[[/src]]

上のようにDTDが別ファイル定義されていて、妥当性検証や実体参照を用いる必要がある場合は、
CB_XMLReaderがDTDファイルをロードするよう指定してやる必要があります。

例えば、以下のようなコードを考えます。

[[src]]
<?php
/**
 * demo_reader_entity_ref.csp
 */

/**
 * 外部サブセットのパスをスラッシュ区切りの絶対ファイルパス、またはURLで記述する
 */
$path = str_replace("\\", "/", cb_basedir()) . '/code/doc_root/developer/xml/sample.dtd';
$xml = sprintf("<!DOCTYPE document SYSTEM \"%s\"><document>&lib;です</document>", $path);

$reader = new CB_XMLReader(CB_XML_PARSE_DTDLOAD);

/**
 * オープン
 */
$reader->openMemory($xml);

/**
 * 終了まで解析
 */
while($reader->read())
{
    if ($reader->getNodeType() == CB_XML_TEXT) {
        $value = $reader->getValue();
        echo "値:$value<BR>";
    }
}

/**
 * エラーレポート
 */
$errors = $reader->getErrors();
for ($i = 0;$i < count($errors);$i++) {
    $msg = $errors[$i]['msg'];
    echo "error$i => $msg<BR>";
}

/**
 * クローズ
 */
$reader->close();

?>
[[/src]]

DTDは外部サブセットとして、正しい場所に以下のように定義してあるとします。

[[src]]
<!ENTITY lib "XMLライブラリ">
[[/src]]

上のコードを実行すると以下のような出力になります。

[[src]]
値:XMLライブラリです

Copyright c 2004 Cybozu Inc. All rights reserved.
[[/src]]

今度はコードのコンストラクタで指定されているCB_XML_PARSE_DTDLOADをはずして
実行させてみます。出力は以下のようになります。

[[src]]
値:です
error0 => Entity 'lib' not defined 

Copyright c 2004 Cybozu Inc. All rights reserved.
[[/src]]

以上のように、CB_XMLReaderは予期しないネットワークアクセスの発生等を防止するため、
デフォルトでは、外部サブセットのDTDをロードしない設定になっています。
実体参照を用いるために必要な場合は、CB_XML_DTDLOADを指定して、
DTDをロードする設定にしてから、解析を実行するようにして下さい。

なお、妥当性検証を行うためのCB_XML_DTDVALIDを指定した場合は
自動的にDTDをロードしますのでCB_XML_DTDLOADと両方指定する必要はありません。

逆に、妥当性検証も実体参照も必要とせず、如何なる場合も外部DTDファイルをロードしたくない
場合などは、どちらの指定もはずして使用するようにして下さい。

[[DOMオブジェクトへのデータ読み込み|section:read_dom]]

CB_XMLReaderは、パース中のノードのサブツリーをDOMオブジェクトとして、
アプリケーションに読み込む機能を提供します。

以下は、サブツリーをDOMオブジェクトとして読み込み、ダンプするサンプルです。

[[src]]
<?php
/**
 * demo_reader_dom.csp
 */

/**
 * a.サブツリーのダンプデータを返却
 */
function dumpnode($element)
{
    $data = "&lt;".$element->tagname()."&gt;";
    $children = $element->child_nodes();
    for ($i = 0;$i < count($children);$i++) {
        if ($children[$i]->node_type() == XML_ELEMENT_NODE) {
            $data .= dumpnode($children[$i]);
        } else if ($children[$i]->node_type() == XML_TEXT_NODE) {
            $data .= $children[$i]->node_value();
        }
    }
    $data = $data."&lt;/".$element->tagname()."&gt;";
    return $data;
}

$reader = new CB_XMLReader(CB_XML_PARSE_NOBLANKS);

/**
 * オープンするファイルパスを絶対パスで記述する
 */
$reader->openFile(cb_basedir().'/code/doc_root/developer/xml/sample.xml');

/**
 * 1つ目のpersonタグまでおくる
 */
while($reader->read() == 1 && strcmp($reader->getNodeName(),"person") != 0);

/**
 * 各personタグ毎の処理
 */
while($reader->getNodeType() == CB_XML_ELEMENT && 
      strcmp($reader->getNodeName(),"person") == 0) {
    
    /**
     * 1.サブツリー読み込み
     */
    $domelement = $reader->expand();
    
    /**
     * ダンプ
     */
    $data = dumpnode($domelement);
    echo "dump => $data<BR>";
    
    /**
     * 2.子ノードをスキップ
     */
    $reader->skip();
}

/**
 * エラーレポート
 */
$errors = $reader->getErrors();
for ($i = 0;$i < count($errors);$i++) {
    echo "error$i => $errors[$i]['msg']<BR>";
}

/**
 * クローズ
 */
$reader->close();

?>
[[/src]]

[[html]]
<a href="demo_reader_dom">ブラウザ出力結果</a>
[[/html]]

[[1.サブツリー読み込み|head:]]

expand()メソッドで、現在のノードを頂点とするサブツリーを、
domxml拡張モジュールのDomElementクラスオブジェクトとして取得することができます。

[[2.子ノードをスキップ|head:]]

skip()メソッドで、現在のノードの子ノードをスキップします。
すなわち、現在のノードがELEMENTであり、かつ空でない
（<empty/>のように終了タグを持たないエレメントを「空である」といいます）
場合は、対応するEND_ELEMENTの次のノードにポイントを進めます。
そうでない場合は、read()と同じく単にポイントを一つ進めます。

[[a.サブツリーのダンプデータを返却|head:]]

domxml拡張APIを使用し、受け取ったDomElementオブジェクトのサブツリーをダンプしています。

以上のように、expand()メソッドとskip()メソッドを組み合わせて使用することで、
サブツリーを順番に操作することが可能となります。

同じ構造のサブツリーが数多く繰り返されているようなドキュメントでは、
全体としてツリー展開することが、メモリリソースの都合上難しいような場合でも、
このようにして、サブツリーごとに展開していくことで、
問題が解決される場合があります。

[[DOMオブジェクトのデータ書き出し|section:write_dom]]

CB_XMLWriterは、DOMオブジェクトのデータを書き出す機能を提供します。

以下は、作成したDOMオブジェクトを書き出すサンプルです。

[[src]]
<?php
/**
 * demo_writer_dom.csp
 */

$template = domxml_open_mem("<person><keyword></keyword></person>");

/**
 * a.domツリーの初期化
 */
function setNameAndAddKeyword($document,$name,$keyword) {
    $node =& $document->document_element();
    $node->set_attribute("name",$name);
    $node =& $node->first_child();
    if (strlen($node->get_content()) == 0) {
        $node->set_content($keyword);
    } else {
        $node->set_content(" and $keyword");
    }
}

/**
 * 書き出し開始
 */
cb_prepare_download('out.xml', 'text/xml', TRUE);

$writer = new CB_XMLWriter();

/**
 * 標準出力オープン
 */
$writer->open();

$writer->startDocument("UTF-8","1.0","yes");

/**
 * ルート
 */
$writer->startElement("office");

/**
 * 1.連続DOM書き出し
 */
setNameAndAddKeyword($template,"A","tall");
$writer->writeDomNode($template);
setNameAndAddKeyword($template,"B","heavy");
$writer->writeDomNode($template);
setNameAndAddKeyword($template,"C","beautiful");
$writer->writeDomNode($template);
setNameAndAddKeyword($template,"D","young");

/**
 * ルート終了
 */
$writer->endElement();

$writer->endDocument();

/**
 * クローズ
 */
$writer->close();

/**
 * 書き出し終了
 */
cb_safe_exit();

?>
[[/src]]

[[html]]
<a href="demo_writer_dom">ブラウザ出力結果</a>
[[/html]]

[[1.連続DOM書き出し|head:]]

writeDomNode()メソッドで指定されたDOMオブジェクトのデータを出力することができます。
writeDomNode()メソッドではdomxml拡張APIにおけるDomElementクラスオブジェクトと、
DomDocumentクラスオブジェクトを指定することができます。
指定されたオブジェクトがDomDocumentクラスオブジェクトであった場合は、
ルートエレメントのデータを出力します。（XML宣言やDTDは出力しません）

[[a.domツリーの初期化|head:]]

DOMオブジェクトの操作はdomxml拡張APIを使用して行います。

[[要素の名前空間|section:element_namespace]]

同じタグが異なる要素タイプを意味してしまう、いわゆる「タグ名の衝突」を避けるため、
XMLでは名前空間を用いることができます。

以下の例では、別々のURIを指し示す接頭辞「book」と「prof」を定義し、
それをタグ名（「title」）に付加することで、識別できるようにしてあります。

[[src]]

<body xmlns:book="http://example.com/ns/book/"
    xmlns:prof="http://example.com/ns/profile/">
    <book:title>ユニバーサルHTML/XHTML</book:title>
    <prof:title>コントラバス奏者</prof:title>
</body>

[[/src]]

以下のように接頭辞を指定せず、デフォルトの名前空間を定義することも出来ます。
デフォルト名前空間が定義されている場合、スコープ中に存在するタグで接頭辞のないものは、
すべてデフォルト名前空間に属します。

[[src]]

<book xmlns="http://example.com/ns/book/">
    <title>ユニバーサルHTML/XHTML</title>
    <author>山下清</author>
</book>

[[/src]]

XMLライブラリでは、CB_XMLReaderクラスのgetNodeURI()メソッドを、
ELEMENTノードにポイントされている状態で呼び出すと、該当する要素の、
名前空間が解決されたURIを取得することができます。
以下は与えられたXMLを順にパースし、要素名と、要素のURIをダンプするサンプルです。

[[src]]
<?php
/**
 * demo_reader_namespace1.csp
 */

/**
 * 各要素の名前空間URIダンププログラム
 */
function dumpfile($file)
{
    $reader = new CB_XMLReader();
    
    /**
     * オープン
     */
    $reader->openFile($file);
    
    /**
     * 1を返却している間は続ける
     */
    while($reader->read()) {
        /**
         * ノード型判定
         */
        $type = $reader->getNodeType();
        
        /**
         * 要素でなければ飛ばす
         */
        if ($type != CB_XML_ELEMENT) continue;
        
        /**
         * ダンプ
         */
        $name = $reader->getNodeName();
        echo "ノード名:$name<BR>";
        $uri = $reader->getNodeURI();
        echo "URI:$uri<BR>";
        echo "<BR>";
    }
    
    /**
     * 解析エラーの出力
     */
    $errors = $reader->getErrors();
    $count = count($errors);
    for ($i = 0;$i < $count;$i++) {
        echo "error$i => ".$errors[$i]['msg']."<BR>";
    }
    
    /**
     * クローズ
     */
    $reader->close();
}

?>

<HTML><TITLE>各要素の名前空間URIダンプ</TITLE><BODY>
<FORM ACTION="demo_reader_namespace1" METHOD="post" ENCTYPE="multipart/form-data">
XMLファイル:<INPUT TYPE="file" NAME="xml"><BR>
<BR>
<INPUT TYPE="submit">
</FORM>

<?php
if (isset($_FILES['xml'])) {
    if ($_FILES['xml']['error'] != UPLOAD_ERR_OK) {
        echo "アップロード失敗！<BR>";
    } else {
        dumpfile($_FILES['xml']['tmp_name']);
    }
}
?>
[[/src]]

[[html]]
<a href="demo_reader_namespace1">動作させてみる</a>
[[/html]]

例1のXMLを入力した結果は以下のようになります。

[[src]]
ノード名:body
URI:

ノード名:book:title
URI:http://example.com/ns/book/

ノード名:prof:title
URI:http://example.com/ns/profile/
[[/src]]

例2のXMLを入力した結果は以下のようになります。

[[src]]
ノード名:book
URI:http://example.com/ns/book/

ノード名:title
URI:http://example.com/ns/book/

ノード名:author
URI:http://example.com/ns/book/
[[/src]]

[[属性の名前空間|section:attribute_namespace]]

ある名前空間においてグローバル（共有）と定義された属性を使用する場合、
属性名にも接頭辞を置くことが可能です。
接頭辞が用いられない場合、属性は要素の区画に属します。
（デフォルト名前空間は、属性には適用されません）

[[src]]
<h:html xmlns:h="http://www.w3.org/1999/xhtml"
        xmlns:b="http://example.com/ns/book/">
    <h:div class="biblio">
    <b:book>
        <b:author h:class="person">神崎正英</b:author>
    </b:book>
    </h:div>
</h:html>
[[/src]]

上の例で、最初に"h:div"タグの属性として定義されている"class"属性は、
xhtml名前空間に属するdivタグの属性として使用され、
後に"b:author"タグの属性として定義されている"h:class"属性は、
xhtml名前空間においてグローバルに定義された属性として使用されます。

XMLライブラリでは、CB_XMLReaderクラスのlookupNS()メソッドを用いて、
接頭辞から名前空間のURIを取得することができます。

また、CB_XMLReaderクラスのgetAttributes()メソッドは、各属性について
以下のような構造体を属性の数だけ列挙し、すなわち、ここから各属性の接頭辞を
知ることが可能です。

[[src]]
array(
    "name" => "属性名（接頭辞も含める）" ,
    "localname" => "ローカルな属性名（接頭辞は含めない）" ,
    "prefix" => "接頭辞" ,
    "value" => "属性値"
    )
[[/src]]

以下は与えられたXMLを順にパースし、属性名と、属性の区画をダンプするサンプルです。
属性の区画は以下のような形式とします。

[[src]]
/**
 * グローバルな属性
 */
{URI}#ローカル属性名
/**
 * 要素に属する属性
 */
{URI}ローカル要素名#ローカル属性名
[[/src]]

[[src]]
<?php
/**
 * demo_reader_namespace2.csp
 */

/**
 * 各属性の区画ダンププログラム
 */
function dumpfile($file)
{
    $reader = new CB_XMLReader();
    
    /**
     * オープン
     */
    $reader->openFile($file);
    
    /**
     * 1を返却している間は続ける
     */
    while($reader->read()) {
        /**
         * ノード型判定
         */
        $type = $reader->getNodeType();
        
        /**
         * 要素でなければ飛ばす
         */
        if ($type != CB_XML_ELEMENT) continue;
        
        /**
         * 要素情報を取得
         */
        $nodeuri = $reader->getNodeURI();
        $nodename = $reader->getNodeLocalName();
        
        /**
         * 属性の列挙を取得
         */
        $attributes = $reader->getAttributes();
        
        /**
         * ダンプ
         */
        foreach($attributes as $attribute) {
            $name = $attribute['name'];
            $localname = $attribute['localname'];
            
            echo "属性名:$name<BR>";
            
            $prefix = $attribute['prefix'];
            
            if ($prefix) {
                $uri = "{" . $reader->lookupNS($prefix) . "}";
                echo "区画:$uri#$localname<BR>";
            } else {
                $uri = "{" . $nodeuri . "}" . $nodename;
                echo "区画:$uri#$localname<BR>";
            }
        }
    }
    
    /**
     * 解析エラーの出力
     */
    $errors = $reader->getErrors();
    $count = count($errors);
    for ($i = 0;$i < $count;$i++) {
        echo "error$i => ".$errors[$i]['msg']."<BR>";
    }
    
    /**
     * クローズ
     */
    $reader->close();
}

?>

<HTML><TITLE>各属性の区画ダンプ</TITLE><BODY>
<FORM ACTION="demo_reader_namespace2" METHOD="post" ENCTYPE="multipart/form-data">
XMLファイル:<INPUT TYPE="file" NAME="xml"><BR>
<BR>
<INPUT TYPE="submit">
</FORM>

<?php
if (isset($_FILES['xml'])) {
    if ($_FILES['xml']['error'] != UPLOAD_ERR_OK) {
        echo "アップロード失敗！<BR>";
    } else {
        dumpfile($_FILES['xml']['tmp_name']);
    }
}
?>
[[/src]]

[[html]]
<a href="demo_reader_namespace2">動作させてみる</a>
[[/html]]

例のXMLを入力した結果は以下のようになります。

[[src]]
属性名:xmlns:h
区画:{}#h
属性名:xmlns:b
区画:{}#b
属性名:class
区画:{http://www.w3.org/1999/xhtml}div#class
属性名:h:class
区画:{http://www.w3.org/1999/xhtml}#class
[[/src]]

[[リファレンス|section:reference]]
*XML -XML、DTD、XMLSchemaについて詳しく説明します。
（
[[html]]
<a href="http://www.techscore.com/tech/XML/">http://www.techscore.com/tech/XML/</a>
[[/html]]
）
*XML名前空間の簡単な説明（
[[html]]
<a href="http://www.kanzaki.com/docs/sw/names.html">http://www.kanzaki.com/docs/sw/names.html</a>
[[/html]]
）

[[サンプル|section:sample]]

*CB_XMLReaderチュートリアルサンプル（[[developer/demo_reader_sample.csp]]）（[[実行|run:developer/demo_reader_sample]]）
*CB_XMLReaderチュートリアルサンプル2（[[developer/demo_reader_sample2.csp]]）（[[実行|run:developer/demo_reader_sample2]]）
*CB_XMLWriterチュートリアルサンプル（[[developer/demo_writer_sample.csp]]）（[[実行|run:developer/demo_writer_sample]]）
*エラー処理（[[developer/demo_reader_errorhandling.csp]]）（[[実行|run:developer/demo_reader_errorhandling]]）
*妥当性検証（[[developer/demo_reader_validation.csp]]）（[[実行|run:developer/demo_reader_validation]]）
*実体参照と外部サブセット（[[developer/demo_reader_entity_ref.csp]]）（[[実行|run:developer/demo_reader_entity_ref]]）
*DOMオブジェクトへのデータ読み込み（[[developer/demo_reader_dom.csp]]）（[[実行|run:developer/demo_reader_dom]]）
*DOMオブジェクトのデータ書き出し（[[developer/demo_writer_dom.csp]]）（[[実行|run:developer/demo_writer_dom]]）
*要素の名前空間（[[developer/demo_reader_namespace1.csp]]）（[[実行|run:developer/demo_reader_namespace1]]）
*属性の名前空間（[[developer/demo_reader_namespace2.csp]]）（[[実行|run:developer/demo_reader_namespace2]]）
