[[概要|section:abstract]]
キャッシュ機構を使用することによりさまざまなデータをキャッシュすることができます。
 「複数回クエリーを発行して作られるデータ」、「複雑な演算を施して作られるデータ」、「ネットワーク越しにあるデータ」などは最も顕著な例で、それらを効果的にキャッシュしておくことにより、サーバーに対する負荷を軽減したり、レスポンス時間の短縮に効果を得ることができます。

また、キャッシュというと、あまりデータの変更がない所などをキャッシュしておくイメージが強いと思いますが、
頻繁に変更されるようなデータであっても、リアルタイム性がそれ程重要でなく、多少の遅延が問題にならないような場合、
短時間キャッシュしただけでも、かなりデータベースへの負荷を抑えることができます。データの種類やその生存時間など考慮して効果的に使用してください。

尚、ユーザーは今回作成した「キャッシュ機構」のほかに「smartyのキャッシュ機構」も使用することができます。
作成したキャッシュ機構でどんなデータでも保存できるので、使用しなくても構いませんが、使い分けることによってよりスマートなキャッシングの構成にすることが可能になります。

具体的な使い分けとしては、以下のようになります。

[[src]]
----------------------------------
             View
----------------------------------  <-- smatryのキャッシュ機構を使用する
           Controler
----------------------------------  <-- キャッシュ機構を使用する
             Model
----------------------------------
[[/src]]

[[設計|section:design]]
ユースケースから要件を考えると、
#組み込みが容易であること（特にキャッシュは出来合いのものに後から組み込む形になるので簡単に加えられることが重要）
#後で問題が発生したときなども考え、完全にキャッシュの機能を操作できること。（有効無効など）
#出力されるデータとしては、「モデル層の生データそのもの」と「ビューのデータ」しかない。
 （ ビューのキャッシュはsmartyにまかせればよいので、そのためPEAR::Cache::Cache_Function などのユーテリティは不要。出来るだけシンプルな形にしてキャッシュ操作が高速に動作するほどよい。）

構成としては、[[Profile|doc:dev/api/profile]] や [[Azlogger|doc:dev/api/azlogger]] と非常に似たクラス構成になっている。
それらはすべて、似て非なるものなので、ケースを突き詰めていけば同じような構成になるのは当然のことかもしれない。
処理自体はPEAR::Cache, PEAR::Cache_Liteを参考にして、それぞれのいい所をとり、Azaleaにあわせて無駄な部分を排除した。クラスの構成はAzlogger等を参考に、できるだけシンプルになる形でまとめた。

[[クラス図|section:class_design]]
[[img:developer/class_design_cache.jpg]]

[[クラス構成について|section:class_structure]]
[[html]]
<table class="cb_doc_table" border="1">
<tr><th nowrap>分類</th><th nowrap>クラス名</th><th>役割と機能</th></tr>

<tr>
<td nowrap rowspan="6">コア</td>
<td nowrap><tt>[[az:fw.cache:CB_Cacher]]</tt></td>
<td>
データのキャッシュ操作をするためのAPIを提供する。<br>
<ul style="margin-top: 0; margin-bottom: 0;">
<li>抽象的な処理を担当し、実際のターゲットへの操作はすべてCB_CacheTargetに委譲する。</li>
</ul>
</td>
</tr>

<tr>
<td nowrap><tt>[[az:fw.cache:CB_CacheTarget]]</tt></td>
<td>
保存先のターゲットを操作するためのインターフェイスを定義する。
<ul style="margin-top: 0; margin-bottom: 0;">
<li>
ターゲットの具像クラスは必ずこのインターフェイスを継承する必要がある。
</li>
</ul>
</td>
</tr>

<tr>
<td nowrap><tt>[[az:fw.cache:CB_CacheModule]]</tt></td>
<td>
キャッシュを階層化するための永続化クラス
<ul style="margin-top: 0; margin-bottom: 0;">
<li>
ターゲット(db, file)に関係なく、階層構造はデータベースに作成される。
</li>
</ul>
</td>
</tr>

<tr>
<td nowrap><tt>[[az:fw.cache:CB_CacheAttribute]]</tt></td>
<td>
キャッシュをデータを保存するための永続化クラス
<ul style="margin-top: 0; margin-bottom: 0;">
</ul>
</td>
</tr>

<tr>
<td nowrap><tt>plugin_fw_cacher_db</tt></td>
<td>
CB_CacheTargetの具像クラス
<ul style="margin-top: 0; margin-bottom: 0;">
<li>
データベースへのキャッシュ操作を実装する。
</li>
</ul>
</td>
</tr>

<tr>
<td nowrap><tt>plugin_fw_cacher_file</tt></td>
<td>
CB_CacheTargetの具像クラス
<ul style="margin-top: 0; margin-bottom: 0;">
<li>
ファイルへのキャッシュ操作を実装する。
</li>
</ul>
</td>
</tr>
    
<tr>
<td nowrap rowspan="4">ユーテリティ</td>
<td nowrap><tt>[[az:fw.cache:CB_CacherManager]]</tt></td>
<td>
データのキャッシュ操作をするためのAPIを提供する。
<ul style="margin-top: 0; margin-bottom: 0;">
<li>インスタンスは常に一つ（シングルトン）</li>
<li>CB_Cacherをカテゴリごとに管理する</li>
<li>CB_CacheTargetFactory、CB_CacheConfigを使用して初期設定されたCB_Cacherを作成する</li>
</ul>
</td>
</tr>
    
<tr>
<td nowrap><tt>[[az:fw.cache:CB_CacheTargetFactory]]</tt></td>
<td>
CB_CacheTargetを作成するためのファクトリークラス
<ul style="margin-top: 0; margin-bottom: 0;">
<li>インスタンスは常に一つ（シングルトン）</li>
<li>ターゲットは汎用プラグイン機構によって動的に追加する。</li>
<li>ターゲット自体は使いまわすことが可能なので、Flyweightな動きを管理する。</li>
</ul>
</td>
</tr>

<tr>
<td nowrap><tt>[[az:fw.cache:CB_CacherConfig]]</tt></td>
<td>
キャッシャー設定ファイルのアクセスクラス。実装に関してはCB_ConfigManagerに委譲している。
</td>
</tr>
</table>
[[/html]]

[[キャッシュ機構のチュートリアル|section:tutorial1]]

[[設定ファイルを確認する|head:]]
キャッシュ機構の設定は CGIディレクトリの "cacher.ini" に記述されています。
 正確には、lwc.ini の [Cacher] config 設定で指定されているファイルがそれにあたります。

初期状態では以下のようになっており、これらのデータはすべてのキャッシャーのデフォルトになります。
[[src]]
{{;;; Cacher configuration file}}

{{;; Default configuration.}}
caching = 1
lifetime = 3600
target = db
[[/src]]
上記の設定の場合、''caching = 1''(キャッシュあり)、''lifetime = 3600''(キャッシュの生存期間が1時間)、''target = db''(キャッシュ先としてデータベース)が設定されていることになります。

[[キャッシュにデータを追加する|head:]]
ターゲットに何が指定されているかによって保存先が変わります。
 データベースの場合は「''tab_cb_cacheinfo''」というテーブルにすべてのデータが保存されます。
 ファイルの場合は、まずcb_tmpdir()によって取得されるディレクトリの下にcacheというディレクトリが作られます。その中にCB_CacheModuleによって管理されているカテゴリーIDのディレクトリがつくられ、キャッシュIDと同名のファイルが作られますので確認してみてください。
(ex. C:/Program Files/Cybozu/mysql-4.1/tmp/cache/(カテゴリーID)/id1 )

尚、カテゴリーの階層構造は常にデータベースに作られるので、カテゴリー名に制限はありませんが、キャッシュIDの方はターゲットとしてファイルシステムを選択した場合、そのままファイル名に使用される為、[[az:fw.cache:include/fw/cache.csp:cb_possible_cache_key]]によって値のvalidationが行われます。それによって　''/:*?\"<>|'' などのファイル名に使用できないものはセットできなくなっています。

[[src]]
<?php
    require_once('fw/cache.csp');
    
    $cm = CB_CacherManager::getInstance();
    $c =& $cm->getCacher( 'hoge' );

    {{// この場合デフォルトの生存期間を使用}}
    $c->set( 'id1', $test );

    {{// 実行時に変更も可能。(setLifeTimeでデフォルト自体の変更も可能)}}
    $c->set( 'id2', $test, 100 );

    {{// 0はマジックナンバーで無期限になる}}
    $c->set( 'id3', $test, 0 );

    {{// idをうまくつけることによって同一意味のキャッシュを複数保存する}}
    $c->set( 'id_username_setting', $test );
    
    $c2 =& $cm->getCacher( 'hoge2' );

    {{// キャッシャーが異なれば同じIDでも大丈夫}}
    $c2->set( 'id1', $test );
?>
[[/src]]

[[キャッシュからデータを取り出す|head:]]
キャッシュからデータを取り出す際にexpire（期限切れ）のデータは自動的に削除されますので、明示的に削除する必要はありません。
 以下に最もノーマルな使い方のサンプルを示します。

[[src]]
<?php
    
    require_once('fw/cache.csp');
    
    $cm = CB_CacherManager::getInstance();
    $c =& $cm->getCacher( 'hoge' );
    
    {{// キャッシュデータの取得できなかった場合}}
    if( !$c->get( 'id1', $data ) ) {{// expireなデータの場合削除}}
    {
        {{// なにか大変な処理をして $test を作成する}}
        
        $c->set( 'id1', $test, 1 );
    }
    
    {{// ここから普通に $data を使用する。}}
    {{// (キャッシュが存在すれば、$testを作成する処理をスキップ)}}
    
?>
[[/src]]

[[対象となるデータの更新日付を指定してキャッシュからデータを取り出す|head:]]
このように使用することで、対象となるデータが更新されるまでキャッシュする動作が可能になります。

[[src]]
<?php
    
    require_once('fw/cache.csp');
    require_once('fw/basic_date.csp');
    
    $cm = CB_CacherManager::getInstance();
    $c =& $cm->getCacher( 'hoge' );
    
    {{// キャッシュ対象のファイルを読み込み、なんらかのデータをキャッシュする}}
    $c->set( 'id1', '...', 1 );
    
    ... {{//しばらくして }}
    
    $timestamp = filemtime( 'キャッシュ対象のファイル' );  {{ // キャッシュ対象データの更新日付を取得 }}
    
    {{ ////////////////////////////////////////////////////////////////// }}
    {{ // 対象となるデータの更新日付がキャッシュした時刻よりも新しい場合、}}
    {{ // キャッシュが無効になっていると判断しexpireされる。}}
    {{ // 尚、対象となる更新時刻にが設定されている場合最優先される。}}
    {{ // つまり、設定した生存時間をオーバーしていても、値の取得に成功し、}}
    {{ // キャッシュデータの方が新しく、有効と判断できれば値が取得できる。}}
    {{ ////////////////////////////////////////////////////////////////// }}
    
    {{ // キャッシュ対象データの更新日付より、キャッシュが新しければ取得できる。 }}
    $ret = $c->get( 'id1' , $value, $t );
    
?>
[[/src]]

[[キャッシュから強制的にデータを削除する|head:]]
[[src]]
<?php
    
    require_once('fw/cache.csp');

    $cm = CB_CacherManager::getInstance();
    $c =& $cm->getCacher( 'hoge' );

    {{// 指定したキャッシュIDのデータを削除する}}
    $c->remove('id1');
    
    {{// このキャッシャーに属するデータをすべて削除する}}
    $c->removeAll();
    
    {{// キャッシャーに関係なくすべてのデータをクリアする}}
    $cm->clean( 'db' );     {{// ファイルターゲットに対して }}
    $cm->clean( 'file' );   {{// データベースターゲットに対して }}
    
?>
[[/src]]

[[データの生存期間を確認する|head:]]
[[src]]
<?php
    
    require_once('fw/cache.csp');

    $cm = CB_CacherManager::getInstance();
    $c =& $cm->getCacher( 'hoge' );
    
    $c->set( 'id1', 'test', 100);
    if( !$c->get( 'id1', $data ) )
    {
        {{// 100秒経ってないので、絶対に通過しない}}
        echo "id1のデータ取得に失敗";
    }
    
    $c->set( 'id2', 'test', 1);
    sleep(1);
    if( !$c->get( 'id2', $data ) )
    {
        {{// 必ず通過する（生存時間1秒でsleepで1秒経過している為）}}
        echo "id2のデータ取得に失敗";
    }
    
    {{// ここでキャッシュを確認すると、id2が削除されていることが分かる}}
}
?>
[[/src]]

[[キャッシャーを階層化する|head:]]
''CB_Cacher'' は ''getChild()'' メソッドを通じて子キャッシャーを作成する機能を有しており、ツリー構造を持ちます。 
''getChild''で作成された、子キャッシャーは親キャッシャーのターゲットなどの設定を自動的に継承します。

''setCaching()'', ''setTarget()'', ''setLifeTime()''といったキャッシャーの設定を変更するメソッドは、子(孫)キャッシャーの設定にも再帰的に適用されます。
 {{ただし、一度でも''setCaching()'', ''setTarget()'', ''setLifeTime()''等のメソッドを使用して、設定を変更すると、その子(孫)キャッシャーには変更の再帰的な適用はされなくなる。これを ''設定の特化'' といいます。}}

キャッシャーはそれ自身でツリー構造をなすが、そのままではルート(根)となるキャッシャーごとに名前空間の異なるヒエラルキーが存在してしまう。 
そこで、CB_CacherManager はカテゴリー名を "." で連結した文字列で表現する名前空間を提供している。 

[[src]]
<?php

require_once( 'fw/cache.csp' );

$cm = CB_CacherManager::getInstance();


{{// 'foo' -> 'bar' -> 'zot' の関係のキャッシャーが構築される。}}
{{// (この際、foo, foo.barは自動的に生成されます。)}}
$zot =& $cm->getCacher( 'foo.bar.zot' );
$baz =& $cm->getCacher( 'foo.bar.baz' );

{{// ここで'bar'は 'zot'と 'baz'の2つのキャッシャーを子にもつ}}
$bar =& $cm->getCacher( 'foo.bar' );

{{// 'zot'を明示的にキャッシュすることを設定(設定を特化させる) }}
$zot->setCaching( TRUE );

{{// 'bar'以下のキャッシュを行わないように設定}}
$bar->setCaching( FALSE );

$zot->set( 'test', 'data' );    {{// データが書き込まれる(設定が特化しているので伝播しない)}}
$baz->set( 'test', 'data' );    {{// データが書き込まれない }}
$bar->set( 'test', 'data' );    {{// データが書き込まれない( 設定が伝播したため ) }}

?>
[[/src]]

[[設定ファイルをマスターする|head:]]
キャッシャー設定ファイルはセクション付き ini ファイルであり、以下の仕様となっている。 
*セクション宣言がない場合、デフォルト(ルート)キャッシャーの設定として扱う 
*セクション名は CB_CacherManager の名前空間で扱われるキャッシャーの階層名として扱う 

各セクションで有効なキーとその意味は以下の表に示す通りです。 

[[html]]
<table class=cb_doc_table border="1">
<tr>
<th nowrap>キー</th>
<th nowrap>値</th>
<th nowrap>値の例</th>
<th nowrap>説明</th>
</tr>
<tr>
<td nowrap>target</td>
<td>ターゲット名</td>
<td nowrap>db</td>
<td>
CB_CacheTargetFactory::getTarget() に渡すキャッシュターゲット名を指定する。
キャッシュターゲットはプラグインによって実装されているため、"code/plugin/cacher/*.csp"のファイル名を渡す。
</td>
</tr>

<tr>
<td nowrap>caching</td>
<td>キャッシュのON/OFF</td>
<td nowrap>1</td>
<td>
キャッシュを使用する場合は ''1'', しない場合は ''0''を設定する。
</td>
</tr>

<tr>
<td nowrap>lifetime</td>
<td>生存時間</td>
<td nowrap>1</td>
<td>
キャッシュデータの生存時間(経過秒数)を設定する。秒数経過後、キャッシュデータが自動で無効になります。
</td>
</tr>

</table>
[[/html]]

以下にサンプルを示します。
設定ファイルの内容の反映に CB_Cacher の各設定メソッド(''setCaching()'', ''setTarget()'', ''setLifeTime()'')を使用しているため、共通した動作を保証できています。 

[[src]]
{{;;; Cacher configuration file}}

{{;; Default configuration.}}
caching = 1
lifetime = 3600
target = db

''[foo]''
caching = 1
lifetime = 10
target = db

''[foo.bar]''
caching = 1
lifetime = 20
target = file

''[hoge.fuga]''
caching = 1
lifetime = 30
target = file

[[/src]]
 ここでの場合を簡単に説明すると、''foo'' や ''foo.bar''は設定されたものが使用される。''foo.bar.zot''に関しては、
キャッシャーを作成すると、''foo.bar''の設定を自動的に引き継ぐ。''hoge''を作成すると、設定がないのでデフォルトが使用される。
''hoge.fuga''は設定があるのでそれが使用されます。
 サンプル中で言及されている設定の伝播の仕方については、詳しくは前節の説明を参照してください。

[[Smartyキャッシュ機構のチュートリアル|section:tutorial2]]

[[設定ファイルを使用する|head:]]
Smartyの設定ファイルは [[common.ini|doc:ext/config#common.ini]] の[Smarty] に記述されています。
 キャッシュで使用するのは「caching」です。これによってSmarty全体のキャッシュ有無を切り替えることになります。
 （これを無効に設定すると、たとえsmartyに対してキャッシュを出力するように設定してもキャッシュが行われません。）

[[キャッシュにデータを追加する|head:]]
[[src]]
<?php
    
    require_once('fw/smarty_bridge.csp');

    $s = new CB_Smarty;

    {{// ここで1が設定され、}}
    {{// 尚かつcommon.iniのキャッシュがオンのときキャッシュされる}}
    $s->caching = 1;

    {{// sample.tplに結びついたキャッシュを作成する}}
    $s->display( 'sample.tpl' );

    {{// idを振ることによって、同一テンプレートのデータを複数キャッシュする}}
    $s->display( 'sample.tpl', 'id_username_setting' );
}
?>
[[/src]]

[[キャッシュからデータを取り出す|head:]]
キャッシュが存在する場合、assignを呼んでデータを設定しなくても、キャッシュを使っての表示を自動で行ってくれる。
[[src]]
<?php
    
    require_once('fw/smarty_bridge.csp');

    $s = new CB_Smarty;
    $s->caching = 1;

    if( !$s->is_cached( 'sample.tpl', 'id1' ) )
    {
        {{// $dataを作成する}}
            
        $s->cache_lifetime = 10;       {{// デフォルトでは3600秒}}
        $s->assign( 'data', $data );
    }

    {{// あまり長いキャッシュIDを渡すと例外が発生する}}
    $s->display('sample.tpl', 'id1');
}
?>
[[/src]]

[[キャッシュから強制的にデータを削除する|head:]]
[[src]]
<?php

    require_once('fw/smarty_bridge.csp');

    $s = new CB_Smarty;
    $s->caching = 1;
    
    {{// sample.tplのキャッシュを削除する}}
    $s->clear_cache('sample.tpl');
    
    {{// idで指定されたキャッシュを削除する}}
    $s->clear_cache('sample.tpl', 'id1'); 

    {{// すべてのキャッシュを削除する}}
    $s->clear_all_cache();
    
?>
[[/src]]

[[設計上の理由|section:rationale]]
[[html]]
<dl>
<dt>Q. PEAR::Cacheを採用しなかった理由</dt>
<dd>
全体的に無駄なものが多く、azaleaのアーキテクチャにそぐわないと判断したため。<br>
特にコンテナでは、DBだけで同じようなものが3種類あり、毎回ユーザーが常に指定するので変更も大変。<br>
ここだけみても、永続化レイヤーで書き換えるべきだと感じた。<br>
共有メモリを使ったものもあったが、unixでしか動かないためそれも利用できない。<br>
Cacheクラスの派生にユーテリティとなるクラスがたくさんあるが、azaleaではsmartyを使う都合上機能がかぶる。
</dd>

<dt>Q. PEAR::Cache_Liteを採用しなかった理由</dt>
<dd>
出力先としてファイル固定として組み込まれていて拡張性はない。（その分処理はかるく高速だが）<br>
３層構成(クライアント、webサーバ、dbサーバ)でキャッシュを行う際には、データベース、ファイルによるメリットがそれぞれあるが、Smarty(常にファイルへのキャッシュ)とのからみを考えるとデータベースへの対応を強化する必要があると考えた。
また、バックエンドとして「[[memcached|http://www.danga.com/memcached/]]」なんかも簡単に取り込めるようにするため、出力先のコンテナには柔軟に対応したかった。<br>
（パフォーマンスなどの問題が起こった際に逃げ道を作っておく意味もある）<br>
また、メモリにキャッシュする機構が中途半端かつ不要だったこともあり、使用しないことにしました。
</dd>

<dt>Q. PEAR::CacheでいうCache_Output、Cache_DB, Cache_Functionなどのユーテリティが用意されていないのはなぜか？</dt>
<dd>
Smartyを使う以上、処理から直接データのアウトプットはありえない為、すべて不要と考えました。<br>
細かく見てみると、Cache_DBは出力バッファリング + クエリキャッシュの役割をするが、azaleaではクエリキャッシュはMySQLそのものが、出力バッファリングはsmartyでするべき。<br>
Cache_Functionも関数の出力バッファリングを助けるが同等の理由で使い道がない。あったも間違った使い方をするだけと判断した。
</dd>

<dt>Q. ファイルやデータベースの依存関係を実装しなかった理由</dt>
<dd>
依存関係はモデルにしか分からないことなので、キャッシュ機構自体に組み込むことはしませんでした。<br>
テーブルなどをキーにして、永続化レイヤーなどの仕組みに直接組み込もうかとも思いましたが汎用的なものにならなそうだったので追加しませんでした。
</dd>

</dl>
[[/html]]

[[リファレンス|section:reference]]
[[フレームワークソース|head:]]
*[[include/fw/cache.csp]]
*[[plugin/fw/cache/db.csp]]
*[[plugin/fw/cache/file.csp]]
