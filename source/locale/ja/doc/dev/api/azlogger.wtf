[[概要|section:abstract]]
本文書ではアゼリアのロギング用ツールキットである ''AzLogger (エーズロガー)'' を解説する。

ロギングとは、アプリケーション内部の動作を記録することである。例えばログインやエラー、設定の変更といった動作を、ファイルやメール、データベースといった手段で記録・通知する等が挙げられる。
 
AzLogger は、高速性とエンドユーザーの使い勝手を主眼として設計された、アゼリアベースのアプリケーションためのロギングツールキットである。以下に挙げる特徴を備えている。

#ヒエラルキ(階層)ロガー
#データベースロギング
#簡単な API, 強力な拡張性
#ロガー設定ファイル
#プラグイン可能なログターゲット

図などを用いた説明が [[勉強会資料|cb6:page=FileView&gid=3561&fCID=174643&fFID=174659]] にあるので、そちらも参照して欲しい。
[[用語|section:term]]

[[html]]
<table class="cb_doc_table" border="1">
<tr><th nowrap>用語</th><th nowrap>解説</th></tr>
<tr>
<td nowrap>ロガー</td>
<td>
ロギング用のAPIを提供するオブジェクト。
''カテゴリー''ごとに存在し、''ログイベント''を生成する。<br>
AzLogger では CB_Logger クラスで表現される。
</td>
</tr>

<tr>
<td nowrap>ログイベント</td>
<td>
動作内容やその付帯状況(日時、ユーザーなど)の記録を表すオブジェクト。<br>
AzLogger では CB_LogEvent クラスで表現される。
</td>
</tr>

<tr>
<td nowrap>ログターゲット</td>
<td>
''ロガー''から''ログイベント''を受け取り、処理するオブジェクト。<br>
AzLogger では CB_LogTarget インターフェースを実装するクラスで表現される。
</td>
</tr>

<tr>
<td nowrap>カテゴリー</td>
<td>
ログの分類区分。AzLogger ではツリー状の階層で、ノードごとに名前を持つ。<br>
例: "hoge''.''fuga" はカテゴリー "''hoge''" の下のサブカテゴリー "''fuga''"
</td>
</tr>

<tr>
<td nowrap>プライオリティ</td>
<td>
ログの重要度を表す。AzLogger では以下の 5 段階のいずれかを指定する。上のものほど重要(プライオリティが高い)。
<table style="border: 0px none;">
<tr><td style="border: 0px none; padding: 0;">1.</td><td style="border: 0px none; padding: 0;">''critical''</td><td style="border: 0px none; padding: 0;">&nbsp;</td><td style="border: 0px none; padding: 0;">(致命的なエラー)</td></tr>
<tr><td style="border: 0px none; padding: 0;">2.</td><td style="border: 0px none; padding: 0;">''error''</td><td style="border: 0px none; padding: 0;">&nbsp;</td><td style="border: 0px none; padding: 0;">(エラー)</td></tr>
<tr><td style="border: 0px none; padding: 0;">3.</td><td style="border: 0px none; padding: 0;">''warning''</td><td style="border: 0px none; padding: 0;">&nbsp;</td><td style="border: 0px none; padding: 0;">(警告)</td></tr>
<tr><td style="border: 0px none; padding: 0;">4.</td><td style="border: 0px none; padding: 0;">''notice''</td><td style="border: 0px none; padding: 0;">&nbsp;</td><td style="border: 0px none; padding: 0;">(重要な情報)</td></tr>
<tr><td style="border: 0px none; padding: 0;">5.</td><td style="border: 0px none; padding: 0;">''debug''</td><td style="border: 0px none; padding: 0;">&nbsp;</td><td style="border: 0px none; padding: 0;">(情報一般、および開発者用の情報)</td></tr>
</table>
</td>
</tr>
</table>
[[/html]]

[[設計|section:design]]

[[ユースケース|head:usecase]]
AzLogger では以下のユースケースをサポートする。

#管理者が、監視や管理の目的でログを確認する
#開発者が、製品機能としてログ情報の一覧や検索、統計を提供する
#開発者が、デバッグ用の情報を開発時に出力し、出荷後は抑制する
#SE や SIer が、トラブルシューティングの情報を製品出荷後に追加出力させる

以下のユースケースはサポートしない。
*一時的にデバッグ用の情報を書き出す

[[要件|head:requirement]]
要件がどのユースケースに対応しているのかを明示するため、「''ユースケース番号'' + アルファベット」形式で識別子を振ってある。

[[html]]
<table class="cb_doc_table" border="1">
<tr>
<td nowrap valign="top">1-a.</td>
<td>
syslog などのシステムロガーに出力できる
</td>
</tr>
<tr>
<td nowrap valign="top">1-b.</td>
<td>
ログをカテゴリーで分類できる
<ul style="margin-top: 0; margin-bottom: 0;">
<li>カテゴリーごとに設定を変更したい。例えば特定アプリケーションのログのみ保存する場合等。
</ul>
</td>
</tr>
<tr>
<td nowrap valign="top">1-c.</td>
<td>
ログを重要度で分類できる
<ul style="margin-top: 0; margin-bottom: 0;">
<li>重要度に応じて通知方法などを変更したい。緊急の場合、メールで通知など。
</ul>
</td>
</tr>
<tr>
<td nowrap valign="top">1-d.</td>
<td>
ログ出力の設定が簡単に変更できる
<ul style="margin-top: 0; margin-bottom: 0;">
<li>エンドの管理者や SIer のスキルはサイボウズの開発者より低いと想定。
</ul>
</td>
</tr>
<tr>
<td nowrap valign="top">2-a.</td>
<td>
書き出したログをプログラムから参照して再利用できる
</td>
</tr>
<tr>
<td nowrap valign="top">3-a.</td>
<td>
既存のコードに容易にログを追加できる
</td>
</tr>
<tr>
<td nowrap valign="top">3-b.</td>
<td>
デバッグ情報のログが出荷版の性能に影響しない
<ul style="margin-top: 0; margin-bottom: 0;">
<li>理想的にはロギングコードの除去。
<li>現実的には if 文をコールサイトで指定して、ログメッセージ用の処理を回避。
</ul>
</td>
</tr>
<tr>
<td nowrap valign="top">4-a.</td>
<td>
プラグイン機構と親和性を高め、どこからでもログの出力を可能とする
</td>
</tr>
<tr>
<td nowrap valign="top">4-b.</td>
<td>
ログ出力の設定方法をサイボウズ製品間で共通のものとする
<ul style="margin-top: 0; margin-bottom: 0;">
<li>サイボウズ製品に通じた SIer であれば、どの製品でもトラブルシュート可能が理想。
</ul>
</td>
</tr>
</table>
[[/html]]

[[設計方針|head:policy]]
上記のユースケースと要件、およびアゼリアのアーキテクチャから以下の設計方針を立て、設計を進めた。

*性能重視
 アゼリアは CGI ベースを基本とするため、ロガーの初期化や設定ファイルの読み込みはリクエスト毎に行われる。極力性能への悪影響を避けるため、初期化や設定ファイルは処理工数を削減することを重視した。
*十分な拡張性と小さなコア
 フレームワークで提供するツールキットであるため、設定方法を除き出力の形式や手段は各製品に完全に委ねる選択をした。結果として AzLogger はコア 2 クラス 1 インターフェース、全 5 クラス 1 インターフェースの構成となった。

これらの方針に沿う既存のロギングツールを調査したところ、[[Avalon LogKit|http://avalon.apache.org/logkit/]] の設計が好ましかったため、これを参考にクラス構成などを設計した。ユースケースの違いなどから、結果としての機能セットには大きな差が生じることになった。

[[アーキテクチャ|head:architecture]]
クラス図は [[勉強会資料|cb6:page=FileView&gid=3561&fCID=174643&fFID=174659]] にある。ここでは各クラスの役割(ロール)と関係、および挙動の詳細を解説する。

クラス全体の構成は、''コア'' と ''ユーティリティ'' に分類される。コアクラスを明確に分類している理由は、柔軟な拡張性を担保するためである。ユーティリティクラスに絶対に依存しない設計とするには、何がコアかをまず定義する手法が有効である。

[[html]]
<table class=cb_doc_table border="1">
<tr><th nowrap>分類</th><th>クラス名</th><th>役割(ロール)と機能</th></tr>
<tr>
<td nowrap rowspan="3">コア</td>
<td nowrap>[[az:fw.logger:CB_Logger]]</td>
<td>
ログを発行する API を提供する。<br>
実際の発行ロジックは [[勉強会資料|cb6:page=FileView&gid=3561&fCID=174643&fFID=174659]] 中の、「CB_Logger の処理フロー」に示す通り。

*特定プライオリティのログを発行
*ログイベントの生成につながるプライオリティの閾値を保持・設定
*特定プライオリティでログイベントが発行されるかのテストメソッドを提供
*ログターゲットを全体あるいはプライオリティごとに 1 つ指定可能
*子を持つことができ、全体でツリー構造をなす

</td>
</tr>

<tr>
<td nowrap>[[az:fw.logger:CB_LogEvent]]</td>
<td>
CB_Logger が発行したログの情報を保持する。
*[[永続化レイヤー|doc:pg/basic/persistent]] の [[az:fw.persistent:CB_PersistentBase]] を継承した永続化クラス
*データベースロギングが不要な場合は、一時オブジェクトを生成
</ul>
</td>
</tr>

<tr>
<td nowrap>[[az:fw.logger:CB_LogTarget]]</td>
<td>
ログイベントを受け付けるクラスの''インターフェース''を定義。
</td>
</tr>

<tr>
<td nowrap rowspan="3">ユーティリティ</td>
<td nowrap>[[az:fw.logger:CB_LoggerConfig]]</td>
<td>
ロガー設定ファイルを読み込む。[[az:fw.core:CB_ConfigManager]] を継承・拡張しているため、ロガー設定ファイルはセクション付き .ini ファイルである。
</td>
</tr>

<tr>
<td nowrap>[[az:fw.logger:CB_LoggerManager]]</td>
<td>
CB_Logger のひとつの名前空間を規定する。
*インスタンスは唯一つ(シングルトン)
*"''foo.bar''" といった、"." で区切られた階層名で CB_Logger を管理する
*CB_LoggerConfig の設定を作成した CB_Logger に適用する
</td>
</tr>

<tr>
<td nowrap>[[az:fw.logger:CB_LogTargetFactory]]</td>
<td>
CB_LogTargetインターフェースを実装したクラスのオブジェクトを生成するファクトリ。
*インスタンスは唯一つ(シングルトン)
*名前で指定されたログターゲットを返す
*[[汎用プラグイン機構|doc:pg/basic/plugin]] を利用して、動的にログターゲットを検出し作成する
*名前をつけてログターゲットを登録する
</td>
</tr>
</table>
[[/html]]

コアではログを書き出すイベントの発生とその処理を、クラス CB_LogEvent と CB_LogTarget としてロガーから分離している。ログの処理方法はカスタマイズ要求が大きいと予想されるため、柔軟な変更が可能な構成とするためである。

ログの統計などを行うアプリケーションをサポートするための、ログ情報のデータベースへの保存(''データベースロギング'')は、永続化クラスを利用して自動的に達成される設計とした。

エンドユーザや SIer に向けた使い勝手の良さを達成する部分は、ユーティリティという位置付けで提供される。具体的には ini ファイル形式の設定ファイルや、プラグイン可能なログターゲットなどである。

[[Step by Step チュートリアル|section:tutorial]]

[[設定ファイルを確認する|head:step1]]
AzLogger の設定ファイルは、CGIディレクトリの "logger.ini" ファイルとなっているはずである。
 正確には、[[common.ini|doc:ext/config#common.ini]] の [Logger] config 設定で指定されているファイルである。

設定ファイルの内容が以下のようになっていることを確認せよ。


[[src]]
{{;;; AzLogger configuration file}}

{{;; Default configuration.}}
threshold	= error

{{; ... 省略 ...}}
[[/src]]

ini ファイル形式の記述で、ファイルの先頭(セクション指定の前)の記述内容が、全てのロガーのデフォルト設定となる。"''threshold = error''" という設定は、ログイベントを生成する閾値を、プライオリティ "error" 以上とする。

[[ロガーを作成し、ログを出力する|head:step2]]
以下のようにスクリプトを作成し、実行してみよ。その後データベースに自動的に保存されるログを [[こちら|run:developer/demo_dumplog]] で確認してみよ。

[[src]]
<?php
{{// ロギングAPI}}
require_once( 'fw/logger.csp' );

{{// シングルトンを得る}}
$lm = CB_LoggerManager::getInstance();

{{// "fuga" カテゴリーのロガーを得る}}
$logger =& $lm->getLogger( 'fuga' );

{{// "error" プライオリティでログを出力する}}
$logger->error( 'あいうえお' );
?>
[[/src]]

結果は以下のようなテーブルとなるはずである。見ての通り、AzLogger はログの記録時にタイムスタンプやログインユーザー名などの情報も同時に採取している。

[[html]]
<table class=cb_doc_table border="1">

<tr>
<th nowrap>ID</th>
<th nowrap>timestamp</th>
<th nowrap>category</th>
<th nowrap>priority</th>
<th nowrap>msg</th>
<th nowrap>user</th>
<th nowrap>account</th>
<th nowrap>remote_host</th>
<th nowrap>remote_addr</th>
</tr>

<tr><td>1</td><td>1077716474</td><td>fuga</td><td>4</td><td>あいうえお</td><td></td><td></td><td>hyamamoto.dev.cybozu.co.jp</td><td>10.0.1.167</td></tr>
</table>
[[/html]]

ログ出力メソッドは [[php:sprintf]] を使用して以下のようにパラメータをフォーマットする機能も有する。

[[src]]
<?php
require_once( 'fw/logger.csp' );
$lm = CB_LoggerManager::getInstance();
$logger =& $lm->getLogger( 'fuga' );

$logger->error( "''パラメータ1: %d\nパラメータ2: %s''", 25, 'ほげ' );
?>
[[/src]]

[[閾値を変更して挙動を確認する|head:step3]]
以下のように、"error" より低いプライオリティでログの出力を試みよ。

[[src]]
<?php
require_once( 'fw/logger.csp' );
$lm = CB_LoggerManager::getInstance();
$logger =& $lm->getLogger( 'fuga' );

{{// "debug" プライオリティで出力する}}
$logger->''debug''( 'デバッグだよ' );
?>
[[/src]]

[[こちら|run:developer/demo_dumplog]] で確認しても、ログは追加されていないはずである。
 これはデフォルトのプライオリティの閾値が "error" であるため、"debug" プライオリティのログではログイベントが生成されないためである。

プライオリティの閾値はロガー設定ファイルを変更するか、CB_Logger::setThreshold() にて明示的に設定可能である。ここでは後者の方法で設定する。

[[src]]
<?php
require_once( 'fw/logger.csp' );
$lm = CB_LoggerManager::getInstance();
$logger =& $lm->getLogger( 'fuga' );

{{// 閾値を "debug" に上げる}}
{{// CB_LOGGER_{DEBUG,NOTICE,WARNING,ERROR,CRITICAL} 定数で指定する}}
''$logger->setThreshold( CB_LOGGER_DEBUG );''

{{// "debug" プライオリティで出力する}}
$logger->debug( 'デバッグだよ' );
?>
[[/src]]

[[こちら|run:developer/demo_dumplog]] 確認すると、以下のようにログが追加されているはずである。"priority" の数値が高くなっている点に注目せよ。

[[html]]
<table class=cb_doc_table border="1">

<tr>
<th nowrap>ID</th>
<th nowrap>timestamp</th>
<th nowrap>category</th>
<th nowrap>priority</th>
<th nowrap>msg</th>
<th nowrap>user</th>
<th nowrap>account</th>
<th nowrap>remote_host</th>
<th nowrap>remote_addr</th>
</tr>

<tr><td>2</td><td>1077717664</td><td>fuga</td><td>**10**</td><td>デバッグだよ</td><td></td><td></td><td>hyamamoto.dev.cybozu.co.jp</td><td>10.0.1.167</td></tr>
<tr><td>1</td><td>1077716474</td><td>fuga</td><td>4</td><td>あいうえお</td><td></td><td></td><td>hyamamoto.dev.cybozu.co.jp</td><td>10.0.1.167</td></tr>
</table>
[[/html]]

[[ログを書き出す前に閾値をチェックする|head:step4]]
ログの出力には、しばしば書き出すための情報を準備するなどの余分な計算を伴う。
 さらに、プライオリティの低いログほど出力機会が多いことが一般的であるため、出荷した製品や、トラブルの発生していない状態では "debug" や "notice" プライオリティのログを出力するコードが性能を圧迫する可能性は高い。

この問題の解消には、もちろんロギングコード自体を削除してしまうことが有効ではあるが、いざ低プライオリティのログが必要になった場合に、設定を変更してもログが出てこなくなるという別の問題が発生する。

そこで AzLogger では、あるプライオリティでログイベントを生成するか否かを返す API を用意している。
 開発者はそれを用いて、if 文などでロギングコードをくくることで性能の劣化を抑えることができる。

[[src]]
<?php
require_once( 'fw/logger.csp' );
$lm = CB_LoggerManager::getInstance();
$logger =& $lm->getLogger( 'fuga' );

{{// "debug" プライオリティが有効か検査する}}
if( $logger->''isDebugEnabled()'' )
{
    echo '重い処理';
    $logger->debug( 'デバッグだよ' );
}
?>
[[/src]]

上記のコードを実行して、画面に "重い処理" という文字列が ''描画されない'' ことを確認せよ。

[[ログターゲットを作成して使用する|head:step5]]
ここまでは AzLogger の ''データベースロギング'' 機能のみを利用してログの出力を確認していた。
 だが、ログイベントの発生時に例えばメールで通知したり、ファイルに書き出したりといったような処理が望まれることはしばしばある。

AzLogger では [[az:fw.logger:CB_LogTarget]] インターフェースを実装したクラスを用意してロガーに設定することで、ロガーの発生するログイベントの処理を行わせることが可能である。
 なお、データベースロギング機能はログターゲットの指定とは独立している。

[[src]]
<?php
require_once( 'fw/logger.csp' );
$lm = CB_LoggerManager::getInstance();
$logger =& $lm->getLogger( 'fuga' );

{{// ログメッセージを画面にエコーするログターゲット}}
class EchoTarget ''extends CB_LogTarget''
{
    // $event は CB_LogEvent オブジェクト
    function ''processEvent''( & $event )
    {
        echo $event->msg;
    }
}

{{// EchoTarget を設定する}}
$logger->''setTarget''( new EchoTarget() );

$logger->critical( '致命傷' );
?>
[[/src]]

上記を実行すると、画面に "致命傷" とエコーされる。
 同時にデータベースにも書き込まれていることを [[こちら|run:developer/demo_dumplog]] で確認せよ。
 このように、''processEvent'' メソッドの記述次第でメールでの通知や syslog へのフォワードを実現できる。

[[特定プライオリティ用のログターゲットを指定する|head:step6]]
ログイベントの処理は、しばしばプライオリティごとに変更したくなるケースが存在する。
 例えば致命的なエラーの際にはメールで通知するが、通常時には特に何もしない場合などである。

一つの手段としては、前の例で示したように ''CB_LogTarget::processEvent()'' 中で ''$event->priority'' の値を参照して挙動を変えるログターゲットを実装することが考えられる。

[[src]]
class ComplexTarget extends CB_LogTarget
{
    function processEvent( & $event )
    {
        if( ''$event->priority == CB_LOGGER_CRITICAL'' )
        {
            {{// メールで通知するなどの処理}}
        }
    }
}
[[/src]]

しかしこの方法は挙動をハードコーディングしてしまうため、設定の柔軟性が損なわれる。
 また、もし既にメールでの通知を行うログターゲットが存在したとしても、同様の処理を再度実装する ''二重化'' の問題も出てくる。

そこで AzLogger では、プライオリティごとにログターゲットを設定する機能を提供している。
 これは前節で説明した、ロガー単位のログターゲットよりも優先して使用される。

[[src]]
<?php
require_once( 'fw/logger.csp' );
$lm = CB_LoggerManager::getInstance();
$logger =& $lm->getLogger( 'fuga' );

class EchoTarget extends CB_LogTarget
{
    function processEvent( & $event )
    {
        echo $event->msg;
    }
}

{{// ロガーのターゲット設定を無効にする (参照なので変数を介す)}}
$dummy = null;
$logger->setTarget( $dummy );

{{// "critical" ログだけ、EchoTarget を使用する}}
$logger->setTarget( new EchoTarget(), ''CB_LOGGER_CRITICAL'' );

$logger->error( 'このメッセージはエコーされない' );
$logger->critical( '致命傷' );
?>
[[/src]]

画面には "critical" なログだけがエコーされるはずである。
 データベースには "error", "critical" 双方共に記録されていることを [[こちら|run:developer/demo_dumplog]] で確認せよ。

[[ログターゲットをプラグインとして実装する|head:step7]]
顧客から開発時に想定しないようなログの出力先や方法を要求される場合などに備えて、AzLogger ではログターゲットを動的に拡張する機能を、''CB_LogTargetFactory'' を通じて提供している。

以下の内容のスクリプトを、"code/plugin/logger/echo.csp" として保存せよ。
 [[汎用プラグイン機構|doc:pg/basic/plugin]] を使用するため、クラス名は "''plugin_logger_echo''" となる。
 詳細は [[code/plugin/logger/index.html]] を参照せよ。

[[src]]
<?php
require_once( 'fw/logger.csp' );
class ''plugin_logger_echo'' extends CB_LogTarget
{
    function processEvent( & $event )
    {
        echo $event->msg;
    }
}
?>
[[/src]]

このようにして用意したログターゲットは、ファイル名から拡張子を除いた "echo" という名前でファクトリから取得できる。

[[src]]
<?php
require_once( 'fw/logger.csp' );

$factory = ''CB_LogTargetFactory''::getInstance();
var_dump( $factory->getLogTarget( '''echo''' ) );
?>
[[/src]]

このように文字列からログターゲットを生成できるようにしたことで、後述する設定ファイル中でプラグインしたファイル名を指定するだけで、動的なログターゲットの変更が可能となる。

[[データベースロギングを停止する|head:step8]]
これまで見てきたように、AzLogger は生成したログイベントを自動的にデータベースに記録する。
 もし特定のロガーでこの機能が不要な場合には、''CB_Logger::setDbLogging()'' メソッドを使用して自動記録を停止できる。

[[src]]
<?php
require_once( 'fw/logger.csp' );
$lm = CB_LoggerManager::getInstance();
$logger =& $lm->getLogger( 'fuga' );

$logger->''setDbLogging( FALSE )'';
$logger->error( 'DBに記録されない' );
?>
[[/src]]

上の例を実行した後、[[こちら|run:developer/demo_dumplog]] でデータベースにログが追加されていないことを確認せよ。

[[データベース内のログを検索する|head:step9]]
データベースに記録されたログは、''CB_LogEvent'' テーブルに保存されている。
 下のように通常の永続化レイヤーの検索 API を使用することで、自由に絞り込みやソートを施した結果を取得できる。

[[src]]
<?php
require_once( 'fw/logger.csp' );
$lm = CB_LoggerManager::getInstance();

{{// getLogTable() は "CB_LogEvent" テーブルのオブジェクトを返す}}
$rowset = new CB_RowSet( $lm->getLogTable() );

{{// 1 時間以上前のログを消去する}}
$t = time() - 3600;
$rowset->addCondition("col_timestamp < $t");
while( ! is_null( $row =& $rowset->iterate() ) )
{
    $row->delete();
}
?>
[[/src]]

[[ロガーを階層化する|head:step10]]
''CB_Logger'' は ''getChild()'' メソッドを通じて子ロガーを作成する機能を有しており、ツリー構造を持つ。
 ''getChild()'' で作成された子ロガーは、親ロガーの閾値やログターゲットなどの設定を自動的に継承する。

これまでに見てきた ''setThreshold()'', ''setTarget()'', ''setDbLogging()'' といったロガーの設定を変更するメソッドは、実際には子(孫)ロガーにも設定の変更を再帰的に適用している。
 ただし、{{継承した設定を一度でも setThreshold(), setTarget(), setDbLogging() といったメソッドで変更すると、その子(孫)ロガー以降には変更の再帰的な適用はされなくなる。}}
 これを {{設定の特化}} と呼ぶ。

ロガーはそれ自身でツリー構造をなすが、そのままではルート(根)となるロガーごとに名前空間の異なるヒエラルキーが存在してしまう。
 そこで、''CB_LoggerManager'' はカテゴリー名を "." で連結した文字列で表現する名前空間を提供している。

[[src]]
<?php
require_once( 'fw/logger.csp' );
$lm = CB_LoggerManager::getInstance();

{{// "foo" -> "bar" -> "zot" という関係のロガーで最後の "zot" を得る}}
{{// "foo", "foo.bar" は自動的に作成される}}
$zot =& $lm->getLogger( '''foo.bar.zot''' );

{{// "foo" -> "bar" -> "baz" の "baz" を得る}}
$baz =& $lm->getLogger( 'foo.bar.''baz''' );

{{// "foo" -> "bar" の "bar" を得る}}
$bar =& $lm->getLogger( 'foo.''bar''' );

{{// "bar" が "zot" と "baz" の 2 つの子ロガーを持つことを確認}}
{{// ( "_children" はプライベートメンバー変数なので、本当はダメ )}}
var_dump( array_keys( $bar->_children ) );
echo '<br>';

{{/*}}
{{ * 設定の変更・継承の実験}}
{{ * "_threshold" もプライベートメンバー変数なので、本当はダメ}}
{{ */}}

{{// "zot" の閾値を "debug" にする}}
$''zot''->setThreshold( CB_LOGGER_DEBUG );

{{// "bar" の閾値を "critical" にする}}
$''bar''->setThreshold( CB_LOGGER_CRITICAL );

{{// "baz" には閾値が再帰的に伝播する}}
echo "baz priority: ", $''baz''->_threshold, '<br>';

{{// "zot" には伝播していない}}
echo "zot priority: ", $''zot''->_threshold;
?>
[[/src]]

[[ロガー設定ファイルをマスターする|head:step11]]
ロガー設定ファイルはセクション付き ini ファイルであり、以下の仕様となっている。

*セクション宣言がない場合、デフォルト(ルート)ロガーの設定として扱う
*セクション名は ''CB_LoggerManager'' の名前空間で扱われるロガーの階層名として扱う

各セクションで有効なキーとその意味は以下の表に示す通りである。

[[html]]
<table class=cb_doc_table border="1">
<tr>
<th nowrap>キー</th>
<th nowrap>値</th>
<th nowrap>値の例</th>
<th nowrap>説明</th>
</tr>
<tr>
<td nowrap>threshold</td>
<td>"debug", "notice", "warning", "error", "critical"</td>
<td nowrap>"error"</td>
<td>
ロガーの閾値。デフォルトでは "critical" でさえなく、ログイベントを一切生成しない。
</td>
</tr>
<tr>
<td nowrap>db_logging</td>
<td nowrap>0, 1</td>
<td nowrap>0</td>
<td>
データベースロギングの有効無効を指定する。0 なら無効、1 なら有効。デフォルトは有効。
</td>
</tr>
<tr>
<td nowrap>target</td>
<td nowrap>"null", ログターゲット名</td>
<td nowrap>"echo"</td>
<td>
<tt>CB_LogTargetFactory::getLogTarget()</tt> に渡すログターゲット名を指定する。ログターゲットをプラグインしている場合は、ファイル名となる。例のように "echo" であれば、"code/plugin/logger/echo.csp" をプラグインしているはず。"''null''" を指定するとログターゲットの設定は解除される。デフォルトは "null"。
</td>
</tr>
<tr>
<td nowrap>critical</td>
<td nowrap>"null", ログターゲット名</td>
<td nowrap>"echo"</td>
<td>
target 同様だが、"critical" プライオリティのログにのみ適用されるログターゲットを設定する。
</td>
</tr>
<tr>
<td nowrap>error</td>
<td nowrap>"null", ログターゲット名</td>
<td nowrap>"echo"</td>
<td>
target 同様だが、"error" プライオリティのログにのみ適用されるログターゲットを設定する。
</td>
</tr>
<tr>
<td nowrap>warning</td>
<td nowrap>"null", ログターゲット名</td>
<td nowrap>"echo"</td>
<td>
target 同様だが、"warning" プライオリティのログにのみ適用されるログターゲットを設定する。
</td>
</tr>
<tr>
<td nowrap>notice</td>
<td nowrap>"null", ログターゲット名</td>
<td nowrap>"echo"</td>
<td>
target 同様だが、"notice" プライオリティのログにのみ適用されるログターゲットを設定する。
</td>
</tr>
<tr>
<td nowrap>debug</td>
<td nowrap>"null", ログターゲット名</td>
<td nowrap>"echo"</td>
<td>
target 同様だが、"debug" プライオリティのログにのみ適用されるログターゲットを設定する。
</td>
</tr>
</table>
[[/html]]

以下にサンプルを示す。サンプル中で言及されている設定の伝播の仕方については、前節の説明を参照のこと。
 設定ファイルの内容の反映に CB_Logger の各設定メソッド(''setThreshold()'', ''setTarget()'', ''setDbLogging()'')を使用しているため、共通した動作を保証できている。

[[src]]
{{;; デフォルトの設定}}
threshold = debug
db_logging = 0

{{;; foo.bar ロガーとその子孫の設定}}
[foo.bar]
db_logging = 1
target = mail

{{;; foo ロガーとその子孫 ("foo.bar" を除く)の設定}}
{{;; セクションの出現順序は無関係}}
[foo]
target = syslog
[[/src]]

[[設計上の理由|section:rationale]]

[[html]]
<dl>
<dt>Q. Avalon LogKit との差異とその理由</dt>
<dd>
結果として大きく異なる機能セットを持つことになったが、そのうち機能制限に見える部分を説明する。
*AzLogger ではログターゲットを一つしか指定できない
 この指摘は正確ではない。
 AzLogger ではロガー全体と各プライオリティごとにログターゲットを設定可能であり、後者の点に関しては Avalon LogKit の機能を上回る柔軟性を備えている。
 設定メソッド(''CB_Logger::setTarget()'')がログターゲットを一つしか受け取らないようにした理由は、API の簡便性および「ログターゲットをまとめるログターゲット」を作成できると踏んだからである。
*ログフォーマッタが存在しない
 AzLogger は Avalon にはない "データベースロギング" 機能を提供している。
 そのためログターゲットの指定は補助的であり、ログフォーマッタの必要性も薄いと判断した。
</ul>
</dd>

<dt>Q. なぜ一時的なデバッグ用の出力の用途を除外したのか</dt>
<dd>
一時的なデバッグ用の出力では、極力開発者の工数(キータイプ数)を削減することが求められる。AzLogger のその他のユースケースは主に管理の容易さや柔軟な拡張可能性を目指していて、開発者の工数を最小化することではない。この矛盾を回避するため一時的なデバッグ用途をユースケースから除外した。
</dd>

<dt>Q. なぜプライオリティは 5 段階しかないのか</dt>
<dd>
プライオリティは数多く用意すると、開発者が何を指定するべきか判断に悩み、結果としてロギングの基準を不統一にする傾向がある。AzLogger では敢えて 5 段階と小数に限定し、ロギング基準の統一化を推進することにした。
</dd>

<dt>Q. [[PEAR Log|http://pear.php.net/package/Log]] を採用しなかった理由</dt>
<dd>
PEAR Log はロガー自体がログターゲットを組み込むモデルであり、柔軟性に欠けた設計であると判断した。
</dd>

<dt>Q. [[Log4PHP|http://logging.apache.org/]] を採用しなかった理由</dt>
<dd>
Log4PHP 自体は開発中であり、まだ利用できる状態にない。Log4J の設計を参考にしなかった理由は、その仕様の無駄な大きさがアゼリアのアーキテクチャにそぐわないと判断しただめ。
</dd>

<dt>Q. 設定ファイルはなぜロガーのみを対象としているのか</dt>
<dd>
ログターゲットの指定の際に、ターゲットに渡すべきパラメータも記述することは検討した。結論としては、任意のパラメータの記述に XML などを採用しては、想定ユーザーのスキルにそぐわないこと、ログターゲットの指定自体が補助的であることからフレームワーク外での対応とすることにした。
</dd>

</dl>
[[/html]]

[[リファレンス|section:reference]]

[[フレームワークソース|head:]]
[[include/fw/logger.csp]]

[[サンプルソース|head:]]
[[developer/demo_dumplog.csp]]

[[設計時の議論など|head:]]
[[設計メモ|cb6:page=ProjectDocView&ppid=3559&pbid=195247]]
