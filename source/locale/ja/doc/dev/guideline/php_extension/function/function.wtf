[[PHPでの構文|section:php_syntax]]
[[src]]
<?php

    echo user_function();             {{//「user function called」}}
    
    {{// ユーザー定義関数}}
    function user_function()
    {
        return "user function called";
    }
?>
[[/src]]

[[拡張モジュールの記述方法|section:ext_syntax]]
[[src]]
''コール側の記述列(hoge.csp)''
<?php

**// 例外発生: hoge_sample_func() expects exactly 1 parameter, 0 given**
hoge_sample_func();

{{// 「is_ref = 0」}}
{{// 「hoge_sample_func called(arg = HOGE)」}}
echo hoge_sample_func("HOGE");

**// 例外発生: Only variables can be passed by reference**
hoge_sample_func_arg1("HOGE");

$arg = "HOGE";
{{// 「is_ref = 1」}}
{{// 「hoge_sample_func_arg1 called(arg = HOGE)」}}
hoge_sample_func_arg1(&$arg);

{{// 「is_ref = 1」、もし BYREF_FORCE にしない場合、「is_ref = 0」となる。}}
**// BYREF_FORCE を使用しているので常にリファレンス**
hoge_sample_func_arg1($arg);

?>
[[/src]]

[[src]]
''モジュール側の記述例(php_hoge.h)''

{{// プロトタイプ宣言}}
PHP_FUNCTION(hoge_sample_func);
PHP_FUNCTION(hoge_sample_func_arg1);
PHP_FUNCTION(hoge_sample_func_arg2);
[[/src]]

[[src]]
''モジュール側の記述例(hoge.c)''

{{// 引数はリファレンスに強制させるパラメータ}}
static unsigned char arg1_force_ref[] = { 1, BYREF_FORCE };
static unsigned char arg2_force_ref[] = { 2, BYREF_NONE, BYREF_FORCE };

{{// 関数のエントリー配列}}
function_entry hoge_functions[] = 
{
    PHP_FE(hoge_sample_func, NULL)
    PHP_FE(hoge_sample_func_arg1, arg1_force_ref)
    PHP_FE(hoge_sample_func_arg2, arg2_force_ref)
    {NULL, NULL, NULL}
};

zend_module_entry hoge_module_entry = 
{
    ...

    "hoge",            {{// モジュール名}}
    hoge_functions,    {{// モジュールに関数エントリーを追加}}

    ...
};

// 関数定義
PHP_FUNCTION(hoge_sample_func)
{
    char *arg = NULL;
    int arg_len;
    char str[256];

    // パラメータ解析
    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &arg, &arg_len) == FAILURE) {
        return;
    }

    zend_printf("is_ref = %ld\n", PZVAL_IS_REF(arg));       // リファレンスか？

    sprintf(str, "hoge_sample_func called(arg = %s)", arg);
    RETURN_STRING(str, 1);
}

PHP_FUNCTION(hoge_sample_func_arg1)
{
    zval *arg;

    // パラメータ解析
    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &arg) == FAILURE) {
        return;
    }

    zend_printf("type = %ld\n", Z_TYPE_P(arg));
    zend_printf("is_ref = %ld\n", PZVAL_IS_REF(arg));
    zend_printf("refcount = %ld\n", ZVAL_REFCOUNT(arg));

}
[[/src]]

[[APIリファレンス|section:api]]

[[関数エントリー追加用のマクロ|head:]]
[[html]]
<table class=cb_data_list border="1">
  <tr>
    <th width=30%>マクロ</th>
    <th width=30%>引数</th>
    <th width=40%>概要</th>
  </tr>
  <tr>
    <td>PHP_FE(name, arg_types)</td>
    <td>
    name: 関数名<br>
    arg_types: パラメータフラグ
    </td>
    <td>
   「<b>function_entry</b>」構造体にメンバを追加する場合に使用します。<br><br>
    パラメータフラグとして以下の値が設定可能です。<br>
    <b>BYREF_NONE</b>: 何もしない。<br>
    <b>BYREF_FORCE</b>: リファレンスを強制する。
    <b>BYREF_ALLOW</b>: <br>
    <b>BYREF_FORCE_REST</b>: <br>
    大抵の場合、NULLをセットすることになります。
    </td>
  </tr>
  <tr>
    <td>PHP_NAMED_FE(zend_name, name, arg_types)</td>
    <td>
    zend_name: 関数名<br>
    name: 実体への関数ポインタ<br>
    arg_types: パラメータフラグ<br>
    </td>
    <td>
    上記マクロとほとんど同じですが、実体となる関数名を自分で定義できる点が異なっています。<br>
    また実体を定義する場合は、「<b>PHP_NAMED_FUNCTION</b>」を使用する必要があります。
    </td>
  </tr>
</table>
[[/html]]

[[関数実体宣言用のマクロ|head:]]
[[html]]
<table class=cb_data_list border="1">
  <tr>
    <th width=30%>マクロ</th>
    <th width=30%>引数</th>
    <th width=40%>概要</th>
  </tr>
  <tr>
    <td>PHP_FUNCTION(name)</td>
    <td>
    name: 関数名<br>
    </td>
    <td>関数の実体を定義する。
    </td>
  </tr>
  <tr>
    <td>PHP_NAMED_FUNCTION(name)</td>
    <td>
    name: 関数名<br>
    </td>
    <td>関数の実体を定義する。「<b>PHP_FUNCTION</b>」と違い完全に名前を決めることができる。
    </td>
  </tr>
</table>
[[/html]]

[[より詳しく知りたい方へ|section:tips]]
[[src]]
''(php.h)''

{{// 関数用マクロ}}
\#define PHP_FE                          ZEND_FE
\#define PHP_NAMED_FE                    ZEND_NAMED_FE
\#define PHP_FUNCTION                    ZEND_FUNCTION
\#define PHP_NAMED_FUNCTION              ZEND_NAMED_FUNCTION

''(zend.h)''

{{// 内部的にはすべてzendで表現されている。(PHP_\**** と等価)}}
\#define ZEND_FE(name, arg_types)        ZEND_NAMED_FE(name, ZEND_FN(name), arg_types)
\#define ZEND_NAMED_FE(zend_name, name, arg_types) { \#zend_name, name, arg_types },
\#define ZEND_FN(name)                   zif_##name
\#define ZEND_FUNCTION(name)             ZEND_NAMED_FUNCTION(ZEND_FN(name))
\#define ZEND_NAMED_FUNCTION(name)       void name(INTERNAL_FUNCTION_PARAMETERS)
\#define INTERNAL_FUNCTION_PARAMETERS    int ht, zval *return_value, zval *this_ptr, int return_value_used TSRMLS_DC

つまり、上記の例だとPHP_FEは「**zif_hoge_sample_func**」という関数名を生成してくれる。


{{// 関数エントリー用}}
\#define function_entry    zend_function_entry

typedef struct _zend_function_entry {
        char *fname;                                          {{// 関数名}}
        void (*handler)(INTERNAL_FUNCTION_PARAMETERS);        {{// 関数実体へのポインタ}}
        unsigned char *func_arg_types;                        {{// パラメータタイプ}}
} zend_function_entry;
[[/src]]