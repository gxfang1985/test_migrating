[[概要|section:abstract]]
PHPでは、値渡し（デフォルト）、参照渡し、オプション（デフォルト引数値）をサポートしています。
 また、可変引数もサポートしており、柔軟に引数の解析が行えます。
 （実際には、配列を引数として渡しても同様の意味で表現できますので、その方が簡単です。）

[[PHPでの構文|section:php_syntax]]
[[値渡しの場合|head:]]
[[src]]
<?php

    {{// 値渡し関数}}
    function arg_value_function($arg1, $arg2)
    {
        {{// 引数を静的に確認する}}
        echo "arg1 = $arg1";
        echo "arg2 = $arg2";

        $arg1 = "sinya";  {{// 値を変更する}}

        {{// 引数の数、値を動的に確認する}}
        echo "argument count = " . func_num_args();
        var_dump(func_get_args());
    }

    $arg1 = "hata";
    $arg2 = "yamamoto";
    $arg3 = "hagiya";

    arg_value_function($arg1, $arg2, $arg3);
    {{/*}}
    {{    arg1 = hata}}
    {{    arg2 = yamamoto}}
        
    {{    argument count = 3}}
    {{    array(3) {}}
    {{        [0]=>string(4) "hata"}}
    {{        [1]=>string(8) "yamamoto"}}
    {{        [2]=>string(6) "hagiya"}}
    {{    } }}
    {{*/}}

    echo $arg1;    {{//「hata」<-- 値渡しなので変更できない。}}

?>
[[/src]]

[[参照渡しの場合|head:]]
[[src]]
<?php

    {{// 参照渡し}}
    function arg_ref_function(&$arg1, &$arg2)
    {
        $arg2 = "taiu";  {{// 値を変更する}}
    }

    $arg1 = "hata";
    $arg2 = "yamamoto";

    arg_ref_function($arg1, $arg2);
    echo $arg2;    {{//「taiu」<-- 参照渡しなので変更できる。}}

    {{// 参照渡しで宣言して、値で渡すのは不可}}
    **//arg_ref_function("hata", "yamamoto");**
    {{//「Fatal error: Only variables can be passed by reference in D:\test\test.csp on line ??」}}

    {{// 実際は値に参照を渡してもほぼ同じ意味になる}}
    {{arg_value_function(&$arg1, "yamamoto");}}
    {{echo $arg1;    //「sinya」}}

?>
[[/src]]

[[オプション(デフォルト引数)の場合|head:]]
[[src]]
<?php

    {{// オプション(デフォルト引数値)の場合}}
    function arg_opt_function($arg1, $arg2='hoge')
    {
        echo "arg1 = $arg1";
        echo "arg2 = $arg2";
    }
    arg_opt_function("hata");
    {{/*}}
    {{    arg1 = hata}}
    {{    arg2 = hoge}}
    {{*/}}
    arg_opt_function("hata", "yamamoto");
    {{/*}}
    {{    arg1 = hata}}
    {{    arg2 = yamamoto}}
    {{*/}}

?>
[[/src]]

[[拡張モジュールの記述方法|section:ext_syntax]]
[[値渡しの場合|head:]]
[[src]]
''コール側の記述列(hoge.csp)''

<?php

    $l = 100;
    $s = "hoge";

    hoge_sample_func1($l, $s);
    {{/*}}
    {{    arg1 = 100}}
    {{    arg2 = hoge}}
    {{*/}}

?>
[[/src]]
[[src]]
''モジュール側の記述例(hoge.c)''

PHP_FUNCTION(hoge_sample_func1)
{
    ...
    long l;
    char* s;
    int s_len;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ls", &l, &s, &s_len) == FAILURE) {
        return;
    }
    zend_printf("arg1 = %ld", l);
    zend_printf("arg2 = %s", s);
    ...
}
[[/src]]

[[参照渡しの場合|head:]]
[[src]]
''コール側の記述列(hoge.csp)''

<?php

    hoge_sample_func2($l, $z1, &$z2);

    echo "$z1";    {{//「何も表示されない」}}
    echo "$z2";    {{//「hoge」}}

    **//////////////////////////////////////////////////////////////////////////**
    **//  実際は「hoge_sample_func2($l, $z1, &$z2);」とコールしても、**
    **//  $z1に強制的に値を返す方法もある。**
    **//  これについては、[[関数|doc:pg/php/extension/manual/function/function]] の場所で説明します。**
    **//////////////////////////////////////////////////////////////////////////**

?>
[[/src]]

[[src]]
''モジュール側の記述例(hoge.c)''

PHP_FUNCTION(hoge_sample_func2)
{
    ...
    long l;
    zval* z1;
    zval* z2;
    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "lzz", &l, &z1, &z2) == FAILURE) {
        return;
    }
    {{// 参照を表現するためには、zval型で引数を取得する必要がある。}}
    {{// 上記サンプルだと、z2は参照渡しなので値を返せるが、z1は値渡しなので返せない。}}
    ZVAL_LONG(z1, 999);
    ZVAL_STRING(z2, "hoge", 1);
    ...
}
[[/src]]

[[オプション(デフォルト引数)の場合|head:]]
[[src]]
''コール側の記述列(hoge.csp)''

<?php

    $s = "hoge";
    
    hoge_sample_func3($s);
    {{/*}}
    {{    arg1 = hoge}}
    {{    arg2 = 999}}
    {{*/}}

    hoge_sample_func3($s, 100);
    {{/*}}
    {{    arg1 = hoge}}
    {{    arg2 = 100}}
    {{*/}}
?>
[[/src]]

[[src]]
''モジュール側の記述例(hoge.c)''

PHP_FUNCTION(hoge_sample_func1)
{
    ...
    long l = 999;
    char* s;
    int s_len;
    
    **// 引数を解析する際に、(| = オプション)として解析するが付加されているので可能**
    **// もし、| がない場合、「hoge_sample_func3($s);」は許されない**
    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|l", &s, &s_len, &l) == FAILURE) {
        return;
    }
    zend_printf("arg2 = %s", s);
    zend_printf("arg1 = %ld", l);
    ...
}
[[/src]]

[[APIリファレンス|section:api]]
[[引数の数を取得する為のマクロ|head:]]
[[html]]
<table class=cb_data_list border="1">
  <tr>
    <th width=30%>名前</th>
    <th width=20%>引数</th>
    <th width=50%>概要</th>
  </tr>
  <tr>
    <td>ZEND_NUM_ARGS</td>
    <td>特になし</td>
    <td>引数の数を取得する。</td>
  </tr>
</table>
[[/html]]

[[引数を解析するための関数|head:]]
[[html]]
<table class=cb_data_list border="1">
  <tr>
    <th width=20%>名前</th>
    <th width=50%>引数</th>
    <th width=30%>概要</th>
  </tr>
  <tr>
    <td>zend_parse_parameters</td>
    <td>
<table>
<tr><th>型</th><th>名前</th><th>方向</th><th>概要</th></tr>
<tr><td>int</td><td>num_args</td><td>[in]</td><td>引数の数</td></tr>
<tr><td></td><td>TSRMLS_CC</td><td></td><td>リソース用<br>(気にしなくてよい。)</td></tr>
<tr><td>char*</td><td>type_spec</td><td>[in]</td><td>引数のフォーマット</td></tr>
<tr><td></td><td>...</td><td>[in/out]</td><td>可変引数</td></tr>
</table>
    </td>
    <td>引数を解析する。<br>（この関数ではエラーを発生させます。）<br><br>
    引数のフォーマットは以下の表現が可能です。
    <table>
    <tr><th>型指定</th><th>意味</th></tr>
    <tr><td><b>l</b></td><td><b>long</b></td></tr>
    <tr><td><b>d</b></td><td><b>double</b></td></tr>
    <tr><td><b>s</b></td><td><b>string</b></td></tr>
    <tr><td><b>b</b></td><td><b>boolean</b></td></tr>
    <tr><td><b>r</b></td><td><b>リソース(zval*)</b></td></tr>
    <tr><td><b>a</b></td><td><b>配列(zval*)</td></tr>
    <tr><td><b>o</b></td><td><b>オブジェクト(zval*)</b></td></tr>
    <tr><td><b>O</b></td><td><b>オブジェクト(zval*)</b><br>(クラスエントリによって指示されたもの)</td></tr>
    <tr><td><b>z</b></td><td><b>何でも(zval*)</td></tr>

    <tr><td><b>|</b></td><td><b>オプション</b></td></tr>
    <tr><td><b>!</b></td><td><b>NULL指定可能にする</b></td></tr>
    <tr><td><b>/</b></td><td><b>別リファレンスを生成する</b></td></tr>

    </table>
    </td>
  </tr>
  <tr>
    <td>zend_parse_parameters_ex</td>
    <td>
<table>
<tr><th>型</th><th>名前</th><th>方向</th><th>概要</th></tr>
<tr><td>int</td><td>flag</td><td>[in]</td><td>フラグ</td></tr>
<tr><td>int</td><td>num_args</td><td>[in]</td><td>引数の数</td></tr>
<tr><td></td><td>TSRMLS_CC</td><td></td><td>リソース用<br>(気にしなくてよい。)</td></tr>
<tr><td>char*</td><td>type_spec</td><td>[in]</td><td>引数のフォーマット</td></tr>
<tr><td></td><td>...</td><td>[in/out]</td><td>可変引数</td></tr>
</table>
    </td>
    <td>引数を解析する。<br>（この関数ではエラーを発生させません。柔軟な処理ができますが、<br>エラーメッセージなど自分で処理しなくてはなりません。）<br><br>
    フラグとしては今の所「<b>ZEND_PARSE_PARAMS_QUIET</b> : エラーを発生させない。」<br>
    だけが設定可能です。
    </td>
  </tr>
</table>
[[/html]]

[[より詳しく知りたい方へ|section:tips]]
[[src]]
''(zend_globals.h)''

{{// グローバル実行体の構造体}}
struct _zend_executor_globals
{
    ...
    HashTable *zend_constants;    {{// 定数のデータはすべてここに蓄積される。}}
    ...
}
[[/src]]

[[src]]
''(zend_constants.h)''

{{// 定数の構造体}}
typedef struct _zend_constant
{
    zval value;
    int flags;
    char *name;
    uint name_len;
    int module_number;
} zend_constant;

{{// long値を宣言するためのマクロ}}
\#define REGISTER_LONG_CONSTANT(name, lval, flags) \
        zend_register_long_constant((name), sizeof(name), (lval), (flags), module_number TSRMLS_CC)

''(zend_constants.c)''

{{// long値に依存するデータを設定する}}
ZEND_API void zend_register_long_constant(char *name, uint name_len, long lval, int flags, int module_number TSRMLS_DC)
{
    zend_constant c;

    c.value.type = IS_LONG;
    c.value.value.lval = lval;
    c.flags = flags;
    c.name = zend_strndup(name, name_len);
    c.name_len = name_len;
    c.module_number = module_number;
    zend_register_constant(&c TSRMLS_CC);
}

{{// 定数の登録を行う}}
ZEND_API int zend_register_constant(zend_constant *c TSRMLS_DC)
{
    char *lowercase_name;
    int ret = SUCCESS;

    lowercase_name = do_alloca(c->name_len);

    memcpy(lowercase_name, c->name, c->name_len);

    if (!(c->flags & CONST_CS)) {
        zend_str_tolower(lowercase_name, c->name_len);
    }

    **//////////////////////////////////////////////////////////////////////////**
    **//   グローバル実行体から定数用のハッシュテーブルを取得して登録する。**
    **//////////////////////////////////////////////////////////////////////////**
    if (zend_hash_add(EG(zend_constants), lowercase_name, c->name_len, (void *) c, sizeof(zend_constant), NULL)==FAILURE) {
        free(c->name);
        if (!(c->flags & CONST_PERSISTENT)) {
            zval_dtor(&c->value);
        }
        zend_error(E_NOTICE,"Constant %s already defined", lowercase_name);
            ret = FAILURE;
    }
    free_alloca(lowercase_name);
    return ret;
}
[[/src]]