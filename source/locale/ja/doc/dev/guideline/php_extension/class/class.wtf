[[PHPでの構文|section:php_syntax]]

[[src]]
<?php

class hoge
{
    {{// プロパティ}}
    var $_prop = "property in hoge";

    {{// インスタンスメソッド}}
    function foo()
    {
        echo "hoge::foo() called [prop = $this->_prop]";
    }
    {{// クラスメソッド}}
    function static_foo()
    {
        echo "hoge::static_foo() called";
    }
}

$obj = new hoge;

**/////////////////////////////////////////////////////////////////////////////**
**//  アクセス指定子(private, public, etc)の概念がない為、常にアクセス可能ですが、**
**//  必ずアクセサメソッド(getProp, setProp)を用意すること。**
**/////////////////////////////////////////////////////////////////////////////**
echo "prop=" . $obj->_prop;         {{//「property in hoge」}}

$obj->foo();                        {{//「hoge::foo() called [prop = property in hoge]」}}

**/////////////////////////////////////////////////////////////////////////////**
**//  クラスメソッドを明示的に宣言することはできません。**
**//  「hogehoge::foo();」もコールすることができます。（プロパティが表示されませんが）**
**//  開発者にできることは [[コーディング規約|doc:pg/rules/coding]] 通りに「static_」をつけることです。**
**/////////////////////////////////////////////////////////////////////////////**
hoge::static_foo();                 {{//「hoge::static_foo() called」}}

?>
[[/src]]

[[拡張モジュールの記述方法|section:ext_syntax]]
[[src]]
''コール側の記述列(hoge.csp)''
<?php

    hoge::static_foo();              {{//「hoge::static_foo() called」}}
    
    $obj = new hoge();
    $obj->foo();                     {{//「hoge::foo() called」}}

?>
[[/src]]

[[src]]
''モジュール側の記述例(hoge.c)''

function_entry hoge_class_functions[] = 
{
    PHP_CLASS_FE(hoge, foo, NULL)
    PHP_CLASS_FE(hoge, static_foo, NULL)
    {NULL, NULL, NULL}
};

int hoge_class_init(TSRMLS_D)
{
    zend_class_entry ce;

    INIT_CLASS_ENTRY(ce, 
                     "hoge", 
                     hoge_class_functions);

    zend_register_internal_class(&ce TSRMLS_CC);

    return SUCCESS;
}

PHP_MINIT_FUNCTION(hoge)
{
    ...
    hoge_class_init(TSRMLS_C);
    ...

    return SUCCESS;
}

PHP_CLASS_FUNCTION(hoge, foo)
{
    zend_printf("hoge::foo() called");
}

PHP_CLASS_FUNCTION(hoge, static_foo)
{
    zend_printf("hoge::static_foo() called");
}
[[/src]]

[[クラス宣言 API|section:api]]

[[クラスの宣言を行うマクロ|head:]]
[[html]]
<table class=cb_data_list border="1">
  <tr>
    <th width=20%>マクロ</th>
    <th width=40%>引数</th>
    <th width=40%>概要</th>
  </tr>
  <tr>
    <td>PHP_CLASS_FUNCTION</td>
    <td>
<table>
<tr><td>class_name</td><td>クラス名</td></tr>
<tr><td>function_name</td><td>関数名</td></tr>
</table>
    </td>
    <td>クラスのメソッドの実体を宣言する。</td>
  </tr>
  <tr>
    <td>PHP_CLASS_FE</td>
    <td>
<table>
<tr><td>class_name</td><td>クラス名</td></tr>
<tr><td>function_name</td><td>関数名</td></tr>
<tr><td>function_args</td><td>関数へのパラメータフラグ</td></tr>
</table>
    </td>
    <td>関数エントリーの登録を行う。<br>（内部的にクラスのメソッドは{cb_ui_pageurl page='developer_php_sdk_function' caption='関数'}と同じように表現され、関数へのパラメータフラグも同じですのでそちらを参照してください。）</td>
  </tr>
  <tr>
    <td>INIT_CLASS_ENTRY</td>
    <td>
<table>
<tr><td>class_container</td><td>クラスエントリー</td></tr>
<tr><td>class_name</td><td>クラス名</td></tr>
<tr><td>functions</td><td>関数エントリー</td></tr>
</table>
    </td>
    <td>クラスに関数などの登録を行う。</td>
  </tr>
  <tr>
    <td>INIT_OVERLOADED_CLASS_ENTRY</td>
    <td>
<table>
<tr><td>class_container</td><td>クラスエントリー</td></tr>
<tr><td>class_name</td><td>クラス名</td></tr>
<tr><td>functions</td><td>関数エントリー</td></tr>
<tr><td>handle_fcall</td><td>関数呼び出しメソッド</td></tr>
<tr><td>handle_propget</td><td>プロパティ取得メソッド</td></tr>
<tr><td>handle_propset</td><td>プロパティ設定メソッド</td></tr>
</table>
    </td>
    <td>クラスに関数などの登録に加え、関数の{cb_ui_pageurl page='developer_php_sdk_class_overload' caption='オーバーロード'}の設定を行う。</td>
  </tr>
</table>
[[/html]]

[[クラスの登録を行う関数|head:]]
[[html]]
<table class=cb_data_list border="1">
  <tr>
    <th width=15%>関数</th>
    <th width=50%>引数</th>
    <th width=15%>返り値</th>
    <th width=40%>概要</th>
  </tr>
  <tr>
    <td>zend_register_internal_class</td>
    <td>
<table>
<tr><th>型</th><th>名前</th><th>方向</th><th>概要</th></tr>
<tr><td>zend_class_entry*</td><td>class_entry</td><td>[in]</td><td>クラスエントリー</td></tr>
<tr><td></td><td>TSRMLS_CC</td><td></td><td>リソースマネージャー用</td></tr>
</table>
    </td>
    <td>登録したクラスエントリー</td>
    <td>クラスエントリーをzendエンジンに登録する。</td>
  </tr>

  <tr>
    <td>zend_register_internal_class_ex</td>
    <td>
<table>
<tr><th>型</th><th>名前</th><th>方向</th><th>概要</th></tr>
<tr><td>zend_class_entry*</td><td>class_entry</td><td>[in]</td><td>クラスエントリー</td></tr>
<tr><td>zend_class_entry*</td><td>parent_ce</td><td>[in]</td><td>親クラスエントリー</td></tr>
<tr><td>char*</td><td>parent_name</td><td>[in]</td><td>親クラス名</td></tr>
<tr><td></td><td>TSRMLS_CC</td><td></td><td>リソースマネージャー用</td></tr>
</table>
    </td>
    <td>登録したクラスエントリー</td>
    <td>クラスエントリーをzendエンジンに登録する。このメソッドは親クラスを設定することができ、{cb_ui_pageurl page='developer_php_sdk_class_extend' caption='継承'}を行う場合使用します。</td>
  </tr>
</table>
[[/html]]

[[より詳しく知りたい方へ|section:tips]]
[[src]]
\#define PHP_CLASS_FUNCTION(class_name, function_name)          PHP_FUNCTION(##class_name##function_name)
\#define PHP_CLASS_FN(class_name, function_name)                PHP_FN(##class_name##function_name)
\#define PHP_CLASS_FE(class_name, function_name, function_args) {#function_name, PHP_CLASS_FN(class_name, function_name), function_args},

typedef struct _zend_class_entry zend_class_entry;

{{// クラスを表す構造体}}
struct _zend_class_entry {
    char type;
    char *name;
    uint name_length;
    struct _zend_class_entry *parent;
    int *refcount;
    zend_bool constants_updated;

    HashTable function_table;
    HashTable default_properties;
    zend_function_entry *builtin_functions;

    {{// オーバーロード用}}
    void (*handle_function_call)(INTERNAL_FUNCTION_PARAMETERS, zend_property_reference *property_reference);
    zval (*handle_property_get)(zend_property_reference *property_reference);
    int (*handle_property_set)(zend_property_reference *property_reference, zval *value);
};

\#define INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value, zval *this_ptr, int return_value_used TSRMLS_DC

{{// クラスのエントリーに値を設定するマクロ}}
\#define INIT_CLASS_ENTRY(class_container, class_name, functions)                \
	{                                                                      \
                class_container.name = strdup(class_name);                      \
                class_container.name_length = sizeof(class_name) - 1;           \
                class_container.builtin_functions = functions;                  \
                class_container.handle_function_call = NULL;                    \
                class_container.handle_property_get = NULL;                     \
                class_container.handle_property_set = NULL;                     \
	}

{{// zendエンジンにクラスの登録を行う}}
ZEND_API zend_class_entry *zend_register_internal_class(zend_class_entry *class_entry TSRMLS_DC)
{
    zend_class_entry *register_class;
    char *lowercase_name = zend_strndup(class_entry->name, class_entry->name_length);

    zend_str_tolower(lowercase_name, class_entry->name_length);

    class_entry->type = ZEND_INTERNAL_CLASS;
    class_entry->parent = NULL;
    class_entry->refcount = (int *) malloc(sizeof(int));
    *class_entry->refcount = 1;
    class_entry->constants_updated = 0;
    zend_hash_init(&class_entry->default_properties, 0, NULL, ZVAL_PTR_DTOR, 1);
    zend_hash_init(&class_entry->function_table, 0, NULL, ZEND_FUNCTION_DTOR, 1);

    if (class_entry->builtin_functions) {
        {{// 関数の登録を行う}}
        zend_register_functions(class_entry->builtin_functions, &class_entry->function_table, MODULE_PERSISTENT TSRMLS_CC);
    }

    {{// クラスの登録を行う}}
    zend_hash_update(CG(class_table), lowercase_name, class_entry->name_length+1, class_entry, sizeof(zend_class_entry), (void **) &register_class);
    free(lowercase_name);
    return register_class;
}
[[/src]]