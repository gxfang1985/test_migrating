[[概要|section:abstract]]
PHPは以下の型をサポートしています。

*''スカラー型''
 論理型(boolean)
 整数型(long)
 浮動小数点型(float)、倍精度浮動小数点型(double)
 文字列型(string)
*''特殊型''
 NULL型
*''リソース型(resource)''
*''複合型''
 配列型(array)
 オブジェクト型(object)

PHP内部では、データはすべてzval型で表現されています。
 スクリプトエンジンのパーサーはリテラルなどから、適切に型の判定を行い、zval型として内部に格納します。
 ここでは、主にスカラー型の説明をします。複合型に関しては [[配列|doc:pg/php/extension/manual/variable/array]]、[[オブジェクト|doc:pg/php/extension/manual/variable/object]]を参照してください。

[[PHPでの構文|section:php_syntax]]
[[src]]
<?php
    **//////////////////////////////////////////////////////////////////////////**
    **//  スカラー型**
    **//////////////////////////////////////////////////////////////////////////**
    $str_hoge = "HOGE";
    echo gettype($str_hoge);     {{//「string」}}

    $long_hoge = 100;
    echo gettype($long_hoge);    {{//「integer」}}

    $double_hoge = 0.5;
    echo gettype($double_hoge);  {{//「double」}}

    $bool_hoge = TRUE;
    echo gettype($bool_hoge);    {{//「boolean」}}

    $null_hoge = NULL;
    echo gettype($null_hoge);    {{//「NULL」}}

    **//////////////////////////////////////////////////////////////////////////**
    **// 複合型（配列、オブジェクト）に関しては別途解説しています。**
    **//////////////////////////////////////////////////////////////////////////**
    $array_hoge = array("apple", "orange", "banana");
    echo gettype($array_hoge);   {{//「array」}}

    $object_hoge = new stdClass;
    echo gettype($object_hoge);  {{//「object」}}

?>
[[/src]]

[[拡張モジュールの記述方法|section:ext_syntax]]
[[src]]
''コール側の記述列(hoge.csp)''

var_dump(return_long_function());     {{// int(100)}}

[[/src]]

[[src]]
''モジュール側の記述例(hoge.c)''

[[PHP_FUNCTION|doc:pg/php/extension/manual/function/function]](return_long_function)
{
    ...
    **//////////////////////////////////////////////////////////////////////////**
    **//   例として、返り値にlongを作成する。**
    **//**
    **//   (「返り値」、「引数」とも同じように作成する。エンジンのスコープテーブルを参照して**
    **//     直接変数を登録することも可能です。）**
    **//////////////////////////////////////////////////////////////////////////**
    ZVAL_LONG(return_value, 100);    {{// RETURN_LONG(100)でも同じ}}
    ...
}
[[/src]]

[[zval型 作成マクロ|section:macro_create]]
**zvalは実体を宣言しないこと。（エンジンが使用できるようにヒープに作成する必要があるため）**
 ポインタで宣言して、このマクロを使用して実体を作成する。
 また、zend内のメモリ機構を使用するため「new」、「malloc」等の処理も呼び出してはいけません。

[[html]]
<table class=cb_data_list border="1">
  <tr>
    <th width=30%>マクロ</th>
    <th width=30%>引数</th>
    <th width=40%>概要</th>
  </tr>
  <tr>
    <td>MAKE_STD_ZVAL(zv)</td>
    <td>
    zv: zval変数へのポインタ<br>
    </td>
    <td>zval変数の作成を行い、初期化する。</td>
  </tr>
</table>
[[/html]]

[[zval型 値取得マクロ|section:macro_read]]
zval型によって多種のデータを表現するため、アクセスに便利なマクロが用意されています。

[[html]]
<table class=cb_data_list border="1">
  <tr>
    <th width=30%>マクロ</th>
    <th width=30%>引数</th>
    <th width=40%>概要</th>
  </tr>
  <tr>
    <td>
    Z_LVAL(zval)<br>
    Z_LVAL_P(zval_p)<br>
    Z_LVAL_PP(zval_pp)<br>
    </td>
    <td>
    zval: zval変数<br>
    zval_p: zval変数へのポインタ<br>
    zval_pp: zval変数へのダブルポインタ
    </td>
    <td>zval変数からlong値を取り出す。</td>
  </tr>
  <tr>
    <td>
    Z_BVAL(zval)<br>
    Z_BVAL_P(zval_p)<br>
    Z_BVAL_PP(zval_pp)<br>
    </td>
    <td>同上</td>
    <td>zval変数からboolean値を取り出す。</td>
  </tr>
  <tr>
    <td>
    Z_DVAL(zval)<br>
    Z_DVAL_P(zval_p)<br>
    Z_DVAL_PP(zval_pp)<br>
    </td>
    <td>同上</td>
    <td>zval変数からdouble値を取り出す。</td>
  </tr>
  <tr>
    <td>
    Z_STRVAL(zval)<br>
    Z_STRVAL_P(zval_p)<br>
    Z_STRVAL_PP(zval_pp)<br>
    </td>
    <td>同上</td>
    <td>zval変数からstring値を取り出す。</td>
  </tr>
  <tr>
    <td>
    Z_STRLEN(zval)<br>
    Z_STRLEN_P(zval_p)<br>
    Z_STRLEN_PP(zval_pp)<br>
    </td>
    <td>同上</td>
    <td>zval変数からstring値の長さを取り出す。</td>
  </tr>
  <tr>
    <td>
    Z_ARRVAL(zval)<br>
    Z_ARRVAL_P(zval_p)<br>
    Z_ARRVAL_PP(zval_pp)<br>
    </td>
    <td>同上</td>
    <td>zval変数からarray値を取り出す。</td>
  </tr>
  <tr>
    <td>
    Z_OBJ(zval)<br>
    Z_OBJ_P(zval_p)<br>
    Z_OBJ_PP(zval_pp)<br>
    </td>
    <td>同上</td>
    <td>
    これは基本的に使用しないでください。<br>
    Z_OBJPROP、Z_OBJCEを使用すること。<br>
    </td>
  </tr>
  <tr>
    <td>
    Z_OBJPROP(zval)<br>
    Z_OBJPROP_P(zval_p)<br>
    Z_OBJPROP_PP(zval_pp)<br>
    </td>
    <td>同上</td>
    <td>
    zval変数からobject値のプロパティを取り出す。<br>
    PHPでいうと、「get_object_vars」はこれで取得した値を返すだけです。<br>
    </td>
  </tr>
  <tr>
    <td>
    Z_OBJCE(zval)<br>
    Z_OBJCE_P(zval_p)<br>
    Z_OBJCE_PP(zval_pp)<br>
    </td>
    <td>同上</td>
    <td>
    zval変数からobject値のクラス情報(クラス名、関数等)を取り出す。<br>
    PHPでいうと、「get_class」はこれで取得した値の名前部分を返すだけです。<br>
    </td>
  </tr>
  <tr>
    <td>
    Z_RESVAL(zval)<br>
    Z_RESVAL_P(zval_p)<br>
    Z_RESVAL_PP(zval_pp)<br>
    </td>
    <td>同上</td>
    <td>
    zval変数からresouce値を取り出す。<br>
    リソースはIDとして表現されているだけなので、実際にはlong値を返すだけです。
    </td>
  </tr>
  <tr>
    <td>
    Z_TYPE(zval)<br>
    Z_TYPE_P(zval_p)<br>
    Z_TYPE_PP(zval_pp)<br>
    </td>
    <td>同上</td>
    <td>zval変数で表現されている型を取り出す。</td>
  </tr>
</table>
[[/html]]
すべて3個づつ用意されているのは、実体、ポインタ、ダブルポインタから、要素を取得する為です。
 型を自分で変換して渡しても同じ意味になります。

[[zval型 値設定マクロ|section:macro_write]]
**MAKE_STD_ZVALによって実体を作成してから使用してください。**

[[html]]
<table class=cb_data_list border="1">
  <tr>
    <th width=30%>マクロ</th>
    <th width=30%>引数</th>
    <th width=40%>概要</th>
  </tr>
  <tr>
    <td>ZVAL_NULL(z)</td>
    <td>
    z: zval変数へのポインタ<br>
    </td>
    <td>NULLを設定する。</td>
  </tr>
  <tr>
    <td>ZVAL_LONG(z, l)</td>
    <td>
    z: zval変数へのポインタ<br>
    l: longの値<br>
    </td>
    <td>longの値を設定する。</td>
  </tr>
  <tr>
    <td>ZVAL_DOUBLE(z, d)</td>
    <td>
    z: zval変数へのポインタ<br>
    d: doubleの値<br>
    </td>
    <td>doubleの値を設定する。</td>
  </tr>
  <tr>
    <td>ZVAL_BOOL(z, b)</td>
    <td>
    z: zval変数へのポインタ<br>
    b: booleanの値<br>
    </td>
    <td>booleanの値を設定する。</td>
  </tr>
  <tr>
    <td>ZVAL_FALSE(z)</td>
    <td>
    z: zval変数へのポインタ<br>
    </td>
    <td>boolean(FALSE)の値を設定する。ZVAL_BOOLを使っても同様のことができます。</td>
  </tr>
  <tr>
    <td>ZVAL_TRUE(z)</td>
    <td>
    z: zval変数へのポインタ<br>
    </td>
    <td>boolean(TRUE)の値を設定する。ZVAL_BOOLを使っても同様のことができます。</td>
  </tr>
  <tr>
    <td>ZVAL_STRING(z, s, duplicate)</td>
    <td>
    z: zval変数へのポインタ<br>
    s: doubleの値<br>
    duplicate: 複製するかどうか？<br>
    </td>
    <td>stringの値を設定する。</td>
  </tr>
  <tr>
    <td>ZVAL_STRINGL(z, s, l, duplicate)</td>
    <td>
    z: zval変数へのポインタ<br>
    s: stringの値<br>
    l: stringの値の長さ<br>
    duplicate: 複製するかどうか？<br>
    </td>
    <td>stringの値を設定する。ZVAL_STRINGよりもスピードが速くバイナリセーフである。</td>
  </tr>
  <tr>
    <td>ZVAL_EMPTY_STRING(z)</td>
    <td>
    z: zval変数へのポインタ<br>
    </td>
    <td>string(空)の値を設定する。</td>
  </tr>
  <tr>
    <td>ZVAL_RESOURCE(z, l)</td>
    <td>
    z: zval変数へのポインタ<br>
    l: resourceの値<br>
    </td>
    <td>resourceの値を設定する。</td>
  </tr>
</table>
[[/html]]

配列、オブジェクトの値設定に関しては別途説明する。

[[zval型 型変換マクロ|section:macro_chtype]]
PHPでは、関数のコール時に型チェックが行われないため、どんな型の引数でもわたすことが可能です。
 この条件下でも動作するために、型の強制変換が用意されています。
 （もちろん変換せずにエラーをとして処理してしまっても構いません。）

[[html]]
<table class=cb_data_list border="1">
  <tr>
    <th width=30%>マクロ</th>
    <th width=30%>引数</th>
    <th width=40%>概要</th>
  </tr>
  <tr>
    <td>convert_to_null_ex(ppzv)</td>
    <td>
    ppzv: zval変数へのダブルポインタ<br>
    </td>
    <td>
    NULL型への強制変換を行う。<br>
    zval_dtor(文字列、配列、オブジェクト、リソースの場合、メモリ解放を行う。)を呼んだのち、型をNULLに設定する。
　　</td>
  </tr>
  <tr>
    <td>convert_to_boolean_ex(ppzv)</td>
    <td>
    ppzv: zval変数へのダブルポインタ<br>
    </td>
    <td>
    論理型への強制変換を行う。<br>
    NULLの場合、FALSEに変換する。<br>
    数値型の場合、0の時はFALSE、それ以外はTRUEに変換する。<br>
    文字列型の場合、空か"0"という文字列の場合はFALSE、それ以外はTRUEに変換する。<br>
    配列、オブジェクト型、要素が存在すればTRUE、なければFALSEに変換する。
　　</td>
  </tr>
  <tr>
    <td>convert_to_long_ex(ppzv)</td>
    <td>
    ppzv: zval変数へのダブルポインタ<br>
    </td>
    <td>
    整数型への強制変換を行う。<br>
    NULLの場合、0に変換する。<br>
    論理型の場合、FALSEの時は0、TRUEの時は1に変換する。<br>
    文字列型の場合、strtolを使用して文字列にしたものに変換する。<br>
    配列、オブジェクト型、要素が存在すれば1、なければ0に変換する。
　　</td>
  </tr>
  <tr>
    <td>convert_to_double_ex(ppzv)</td>
    <td>
    ppzv: zval変数へのダブルポインタ<br>
    </td>
    <td>
    倍精度不動小数点型への強制変換を行う。<br>変換に関しては、convert_to_long_exと同様です。ただし、文字列変換する際にはstrtodを呼んで変換する。
　　</td>
  </tr>
  <tr>
    <td>convert_to_string_ex(ppzv)</td>
    <td>
    ppzv: zval変数へのダブルポインタ<br>
    </td>
    <td>
    文字列型への強制変換を行う。<br>
    NULLの場合、空文字に変換する。<br>
    論理型の場合、TRUEの時は"1"、FALSEの時は空文字に変換する。<br>
    整数型、倍精度浮動小数点型の場合、zend_sprintfで文字列変換したもにに変換する。<br>
    リソース型の場合、"Resource id #%id%"に変換する。%id%は任意のリソースID<br>
    配列型の場合、"Array"に変換する。<br>
    オブジェクト型の場合、"Object"に変換する。
　　</td>
  </tr>
  <tr>
    <td>convert_to_array_ex(ppzv)</td>
    <td>
    ppzv: zval変数へのダブルポインタ<br>
    </td>
    <td>
    配列型への強制変換を行う。<br>
    NULLの場合、空の配列に変換する。<br>
    オブジェクト型の場合、プロパティを連想配列として変換する。<br>
　　</td>
  </tr>
  <tr>
    <td>convert_to_object_ex(ppzv)</td>
    <td>
    ppzv: zval変数へのダブルポインタ<br>
    </td>
    <td>
    オブジェクト型への強制変換を行う。<br>
    NULLの場合、空の配列に変換する。<br>
    配列型の場合、配列のキーをプロパティ、値をその内容として変換する。
　　</td>
  </tr>
</table>
[[/html]]

[[より詳しく知りたい方へ|section:tips]]

[[src]]
''(zend.h)''

{{// zval構造体}}
typedef struct _zval_struct zval;
struct _zval_struct {
        zvalue_value value;        {{// データ値}}
        zend_uchar type;           {{// データタイプ(ex. IS_LONG)}}
        zend_uchar is_ref;         {{// リファレンスの場合 = 1}}
        zend_ushort refcount;      {{// 参照カウント}}
};

{{// データタイプ}}
\#define IS_NULL                 0
\#define IS_LONG                 1
\#define IS_DOUBLE               2
\#define IS_STRING               3
\#define IS_ARRAY                4
\#define IS_OBJECT               5
\#define IS_BOOL                 6
\#define IS_RESOURCE             7
\#define IS_CONSTANT             8
\#define IS_CONSTANT_ARRAY       9

// zval構造体のデータ部
typedef union _zvalue_value {
        long lval;             {{// 整数値(boolean, resouceもここに保存)}}
        double dval;　　　　　　{{// 倍精度浮動小数点(floatもここに保存)}}
        struct {               {{// 文字列}}
                char *val;
                int len;
        } str;
        HashTable *ht;         {{// 配列}}
        zend_object obj;       {{// オブジェクト}}
} zvalue_value;

[[/src]]

[[src]]
''(zend_API.h)''

{{// 整数値設定用のマクロ}}
\#define ZVAL_LONG(z, l){                        \
                (z)->type = IS_LONG;            \
                (z)->value.lval = l;            \
}

{{// 文字列設定用マクロ}}
\#define ZVAL_STRINGL(z, s, l, duplicate){                           \
        char *__s=(s); int __l=l;                                   \
        (z)->value.str.len = __l;                                   \
        (z)->value.str.val = (duplicate?estrndup(__s, __l):__s);    \
        (z)->type = IS_STRING;                                      \
}

{{// zval値取得用のマクロ}}
\#define Z_LVAL(zval)             (zval).value.lval
\#define Z_LVAL_P(zval_p)         Z_LVAL(*zval_p)
\#define Z_LVAL_PP(zval_pp)       Z_LVAL(**zval_pp)

[[/src]]

[[src]]
''(zend.h)''

{{// zval型の作成}}
\#define MAKE_STD_ZVAL(zv)               \
        ALLOC_ZVAL(zv);                 \
        INIT_PZVAL(zv);

\#define INIT_PZVAL(z)                   \
        (z)->refcount = 1;              \
        (z)->is_ref = 0;

''(zend_fast_cache.h)''

\#define ALLOC_ZVAL(z)                                 \
        ZEND_FAST_ALLOC(z, zval, ZVAL_CACHE_LIST)

\#define ZEND_FAST_ALLOC(p, type, fc_type)             \
        (p) = (type *) emalloc(sizeof(type))
[[/src]]
