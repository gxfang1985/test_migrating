[[ユニットテストとは|section:what]]
ユニットテストは単体テストと日本語で書くこともあります。その名の通り、特定の機能やモジュール単体の動作試験を指します。

単体の試験であれば何でもユニットテストなのですが、最近では [[XP(eXtreme Programming)|http://www.armaties.com/extreme.htm]] のテスト重視指向から産まれた ''ユニットテストフレームワーク''を利用して行うことが多いです。

今では各種の言語用に色々なフレームワークがありますが、そのほとんどは Java 用に書かれた [[JUnit|http://www.junit.org/]] を土台としています。JUnit 由来のユニットテストフレームワークを総称して、xUnit といいます。

[[AzUnit - アゼリアユニットテストフレームワーク|section:azunit]]

PHP4 はオブジェクト指向機能を備えているとはいえ、その機能はかなり貧弱であり、特に例外をハンドルできないことから xUnit 系列の実装は困難です。実際、PEAR にも [[PHPUnit|http://pear.php.net/package/PHPUnit]] というユニットテストフレームワークが存在するのですが、PHP4 はサポートせず PHP5 のみとなっています。

アゼリアではきちんと使えるユニットテストフレームワークを独自に開発し、提供しています。このユニットテストフレームワークのことを ''AzUnit (エーズユニット)'' と呼ぶことにします。

アゼリアのために作られただけあって、アゼリア上で動作するモジュールの試験に最適な仕様になっています。具体的には、フレームワークコード上で動作すること(各テストは通常のリクエスト処理フローで処理されます)、php.ini や common.ini の設定を共有すること、などです。

[[用語|section:terminology]]

[[html]]
<table class=cb_doc_table border="1">
<tr>
<td nowrap>アサーション (assertion)</td>
<td>
与えられた式が正しいことを担保する言語機能。PHP4 にもあり、式が正しくないと失敗する。
</td>
</tr>

<tr>
<td nowrap>エクスペクテーション (expectation)</td>
<td>
結果を期待すること。期待した結果と異なる結果は、試験失敗となる。
</td>
</tr>

<tr>
<td nowrap>Failure と Error</td>
<td>
Failure というのは、テストを書いたプログラマが予期しうる失敗。アサーションの失敗や、エクスペクテーションの失敗がこれに当たる。Error はプログラマの予期していない個所での失敗のこと。文法エラーや予期せぬエラーの発生などがこれに当たる。
</td>
</tr>
</table>
[[/html]]

[[IISの設定|section:iis]]

もし Web サーバーにIISを使用している場合、php.exe の実行ユーザーを変更しないと AzUnit が起動できません。以下の手順で php.exe の実行ユーザーを変更してください。

#IISの管理画面で、実行したい php.exe のプロパティを開く。
#ファイルセキュリティタブの「''匿名アクセスおよび認証コントロール''」の編集ボタンを押す。
#匿名アクセスのユーザー名を、参照ボタンで取得してきたログインしているユーザーに変更する。

[[テストケースの書き方 Step by Step|section:stepby]]

#[[テストケースの作成|#tut_create_testcase]]
#[[テストの実行|#tut_run_test]]
#[[まとめて実行|#tut_testrunner]]
#[[結果の表示|#tut_show_result]]
#[[実行の途中経過を表示|#tut_show_process]]
#[[テスト前の準備|#tut_prepare]]
#[[データベース設定|#tut_prepare_database]]
#[[エラー発生のテスト|#tut_handle_error]]
#[[HTTP ヘッダ出力のテスト|#tut_handle_header]]
#[[標準出力のテスト|#tut_handle_output]]
#[[ステータスコードの確認|#tut_handle_status_code]]
#[[テストの説明文の追加|#tut_add_description]]
#[[HTTP入力 / サーバー環境のエミュレーション|#tut_emulation]]

[[1. テストケースの作成|head:tut_create_testcase]]
テストケースは、[[az:fw.unittest:CB_TestCase]] クラスを拡張して記述します。
具体的には以下のように、''test'' で始まる名前を持つメソッドとして作成します。
テスト成功であれば最後まで実行を続け、テスト失敗時には [[php:assert]] で落ちるようにします。ファイルの最後で、[[az:fw.unittest:include/developer/azunit.csp:cb_test_run]] を呼び出します。

[[src]]
<?php

require_once( 'developer/azunit.csp' );
require_once( ''CB_Foo を定義しているファイル'' );

class Test_CB_Foo extends **CB_TestCase**
{
    var $foo = null;

    {{// コンストラクタはこの 1 引数を取る定型に従います}}
    function Test_CB_Foo( $test_method )
    {
        parent::CB_TestCase( $test_method );

        {{// 以下テスト用初期化コードは自由に記述}}
        $this->foo = new CB_Foo();
    }

    function **testFoo**()
    {
        **assert**( '$this->foo->bar() == 3' );
    }
}

**cb_test_run();**

?>
[[/src]]

作成したテストケースを、"クラス名''.cspt''" というファイル名で保存します。クラス名は大小文字の区別をしないので、ファイル名規約に従って全て小文字で保存してください。この例の場合は、"''test_cb_foo.cspt''" となります。

''assert() 文中が文字列で記述されていることに注目してください。''PHP4 の assert は通常の式を書くこともできますが、文字列で渡すことによりアサーション失敗時に、「失敗した式」を得られる違いがあります。そのため、アゼリアでは [[php:assert]] の中は文字列で書く規約としています。

[[2. テストの実行|head:tut_run_test]]
テストの実行には、[[az:fw.unittest:CB_TestExecutor]] を使います。
CB_TestExecutor::runOne() は、一つのテストを実行して、結果を収めた [[az:fw.unittest:CB_TestResult]] オブジェクトを返します。

[[src]]
<?php

require_once( 'developer/azunit.csp' );

{{// (実行するスクリプトファイル, 実行するテストメソッド)}}
$executor = new CB_TestExecutor( 'Test_CB_Foo.cspt', 'testFoo' );
$result =& $executor->runOne();

?>
[[/src]]

上のコードを実行すると、Test_CB_Foo::testFoo() を実行して、結果を収めた [[az:fw.unittest:CB_TestResult]] オブジェクトが $result に返ります。

[[3. まとめて実行|head:tut_testrunner]]
一つ一つのテストを全て記述するのは大変なので、テストスクリプトを検索、テストメソッドをリフレクションで見つけて実行し、結果を収集する [[az:fw.unittest:CB_TestRunner]] クラスが用意されています。
途中経過の表示などの機能は、[[az:fw.unittest:CB_TestRunner]] を拡張したそれぞれ別の TestRunner を作成して変更・追加が可能です。

CB_TestRunner の基本的な機能
#テストを追加する
#全て実行する
#収集した結果を返す

より高度な機能の実現は後のステップで解説します。

[[src]]
<?php

require_once( 'developer/azunit.csp' );

$runner = new CB_TestRunner();

{{// テストを一つ追加}}
$runner->addTest( new CB_TestExecutor( '/.../hoge.cspt', 'testFuga' ) );

{{// hoge.cspt ファイル中のテストメソッドを全て追加}}
$runner->addTestFile( '/.../hoge.cspt' );

{{// ディレクトリを再帰的に検索して、マッチするファイルを追加}}
$runner->addTestDir( '/.../hoge', 'fuga*.cspt' );

{{// 実行すると、$result に CB_TestResult が返る}}
$result =& $runner->run();

?>
[[/src]]

このように一々ファイルを追加するのは手間がかかるので、コマンドラインやウェブフォームで指定できる UI を同様に作成できます。フレームワークでそれぞれ一つずつ用意していますが、素晴らしい UI を作成したら是非ご提供ください。

[[4. 結果の表示|head:tut_show_result]]

上記のようにして得られる CB_TestResult から実行したテストの結果が得られるので、それを表示することは容易でしょう。Smarty で出力するようにしておくと、テンプレートを変えるだけで見栄えも変更できます。

AzUnit は [[az:fw.unittest:CB_TestResultPrinter]] およびその子クラスでテスト結果を表示する機能も一応提供しています。

[[5. 実行の途中経過を表示|head:tut_show_process]]
実行中にテストの実行状況を表示したければ、[[az:fw.unittest:CB_TestRunner]] を継承し、リスナーメソッドを実装します。以下の 3 つのメソッドがリスナーメソッドです。

*function addFailure( & $failure {{/* object CB_TestFailure */}} );
 失敗(Error もしくは Failure)が発生した場合に呼び出される。
*function startTest( $label )
 $label という名前のテストを開始する際に呼び出される。
*function endTest( $label )
 $label という名前のテストが終了した後に呼び出される。

[[6. テスト前の準備|head:tut_prepare]]
複数の test で始まるメソッドをクラス中に実装することで、一つのクラスに複数のテストを用意できます。こうすることの大きな理由は、それらのテストで共通することがあるからでしょう。

最も良くあるパターンが、テスト用の準備が共通であることです。準備はコンストラクタで以下のように行います。

#parent::CB_TestCase( $test_method ) を呼び出し、AzUnit を初期化
#既存の環境(データベーステーブルなど)をクリア
#各テストメソッド共通の準備を行う

[[7. データベース設定|head:tut_prepare_database]]

環境作成の中でも一番多くおこなうのが、データベース中のデータの設定でしょう。アゼリアは通常、リクエスト終了時までデータベースへの SQL 発行をしないのですが、CB_Row::registerNow() などで即 SQL を発行させれば、テストメソッドからデータベースへの検索が可能になります。

なお、''動的にテーブルを作成・削除するテストは極力避けてください''。テーブル操作はトランザクションで保護されておらず、危険なものです。必要なテーブルは予め(ユニットテスト実行の前に)作成しておくようにします。実際の製品でも同様に、テーブルの作成は初期化時に一括して行うようにしてください。

[[8. エラー発生のテスト|head:tut_handle_error]]

PHP4 には例外機構がないので、try-catch では処理できません。そこで AzUnit では以下のように、テストケース中でエラーの発生を期待(expect)することを宣言します。

[[src]]
class Test_CB_Foo extends CB_TestCase
{
    var $_foo;

    function testFoo()
    {
        $this->**expectError**( 'FOO12345' {{/* 期待するエラー番号*/}} );
        $this->_foo->bar(); {{// エラーが発生するはず}}
    }
}
[[/src]]

上記の結果、"FOO12345" エラーが発生すると、このテストは成功と扱われます。
エラーが発生しなかったり、別のエラーが発生したりすると失敗となります。

[[9. HTTP ヘッダ出力のテスト|head:tut_handle_header]]
エラーのテストと同様に、HTTP ヘッダも期待(expect)できます。

[[src]]
class Test_CB_Foo extends CB_TestCase
{
    function testFoo()
    {
        {{// 出力されていることを期待。値は問わない。}}
        $this->**expectHeader**( 'X-Cybozu-Hoge' );

        {{// 出力されて、値も "10" であることを期待。}}
        $this->**expectHeader**( 'X-Cybozu-Fuga', 10 );

        {{// do something...}}
    }
}
[[/src]]

[[10. 標準出力のテスト|head:tut_handle_output]]

echo 文などで書き出した文字列の内容を確認するためには、''アウトプットバッファリング機構''を利用します。この機能により、出力を PHP 変数に取り込んで確認できます。

[[11. ステータスコードの確認|head:tut_handle_status_code]]

CGI の出力する HTTP レスポンスステータスは、"''Status: 302''" といった形のヘッダとして出力されます。そのため、CB_TestCase::expectHeader() で "Status" ヘッダを期待するようにします。

[[12. テストの説明文の追加|head:tut_add_description]]
例えばまだ実装していない機能などで、必ず失敗するテストがある場合、その旨の説明を結果に含めることが可能です。以下のように CB_TestCase::addDescription() メソッドを使用します。

[[src]]
class Test_CB_Foo extends CB_TestCase
{
    function testFoo()
    {
        $this->addDescription( 'this must fail!' );
        assert( 'false' );
    }
}
[[/src]]

[[13. HTTP 入力 / サーバー環境のエミュレーション|head:tut_emulation]]
アゼリアでは大域変数に HTTP の入力情報や、サーバー環境の情報が入っていることになっているので、コンストラクタでそれらの大域変数を操作しておきます。

*GET / POST パラメータ
 $G_INPUT 配列に格納します。
*アップロードファイル
 ''$_FILES'' を操作します。
*その他各種のサーバー環境情報
 $_SERVER や $_COOKIE などを適宜操作します。

[[コマンドライン UI の使い方|section:command]]
AzUnit は簡易なコマンドライン用 UI を提供しています。指定したファイルやディレクトリから実行すべきテストを検索、実行し、結果のレポートを出力します。出力結果をメールする機能などが必要であれば、適宜拡張してください。

使い方は、以下のようにコマンドプロンプトから実行します。UNIX の場合は適宜対応する実行ファイルなどに置き換えてください。

[[src]]
cd ''(php.exe のあるディレクトリ)''
php.exe -C -q -f code\command\run_test.csp ''(テストファイル or ディレクトリ)'' ''...''
[[/src]]

結果は以下のように表示されます。実行中に表示される、"''.''", "''x''", "''X''" はそれぞれ "正常終了", "Failure", "Error" に対応します。

[[src]]
Running...
**...x.x..X....**

============================================================
Test Report @ Tue, 25 Nov 2003 11:06:48 +0900

-------- Testing Environmrnt
OS:   Linux
PHP:  4.3.4
Host: Linux azalea 2.4.20-20.9 #1 Mon Aug 18 11:45:58 EDT 2003 i686 i686 i386 GNU/Linux

-------- Summary of Test Results
Successful:               NO
Total # of tests:         13
Total # of failures:       2
Total # of errors:         1
Ratio of success:     81.25%

-------- Failure Description
[test::test1] Assertion "false" failed at line 14 in /home/ymmt/azalea_unix/code/test.cspt.
[test::test3] Expected to throw FW00001, but actually nothing thrown.

-------- Error Description
[test::test4] A non expected error FW00002 was thrown.

============================================================
[[/src]]

[[特に書くべきテストケース|section:cases]]

[[セキュリティホール関連|head:]]
*「 " ' & > < 」を含む文字列の処理 (HTML処理、SQL処理)
*「 % ' _ 」を含む検索パターン (SQL の LIKE 文字列処理)

[[PHP仕様関連|head:]]
*空文字列への特殊処理に "0" を指定する
 PHP では単なる if 文などでは空文字列も "0" も数値の 0 も偽と判断されるので、空文字列チェックは ''strlen($hoge) == 0'' といった形で行う必要があるため。

[[JUnit との違いとその理由|section:junit]]

AzUnit は xUnit、特に JUnit を参考に作られているが、仕様にはかなり大きな違いがある。以下に違いとその根拠を示す。

[[実行モデル|head:]]

JUnit は in-process。AzUnit はテストを子プロセスで起動。
PHP4 に例外処理がないので、in-process では適切なエラー処理を試験できないため。
また PHP4 の言語的汚さから、テスト間の相互依存を考えるとプロセスモデルのほうが無難と判断した。

[[CB_TestExecutor|head:]]

AzUnit 独自のクラス。テストケースの実行が別プロセスになるわけだが、このクラスは親プロセス(TestRunner)中で個々のテスト(子プロセス)を表現するスタブクラスとして使用される。

設計理由は、AzUnit の実行モデルでの各クラスの役割を考えたときに、プロセスの起動から出力の処理までが TestRunner の仕事に追加されてしまい、粒度が大きすぎると感じたため。

もう一点は、実装の隠蔽のため。子プロセスがどうこうというのは一時的な都合かもしれない。その意味でスタブ(stub)ではなく、実行者(executor)とした。PHP5 で同様な仕組みを in-process で出来るようになったら、これの実装をリダイレクトするだけにしてしまえば良い。

CB_TestExecutor は JUnit では Test がこなしていた、TestResult への追加を行う役目を持つ。こうして TestResult は CB_TestExecutor を介すことで、実行モデルを気にすることなくテスト結果の収集とリスナーへの通知を行える。

[[TestSuite|head:]]

AzUnit ではテスト集合の役割を独立させていない。CB_TestRunner がその役割を負っている。TestSuite は関連するテスト集合を実行させるために利用できるが、少々役割が小さすぎると判断した。

[[Assert|head:]]

JUnit では TestCase 記述のため便利に使われる Assert クラスだが、アゼリアにはない。単純に [[php:assert]] を使うほうが fail した正確な行番号を取得できるし、失敗した式も表示できるので。[[参考|dss:page=DS_topicview&cat_id=6792&msg_id=8290&f_id=8290&open=1#8290]]

もちろん Assert::assertSame() などは「意味」をもって失敗を分類できる(「一致していない」)のだが、山本の判断では、「式」で十分プログラマに伝わる。

明示的失敗 (Assert::fail()) は、AzUnit では assert( 'false' ); とする。

[[TestCase::setUp(), TestCase::tearDown()|head::]]

これらは AzUnit には存在しない。理由は、これも実行モデルによるものだが 1 テスト 1 プロセスで、しかもエラー時に異常終了する可能性があるからである。

各プロセスでオブジェクトが生成されるので、setUp() の役割は TestCase の(派生クラスの)コンストラクタと重複することになる。またエラー発生時にはプロセスが終了してしまうので、tearDown() を確実に行う術がない。

そのため、AzUnit では各テストクラスのコンストラクタで、前述のような手順でテスト環境を作成することにした。

[[その他|head:]]
各所を簡略化している(プリンタインターフェースを持たないとか、Listener は一つしか設定できないとか)。xUnit と違い各種のユーザーがいる訳ではないので、不要な API は極力削ぎ落とした。

[[設計時の要件定義|section:require]]

[[html]]
<dl>
<dt>アゼリアの通常の実行環境と同一であること</dt>
<dd>
リクエストフローや設定ファイル(php.ini など)が異なると、正しく試験できない。
</dd>

<dt>簡単にテストケースを作成できること</dt>
<dd>
使われるための必須要件。簡単でなければ、テストケースの作成をさぼったり、工数の許容できない増大を招くことになる。。
</dd>

<dt>プロダクションコードと分離できること</dt>
<dd>
テストスクリプトのファイルを別にする。ディレクトリも別の方が形態管理的に楽。
まとめて削除できるから。
</dd>

<dt>プラットフォーム非依存にする</dt>
<dd>
クロスプラットフォームのリグレッションテストに使いたいから。
</dd>

<dt>全テストのバッチ実行を可能とする</dt>
<dd>
エラーで停止しないこと、エラーが発生した一覧を取得できること。
これもリグレッションテスト用の要件。
</dd>

<dt>テストの個別実行・まとめ実行を可能とする</dt>
<dd>
開発補助としてユニットテストを使うための要件。
</dd>

<dt>ブラウザからも実行可能とする</dt>
<dd>
これも開発補助としての要件。この要件のために、はまりまくった裏話がある。
</dd>

</dl>
[[/html]]

[[ToDo|section:todo]]

[[国際化|head:]]
CB_Failure::toString() の実装が、今は英語で直。必要性は薄いかもしれない。

[[XML 出力|head:]]
スキーマを決めないといけない。実装は class CB_TestXMLResultPrinter で行う予定だが、現在中身は空。

[[HttpUnit|head:]]
複合試験的なツールが別途欲しい。セッション管理や、画面遷移の試験を自動化したいから。
 [[既存の HttpUnit|http://httpunit.sourceforge.net/]] は Java のツールなので、PHP4 で染まったアゼリアには馴染まないかも。

[[既知の問題|section:known]]

[[無限ループバグを停止できない|head:]]
PHP4 では無限ループにはまるようなプロセスの強制終了ができない。proc_get_status() あたりが PHP5 にしかなくて、走らせたプロセスの pid さえ取得できない。

[[テストラベルの変更が同期しない|head:]]
AzUnit の実行モデルの問題。テスト開始前にラベルを設定するのは CB_TestExecutor だが、実行途中には子プロセス(TestCase)から setLabel() メソッドで変更できてしまい食い違う可能性がある。setLabel() は deprecated にマークしたが・・・。

[[CB_TestRunner に同名のファイル(クラス)を追加できない|head:]]
同名のテストファイルが別々のディレクトリにあったとして、それを追加することはできない。仕様上、それらは同名のクラスを持ち、PHP4 には一旦定義したクラスをアンロードする機能がないため。

[[リファレンス|section:reference]]

#フレームワークソース ([[include/developer/azunit.csp]])
#API ([[az:fw.unittest:include/developer/azunit.csp]])
