[[概要|section:abstract]]
軽量コンテナを利用することで実装の挿げ替えが容易になり、柔軟なモデルを実現することができます。
 Azalea の軽量コンテナの特徴は以下の通りです。 

*setter ベース IoC を採用。ただしPHPに合わせて簡易化 
*レイヤーに合わせてコンテナを分割統治可能 
*シングルトンの管理をコンテナに委譲可能 
*デストラクタの代わりとなる自動シャットダウン機能を提供 

[[軽量コンテナとは|section:about_lwc]]
本項で言う「軽量コンテナ(light-weight container)」とは、Java界で言うところの IoC (Inversion of Control) コンテナを指しています。IoCコンテナには例えば [[Spring|http://www.springframework.org/]] や [[Pico Container|http://www.picocontainer.org/]] などがあり、[[Inversion of Control|http://www.kakutani.com/trans/fowler/injection.html]] は、Dependency Injection パターンとしても知られています。本項で示すよりも詳細な解説が Martin Fowler の [[記事|http://www.kakutani.com/trans/fowler/injection.html]] にあるので、参考にしてください。 

[[問題となるコード|head:problem_code]]
軽量コンテナは、プログラム内部構造からオブジェクトへの依存関係を設定として切り分けるユーティリティです。
 例えば、A というクラスが B というクラスのオブジェクトを使用する場合、以下のようなコードとなります。 

[[src]]
**/* 擬似コード */**

class A
{
    var $_b;
    function A()
    {
        $this->_b = new B();

        {{// B がシングルトンであれば、下のようになります。}}
        {{// $this->_b = B::getInstance();}}
    }

    function useB()
    {
        $this->_b->doSomething();
    }
}

$a = new A();
$a->useB();
[[/src]]

もちろん A および B の機能に満足している間は、このコードは完璧に動作します。
しかし、B の機能を拡張する必要があるにもかかわらず、B の改変ができない (他で使われているので/バイナリなので/出荷後なので/etc.)場合には手の施しようがありません。この場合、Bという特定の実装に依存していることが問題なのです。

さらに次のように、特定のインスタンスを利用するクラス群を考えます。 
[[src]]
**/* 擬似コード */**

class UsefulClass
{
    {{// シングルトンパターン}}
    function getInstance()
    {
        /* return singleton */
    }

    function sendMessage( $id, $msg );
    function receiveMessage( $id );
}

class A
{
    function doSomething()
    {
        $o = UsefulClass::getInstance();
        $o->sendMessage( 'abc', 'hello' );
    }
}

class B
{
    function doAnother()
    {
        $o = UsefulClass::getInstance();
        $o->receiveMessage( 'abc' );
    }
}

$a = new A();
$b = new B();
a->doSomething();
b->doAnother();

[[/src]]

A, B はメッセージをやり取りするために、同一の UsefulClass のインスタンスを必要としています。
この例で示されるように、よくある解としては、UsefulClass をシングルトンパターンで実装することです。
しかし、UsefulClass を別のオブジェクト群の通信で使いたい場合、シングルトンでは混線してしまいます。
このように、シングルトンパターンはクラスの可用性を著しく下げることがあります。この場合、インスタンスの管理が問題となっているのです。

[[軽量コンテナによる解決|head:answer]]
IoCコンテナでは、これらの問題を簡単に解決することができます。
具体的には、依存するオブジェクトをコンテナによって与えます。
最初の例でいえば、A は $_b を準備せず、コンテナに任せるようにします。

[[src]]
**/* 擬似コード */**

class A
{
    var $_b;
    function A() {}
    function useB()
    {
        $this->_b->doSomething();
    }
}
class B...

$container = new Container();
$container->register( 'objB', array('class'=>'''B''') );
$container->register( 'objA', array('class'=>'''A''', 'prop:''_b'''=>'''ref:objB''') );
$a =& $container->get( 'objA' );
$a->useB();

[[/src]]

クラス A は コンストラクタで B を作成しません。
ユーザーもまた、クラス A のインスタンスを直接作成はしません。
代わりに A, B のインスタンスを作成し、A の "_b" プロパティに B のインスタンスを設定するのが ''$container'' です。 

コンテナは register メソッドで与えられた設定に従って、指定されたオブジェクトを作成します。
この例では、"objA" は A クラスのインスタンスであり、その "_b" プロパティには "objB" を代入します。
同様に、"objB" は B クラスのインスタンスです。
例えば "objB" のクラス指定を C クラスに変更するには、コンテナに与える設定を変更すれば良いことになります。 

例では、プログラム内でコンテナを設定していますが、実際のコンテナでは設定ファイルなどにより柔軟に設定の変更が可能となっています。
結局の所、オブジェクトの作成と設定をコンテナという第三者に委任することにより、クラス A は クラス B の ''実装に直接依存せず、インターフェースにのみ依存する'' ようになります。 

次に、シングルトンを濫用していたコードの改良を考えます。 
[[src]]
**/* 擬似コード */**

class UsefulClass
{
    {{// シングルトンではありません}}
    function UsefulClass() {}
    function sendMessage( $id, $msg );
    function receiveMessage( $id );
}

class A
{
    var $_useful;
    function doSomething()
    {
        $useful->sendMessage( 'abc', 'hello' );
    }
}

class B
{
    var $_useful;
    function doAnother()
    {
        $_useful->receiveMessage( 'abc' );
    }
}

$container = new Container();
$container->register( '''useful''', array('class'=>'''UsefulClass''', '''singleton'=>TRUE'') );
$container->register( 'objA', array('class'=>'A', 'prop:_useful'=>'''ref:useful''') );
$container->register( 'objB', array('class'=>'B', 'prop:_useful'=>'''ref:useful''') );

$a =& $container->get( 'objA' );
$b =& $container->get( 'objB' );
a->doSomething();
b->doAnother();

[[/src]]

想像がつくと思いますが、この例ではコンテナにインスタンスの管理を委任しています。
コンテナに、"useful" で示されるオブジェクトをシングルトンとして管理するように指示することで、同じ "useful" を指す "objA" および "objB" は、同一のインスタンスを共有できるようになります。
UsefulClass はシングルトンではないので、''コンテナに別の識別子(例えば "useful2")を使えば、別のインスタンスとして生成できます''。

[[軽量コンテナのメリット|section:merit]]

[[html]]
<table class="cb_doc_table" border="1">
<tr><th>問題</th><th>導入前</th><th>導入後</th></tr>

<tr>
<td nowrap>特定の実装への依存</td>
<td nowrap>
オブジェクト間に強い依存関係
</td>
<td>
オブジェクトではなく、インターフェースに依存
</td>
</tr>

<tr>
<td nowrap>インスタンスの管理</td>
<td nowrap>
シングルトンや大域変数の濫用
</td>
<td>
コンテナがインスタンスを管理するので、各クラスの実装では管理コードが不要
</td>
</tr>
</table>
[[/html]]

例でも示しているように、軽量コンテナはプログラミング上の便利な道具に過ぎず、導入に伴う制約はほとんどありません。
どのようなインターフェースを持つクラスに対しても適用可能であり、管理されるクラスの実装にもコンテナに依存するコードは全く含まれません。

[[仕様|section:spec]]
[[クラス構成|head:classes]]
Azalea の軽量コンテナは、下表のたった二つのクラスからなる極めてシンプルな構成となっています。
PHP4はオブジェクト指向機能が貧弱であるため、インターフェース等を用意できない( 意味もない ) ことが主な理由となっています。 

[[html]]
<table class="cb_doc_table" border="1">
<tr>
<th nowrap>クラス名</th><th nowrap>ベースクラス名</th><th nowrap>役割と機能</th></tr>

<tr>
<td nowrap>[[az:fw.core:CB_LWContainer]]</td>
<td nowrap>&nbsp;</td>
<td>
軽量コンテナの実装、インスタンスの管理および生成を担います。後述するように階層(レイヤー)構造を持ち、ベースとなるコンテナに委譲する機能を有します。
</td>
</tr>

<tr>
<td nowrap>[[az:fw.core:CB_LWContainerConfig]]</td>
<td nowrap>[[az:fw.core:CB_ConfigManager]]</td>
<td>
CB_LWContainer にインスタンス管理/生成のルールを提供します。このクラスは ".ini" ファイルを読み込みますが、継承・拡張して独自の設定クラスを開発することも可能です。
</td>
</tr>
</table>
[[/html]]

[[コンテナ規約|head:rules]]
コンテナに登録して生成可能なクラスは、一つだけ制約があります。
必ず、無引数のコンストラクタにしなければなりません。( コンテナがオブジェクトを生成するためには、コンストラクタの形式を限定する必要があるため。) 

[[src]]
class Registerable
{
    function ''Registerable''()
    {
    }
}

$container->register( {{識別子}}, array('class'=>'Registerable') );

[[/src]]

コンテナには生成したオブジェクトのプロパティを初期化する機能があるため、この制約による不都合はほとんどないはずです。
 また、後述する自動ブート("''auto_boot''") 設定を利用すれば、コンテナがプロパティを設定し終えた後に初期化メソッドを自動的に呼びだすことも可能となっています。 

*「''自動ブート''」
 軽量コンテナに管理されるクラスは、まずインスタンスが作成された後にプロパティが設定されます。
そのため、コンストラクタではほとんど初期化ができません。そこで、軽量コンテナにはプロパティ設定後に自動的に "''boot()''" メソッドを呼び出してからインスタンスを返す機能があります。自動ブート機能を利用する場合、以下のように "boot()" メソッドを実装してください。 
[[src]]
class Registerable
{
    function Registerable() {}
    var $_dbname;
    function ''boot''()
    {
        // $this->_dbname は設定済み
        connect_to_database( $this->_dbname );
    }
}
[[/src]]
*「''自動シャットダウン''」
 オブジェクトのライフタイム終了時に、終了処理を行いたい場面は良くあります。ソケットやファイルのクローズなどが顕著な例の一つです。軽量コンテナには Azalea の [[処理フロー|doc:dev/base/request]] の最後に、生成したオブジェクトの "''shutdown()''" メソッドを自動的に呼び出す機能が用意されています。(ただし、下記設定を有効にする必要があります)。自動シャットダウン機能を利用する場合、以下のように "shutdown()" メソッドを実装してください。 
[[src]]
class Registerable
{
    var $_connection;
    function ''shutdown''()
    {
        close_connection( $this->_connection );
    }
}
[[/src]]

[[設定項目|head:config]]
軽量コンテナには、管理すべきオブジェクトに関する設定を与える必要があります。 
 ( オブジェクトは識別子で区別され、識別子ごとに以下の表で示す設定を行う必要があります。)

[[html]]
<table class="cb_doc_table" border="1">
<tr><th nowrap>設定名</th><th nowrap>値</th><th nowrap>デフォルト値</th><th nowrap>必須</th><th nowrap>説明</th></tr>

<tr>
<td nowrap>class</td>
<td nowrap>文字列</td>
<td nowrap>&nbsp;</td>
<td nowrap>YES</td>
<td>
オブジェクトのPHPクラス名
</td>
</tr>

<tr>
<td nowrap>require</td>
<td nowrap>文字列</td>
<td nowrap>&nbsp;</td>
<td nowrap>NO</td>
<td>
PHPクラスをロードするために必要なファイルを指定します。複数ファイルある場合は空白で区切ってください。
ファイルは [[php:require_once]] でロードされます。
</td>
</tr>

<tr>
<td nowrap>singleton</td>
<td nowrap>論理値(として解釈)</td>
<td nowrap>真</td>
<td nowrap>NO</td>
<td>
オブジェクトの生成方法を指定します。真(となる値)であれば、この識別子のオブジェクトはコンテナ内で一個だけ生成され、使いまわされます。偽であれば、識別子が指定されるたびに新たなオブジェクトが生成されます。
</td>
</tr>

<tr>
<td nowrap>auto_boot</td>
<td nowrap>論理値(として解釈)</td>
<td nowrap>真</td>
<td nowrap>NO</td>
<td>
生成したオブジェクトの <b>boot()</b> メソッドをプロパティ設定後に呼び出すか指定します。真でかつ、boot() メソッドがあれば呼び出します。コンストラクタの代わりに使えます。
</td>
</tr>

<tr>
<td nowrap>auto_shutdown</td>
<td nowrap>論理値(として解釈)</td>
<td nowrap>偽</td>
<td nowrap>NO</td>
<td>
生成したオブジェクトの <b>shutdown()</b> メソッドをリクエスト処理終了時に自動的に呼び出すか指定します。真でかつ、shutdown() メソッドがあれば呼び出します。デストラクタの代わりに使えます。
</td>
</tr>

<tr>
<td nowrap>prop:<i>プロパティ名</i></td>
<td nowrap>val(ue):<i>文字列</i></td>
<td nowrap>&nbsp;</td>
<td nowrap>NO</td>
<td>
生成したオブジェクトのプロパティに、文字列値を設定します。
</td>
</tr>

<tr>
<td nowrap>prop:<i>プロパティ名</i></td>
<td nowrap>ref:<i>識別子</i></td>
<td nowrap>&nbsp;</td>
<td nowrap>NO</td>
<td>
生成したオブジェクトのプロパティに、識別子で参照するオブジェクトをコンテナから取得して設定します。
</td>
</tr>
</table>
[[/html]]

コンテナに対しては、設定名をキーとした連想配列として識別子とともに設定します。具体的には以下のようになります。

[[src]]
$container = new CB_LWContainer( $base_container, $some_config );
$container->register( {{識別子}}, ''array('class'=>'Foo', 'require'=>'fw/foo.csp')'' );
$foo =& $container->getInstance( {{識別子}} );
[[/src]]

[[設定クラス|head:config_class]]
ここまでコンテナに直接オブジェクトの生成方法を設定してきましたが、これでは結局依存関係をコーディングする必要があるためユーザビリティに欠けます。そこでアゼリアでは軽量コンテナから設定の管理を別クラスに切り出しています。 

[[src]]
{{// デフォルトでは ini ファイルを読み込む実装}}
$config = new CB_LWContainerConfig( 'hoge.ini' );
$container = new CB_LWContainer( $base_container, $config );
[[/src]]

[[az:fw.core:CB_LWContainer]] のコンストラクタの第二引数には [[az:fw.core:CB_LWContainerConfig]] もしくはそのサブクラスのインスタンスを渡します。[[az:fw.core:CB_LWContainerConfig]] を継承・拡張することで、例えばデータベースを読み書きする設定オブジェクトを作成することも可能になります。 

設定に使用する ini ファイルでは識別子をセクション名とし、各セクションに設定を記述していきます。 
[[src]]
''[Foo]''                      ; 識別子 Foo
class       = CB_Foo        ; クラス名
require     = fw/foo.csp    ; ロードするファイル
singleton   = 0             ; シングルトンにしない
prop:_msg   = val:hoge      ; _msg プロパティに文字列 "hoge" をセット

''[Bar]''                      ; 識別子 Bar
class       = CB_Bar        ; クラス名
singleton   = 1             ; シングルトンとして管理
prop:_foo   = ref:Foo       ; _foo プロパティに Foo 識別子のオブジェクトをセット
[[/src]]

[[レイヤー構成|head:layer]]
MVCでのレイヤー構成では、レイヤーごとに開発者が異なるのが普通です。
そのような状況ではたった一つのコンテナで全レイヤーのオブジェクトを管理するのは、作業範囲が重複することが問題となります。
逆にレイヤーごとにコンテナを用意することにすると、下位のレイヤーに依存しているオブジェクトの依存関係を設定できないことが問題となります。

この問題の解決のため、[[az:fw.core:CB_LWContainer]] は下位レイヤーのコンテナをベースコンテナとして持つことが可能になっています。
ベースコンテナを持つコンテナは、自分が管理していない識別子のオブジェクトを指定されると、ベースコンテナに問い合わせます。 

[[src]]
$container = new CB_LWContainer( null, $some_config );
$container->register( '''foo''', array('class'=>'Foo') );

{{// $container をベースコンテナとするコンテナを作成}}
$container2 = new CB_LWContainer( ''$container'', $another_config );
{{// 下位コンテナの "foo" を参照可能}}
$container2->register( 'bar', array('class'=>'Bar', 'prop:_foo'=>'''ref:foo''') );

$bar =& $container2->getInstance( 'bar' );
...
[[/src]]
フレームワークでは、''$G_container_base'' 大域変数に最下位のコンテナを作成しています。

[[html]]
<table border="1">
<tr><th nowrap>大域変数名</th><th nowrap>ベースコンテナ</th><th nowrap>設定ファイル名</th><th nowrap>役割</th></tr>

<tr>
<td nowrap>$G_container_base</td>
<td nowrap>null</td>
<td nowrap>lwc.ini</td>
<td>
最下位レイヤーのコンテナ。フレームワークで利用する。
</td>
</tr>

</tr>
</table>
[[/html]]

[[チュートリアル|section:tutorial]]

[[クラスを作成する|head:tut_create_class]]
軽量コンテナで管理するクラスは無引数のコンストラクタを持つようにしなければなりません。
 それ以外は自由に記述して構いません。プロパティはコンテナの初期化に任せてください。 

[[src]]
<?php

class CB_Foo
{
    function CB_Foo() {}

    {{// コンテナによって設定されるファイル名}}
    var $_file;

    function log( $msg )
    {
        $fp = fopen( $this->_file, 'a' );
        fwrite( $fp, $msg . "\n" );
        fclose( $fp );
    }
}
?>
[[/src]]

[[src]]
<?php

class CB_Bar
{
    function CB_Bar() {}

    {{// コンテナによって設定されるロガーオブジェクト}}
    var $_logger;

    function doA()
    {
        $this->_logger->log( "A!" );
    }
}
?>
[[/src]]

[[設定ファイルを記述する|head:tut_config]]
デフォルトでは、$G_container_base の参照する設定ファイルはCGIディレクトリの "''lwc.ini''" です。
詳しく言えば、[[common.ini|doc:ext/config#common.ini]] の ''[LWC] config'' で指定されているファイルになります。 

"''lwc.ini''" を下記のように記述してください。( ログファイルのパスは適宜変更すること。)
[[src]]
''[Foo]''
class           = CB_Foo
require         = foo/foo.csp
prop:_file      = val:{{どっかのパス}}/log.txt

''[Bar]''
class           = CB_Bar
require         = foo/bar.csp
prop:_logger    = ref:Foo
[[/src]]

[[軽量コンテナを利用する|head:tut_use_container]]
以上の設定で軽量コンテナを利用する準備は整っています。
以下のコードを実行して、ログファイルにログが書き込まれるのを確認してください。 
[[src]]
<?php
require_once( 'fw/lwc.csp' );
global $G_container_base;

$bar =& $G_container_base->getInstance( 'Bar' );
$bar->doA();
?>
[[/src]]


[[実装クラスを変更する|head:tut_change_class]]
ファイルに出力する代わりに、[[php:syslog]] でログを出力するロガーに切り替えたいとします。
まず、新規のロガークラスを作成します。 

[[src]]
<?php
class CB_Zot
{
    function CB_Zot() {}

    {{// コンテナで設定}}
    var $_priority;
    var $_facility;

    var $_opened = FALSE;
    function _open()
    {
        if( $this->_opened ) return;

        define_syslog_variables();

        {{// 文字列から定数値を取得}}
        $this->_priority = constant($this->_priority);
        $facility = constant($this->_facility);
        openlog("Zot", LOG_PID, $facility);

        $this->_opened = TRUE;
    }

    function log( $msg )
    {
        $this->_open();
        syslog( $this->_priority, $msg );
    }
}
?>
[[/src]]

"''lwc.ini''" を編集して、以下のようにします。(元との差分のみ記述)
 このようにして、CB_Bar の実装は一切変更せずに挙動を変えることができます。 
[[src]]
[Bar]
{{;; 参照先を Zot に変更}}
;prop:_logger   = ref:Foo
prop:_logger    = ref:Zot

[Zot]
class           = CB_Zot
require         = foo/zot.csp
prop:_priority  = val:LOG_ALERT
prop:_facility  = val:LOG_LOCAL0

[[/src]]

[[文字列プロパティを変更する|head:tut_change_string]]
上記の例では Zot は LOG_ALERT レベルでログの出力を行います。
こういった文字列プロパティも設定ファイルから自由に変更可能です。 
[[src]]
[Zot]
;; LOG_EMERGレベルに変更
;prop:_priority = val:LOG_ALERT
prop:_priority  = val:''LOG_EMERG''
[[/src]]

[[複数のインスタンスを利用する|head:tut_multi_instance]]
軽量コンテナはデフォルトでは各識別子のオブジェクトを一度しか生成しません。
例えば "Bar" 識別子のインスタンスをコンテナから取り出すたびに生成するには、以下のように設定ファイルの "singleton" で "0" を与えてください。

[[src]]
[Bar]
''singleton       = 0''
[[/src]]

[[自動ブート機能を利用する|head:tut_auto_boot]]
前出の CB_Zot クラスでは、syslog デバイスをオープンする必要があるのだが、コンストラクタではプロパティが未初期化のためオープンできず、"''$_opened''" フラグで後からチェックするようにしています。 
 このようなケースはしばしばあり得るので、[[az:fw.core:CB_LWContainer]] ではインスタンスを作成してプロパティを設定した後、自動的に初期化メソッドを呼び出す自動ブート機能を提供しています。自動ブート機能の利用には、以下のように "''boot()''" メソッドを実装する。変更前の実装と比較してみてください。非常にシンプルになっているのが確認できます。 
[[src]]
<?php
{{/* 自動ブート機能を利用して書き直したバージョン */}}
class CB_Zot
{
    function CB_Zot() {}

    {{// コンテナで設定}}
    var $_priority;
    var $_facility;

    function boot()
    {
        define_syslog_variables();

        $this->_priority = constant($this->_priority);
        $facility = constant($this->_facility);
        {{// ログデバイスをオープン}}
        openlog("Zot", LOG_PID, $facility);
    }

    function log( $msg )
    {
        syslog( $this->_priority, $msg );
    }
}
?>
[[/src]]


[[自動シャットダウン機能を利用する|head:tut_auto_shutdown]]
Azalea の軽量コンテナでは、コンテナがインスタンスを管理する特徴を利用して自動シャットダウン機能を提供しています。
自動シャットダウン機能とは、リクエスト処理の最後にオブジェクトの "''shutdown()''" メソッドを呼び出すものです。 

例えば、上記 CB_Zot クラスではオープンした syslog デバイスをクローズする必要がありました。リクエスト処理中に何度もオープンクローズを繰り返すのはパフォーマンス上問題があるので、リクエスト処理の最後にクローズするようにしたい場合、以下のように "''shutdown()''" メソッドを追加してください。 
[[src]]
<?php
class CB_Zot
{
    ...
    function shutdown()
    {
        closelog();
    }
}
?>
[[/src]]
また、自動シャットダウンはデフォルトで無効の為、"lwc.ini" にて "''auto_shutdown''" の設定を有効にしてください。
[[Rationale|section:Rationale]]

[[html]]
<dl>
<dt>"auto_shutdown" は便利なのに、デフォルトではなぜ無効なのか？</dt>
<dd>
シャットダウン対象のオブジェクトをコンテナが管理するため、"auto_shutdown" 対象のオブジェクトはリクエスト終了時まで解放されずメモリを圧迫する。また、明示的に指定することで事故も防止できる。
</dd>

<dt>では "auto_boot" がデフォルトで有効である理由は？</dt>
<dd>
自動シャットダウン機能ではメモリを圧迫する可能性があるのに対して、自動ブート機能ではその心配がないため。また、コンストラクタに制限を設けている分、自動ブート機能の使用頻度は高いと判断できるため。
</dd>

<dt>コンテナの階層を、ツリーではなくレイヤーにした理由は？</dt>
<dd>
下層のコンテナを複数統合するコンテナモデルは、[[Pico Container|http://www.picocontainer.org/Five+minute+introduction]] などで採用されている。しかしながら、(1)上層で見付からないコンポーネントを<u>どの下層コンテナに問い合わせるか不明</u>であること、(2)レイヤー内の依存関係を単純化すること、からレイヤーに合わせたモデルを採用しました。
</dd>

</dl>
[[/html]]

[[リファレンス|section:reference]]
* 実装コード ( [[code/include/fw/lwc.csp]] )
* フレームワーク層コンテナの作成 ( [[code/include/fw/prepend.csp]] )