[[概要|section:abstract]]

[[概要(パワーポイント)|cb6:page=FileView&gid=3561&fCID=120332&fFID=120337&cp=fl]]

[[目的と設計方針|section:purpose]]
永続化レイヤー(Persistent Layer)はサーバー上に保存される情報の管理を担当する。モジュールではなくレイヤーである理由は、永続化レイヤーの主たる役割がデータベース管理であり、アプリケーションロジックとデータベースの間に位置しているからである。

永続化レイヤーはサーバー上のデータを適切に保護するため、トランザクション管理機能を有する。データベースのトランザクションはもちろんだが、データベーストランザクションと連動するよう、サーバー上のファイルやセッション情報の管理も担当する。

永続化レイヤーの設計にあたっては、以下の方針を立てた。
*''迅速な開発をサポートする''
 → RDBの詳細な知識を要しない
 → データ構造の簡便な設計が可能
*''内部仕様と実装は明快で小さく''
 → 速度(実行効率)確保のため
 → 他 RDBMS への移植を容易にするため
 → 内部仕様を利用したクエリを作成可能とするため

[[モジュール構成|section:module]]
永続化レイヤーは複数のファイルに分けられたクラスと関数、およびトランザクション処理から構成される。各ファイルとその中に含まれるクラスや関数の関係は以下の表に示す通り。

[[include/fw/database.csp|include/fw/database.csp]]

[[html]]
<dl><dd>
[[/html]]
データベース接続の基本的な抽象化を行う。データベースサーバー固有の実装は全てこのファイルの中で隠蔽している。MySQL 以外の RDBMS に対応するには、このファイル中のクラスおよび関数を移植すれば良い。
*class [[az:fw.persistent:CB_DatabaseConnection]]
 データベースに直接アクセスする API の抽象化を行う。接続処理、エラー処理、クエリの発行など。
*class [[az:fw.persistent:CB_TableManager]]
 トランザクション中で使用したテーブルの情報を管理する。''CB_TableInfo'' のファクトリとして機能する。
*class [[az:fw.persistent:CB_TableInfo]]
 テーブルの抽象化を行う。すなわち、テーブルの型定義と抽象型の実装を担当する。''CB_Row'' のファクトリとして機能する。
*class [[az:fw.persistent:CB_Row]]
 一行を表現する。行の各カラムの持つ型は、生成源であるテーブルの型定義による。
*class [[az:fw.persistent:CB_RowSet]]
 条件にマッチする行の集合を表現する。すなわち、テーブルに対する検索機能を提供する。
*class [[az:fw.persistent:CB_MultiRowSet]]
 ''CB_RowSet''の機能を拡張したクラスであり、互いに結合された複数のテーブル行を取得することができる。
*function [[az:fw.persistent:include/fw/database.csp:cb_queryf]]
 クエリ中の特殊文字をエスケープするための関数。
[[html]]
</dd></dl>
[[/html]]

[[include/fw/basic_date.csp|include/fw/basic_date.csp]]

[[html]]
<dl><dd>
[[/html]]
単純に数値で表現される日付や時刻のクラスを定義する。単純とはすなわち、タイムゾーンや夏時間などの概念を持たないということである。''fw/database.csp'' でテーブル中の日付、時刻、日付時刻といった抽象型の値を表現するのに利用される。
*class [[az:fw.core:CB_Date]]
 日付を表現する。
*class [[az:fw.core:CB_Time]]
 時刻を表現する。
*class [[az:fw.core:CB_DateTime]]
 日付時刻を表現する。一般的な時間に対応し、国際化の観点からは世界標準時(UTC)として処理される。
*class [[az:fw.core:CB_TimeStamp]]
 UNIX タイムスタンプを表現する。
[[html]]
</dd></dl>
[[/html]]

[[include/fw/persistent.csp|include/fw/persistent.csp]]

[[html]]
<dl><dd>
[[/html]]
PHP のクラス定義をデータベースの型定義として利用する「オブジェクトリレーショナル拡張」を実装する。''fw/database.csp'' を使用しており MySQL には非依存である。
*class [[az:fw.persistent:CB_PersistentBase]]
 永続化クラスのベースクラス。下記 ''cb_class2table'' 関数に渡すクラスはこのクラスを継承(拡張)しなければならない。
*class [[az:fw.persistent:CB_ReadOnlyBase]]
 読み込みのみサポートする永続化クラスのベースクラス。''CB_PersistentBase'' を継承し、変更メソッドを無効化している。
*function [[az:fw.persistent:include/fw/persistent.csp:cb_class2table]]
 永続化クラス名を受け取り、対応する抽象テーブルオブジェクト(''CB_TableInfo'' クラスのインスタンス)を返す。
 **一度クラスを作成後は ''CB_TableManager'' から直接 ''CB_TableInfo'' を取得することが可能で、効率も良い。**
[[html]]
</dd></dl>
[[/html]]

[[include/fw/server_file.csp|include/fw/server_file.csp]]

[[html]]
<dl><dd>
[[/html]]
サーバー上に保存するファイル(= ''永続化ファイル'')を管理する。
*class [[az:fw.persistent:CB_ServerFileManager]]
 データベーストランザクションと連動し、コミットが正常に行われる時にサーバー上のファイルを保存・削除する。''CB_ServerFile'' を継承するオブジェクトは自動的にこのクラスによって管理される。
*class [[az:fw.persistent:CB_ServerFile]]
 永続化ファイルのベースクラス。各アプリケーションはこのクラスを拡張して必要なプロパティを付加し、使用する。
[[html]]
</dd></dl>
[[/html]]

[[include/fw/dblist.csp|include/fw/dblist.csp]]

[[html]]
<dl><dd>
[[/html]]
データベース中でリストは単純に、順番を保持するカラムとして表現される。
 このファイルではモデルにリストのインターフェースを持たせるためのユーティリティが提供される。
*function [[az:fw.persistent:include/fw/dblist.csp:cb_set_list_index]]
 この関数は一連のオブジェクトの ID を取り、その順に番号をセットするユーティリティである。下記 ''CB_RowList'' よりも高速であるが、要素を追加したり削除したりする機能は持たない。
*class [[az:fw.persistent:CB_RowList]]
 UI で一度に一つの要素をリスト中で前後に移動したり追加したりするためのユーティリティ。
[[html]]
</dd></dl>
[[/html]]

[[include/fw/append.csp|include/fw/append.csp]]

[[html]]
<dl><dd>
[[/html]]
トランザクション処理のうち、最後のコミット処理を担当する。
 データベーストランザクションと連動する各種クラスの操作もこのファイル中で行われる。
[[html]]
</dd></dl>
[[/html]]

[[データベース抽象|section:abstraction]]
データベースの抽象化を行う目的は以下の通り。
#RDBMS の詳細を隠蔽し、容易にモデルを構築可能とするため
#MySQL 以外の RDBMS への移植を可能とするため

抽象化は 2 段階からなる。
 すなわち、データベース接続 API を隠蔽する 1 段階目、および各種データベースの操作を行う''SQL''を抽象化する 2 段階目である。いずれも [[include/fw/database.csp|include/fw/database.csp]] 内で実装されている。

データベース接続 API の隠蔽は [[az:fw.persistent:CB_DatabaseConnection]] クラスにより実装されている。
 [[az:fw.persistent:CB_DatabaseConnection]] クラスオブジェクトは軽量コンテナより取得する。
 
[[src]]
$db =& $G_container_base->getInstance( 'dbconn' );
$result = $db->query( 'SELECT * FROM cb_table1;' );
if ( $result === FALSE )
{
    echo 'DB Error: ', $db->getError();
}
[[/src]]
上記例ではまず $db にデータベースオブジェクトを取得している。
 $db のメソッドである query や getError を使用することで、接続の詳細や実装を隠蔽している。
 しかしながら、query メソッド中にある SQL はこのままでは各 RDBMS に依存し、またアプリケーション開発者に SQL の知識を要求することになる。

そこで次に、RDBMS の構造で主要な役割を果たす「テーブル」を抽象化する。
 下に示すように、テーブルを表現するオブジェクト(''$table'')を導入する。

[[src]]
$manager =& $G_container_base->getInstance( 'table_manager' );
$table =& $manager->getTableInfo( 'hoge' );

{{// $table が CB_TableInfo オブジェクトであることを確認する}}
echo get_class( $table );

$table->addColumn( 'column1', array('type' => 'char') );
$table->addColumn( 'column2', array('type' => 'int' ) );
$table->addIndex( 'index1', array('cols'=>array('column1') ) );

$table->createTable();
[[/src]]
テーブルオブジェクト([[az:fw.persistent:CB_TableInfo]] クラスのインスタンス)は [[az:fw.persistent:CB_TableManager]] クラスオブジェクトにより管理されている。
 上の例では ''getTableInfo'' メソッドにより "''hoge''" テーブルオブジェクトを作成している。その後 ''addColumn'' および ''addIndex'' メソッドにより "''column1''", "''column''" の 2 カラムと "column1" への一次元インデックス "''index1''" を定義し、''createTable'' メソッドでテーブルを作成している。
 例よりわかる通り、SQL 文は一切使用しない。

[[az:fw.persistent:CB_TableManager]] はデータベース中に作成した各テーブルの型情報(カラムおよびインデックス)を記憶しており、既に作成済みのテーブルも ''getTableInfo'' で取得できる。
 作成済みかどうかはテーブルオブジェクトの ''exists'' メソッドで判別できる。

[[src]]
$table2 =& $manager->''getTableInfo( 'hoge' )'';

if ( $table2->''exists''() ) {
    echo 'OK!';
} else {
    echo 'Bad!';
}
[[/src]]

さらに、テーブル中の各行の取得、挿入、削除でも SQL を隠蔽するため、[[az:fw.persistent:CB_Row]] クラスを導入する。
 取得および挿入はテーブルオブジェクトの ''getRow'', ''newRow'' メソッドがファクトリとして使われる。

[[src]]
$row1 =& $table->newRow();

{{// CB_Row クラスのインスタンスであることを確認}}
echo get_class( $row1 )

$row1->set('column1', '行 1');
$row1->set('column2', 123);

$oid1 = $row1->getOID();
$_row1_ =& $table->getRow( $oid1 );
echo $_row1_->get('column1');

$_row1_->delete();
[[/src]]
新規行の作成は上の例に示される通り、''newRow'' メソッドにより行われる。
 その後各カラムへの値の代入は行オブジェクト(= [[az:fw.persistent:CB_Row]])の ''set'' メソッドにて行われている。

永続化レイヤーは各行に一意の ID を自動的に割り当てる。
 ''getOID'' メソッドにより ID を取得でき、その ID を使用してテーブルオブジェクトの ''getRow'' により既存の行の取得が可能となっている。
 行の削除は ''delete'' メソッドにより行われる。

データベースの基本的な構造である接続、テーブル定義、行の操作の抽象化は以上に示した通り実現されている。
 この他、永続化レイヤーは SQL のデータタイプ、検索操作、トランザクション管理なども抽象化するが、それらは以降の章で個別に解説する。

[[抽象型仕様|section:type]]
前章でテーブルの抽象化の例において、''addColumn'' や ''addIndex'' といったメソッドを使用してテーブルの型定義を行った。
 これらのメソッドの第 2 引数にて指定されたものが、これから解説する抽象型である。

抽象型とは、直接的には SQL のデータタイプを一般化したものである。
 SQL 自体が標準ではあるのだが、各データタイプの値域やサポート状況は RDBMS ごとに様々であるため、抽象型として分離することによりポータビリティを確保している。

[[src]]
$table->addColumn( 'column1',
    ''array('type' => 'char', 'length' => 255)'' );
[[/src]]

上の例に示されるように、抽象型は PHP の連想配列で表現される。
 これは各型に多種の属性があり、将来属性が増えた場合にも同一の API で拡張できるようにするためである。

[[オブジェクトID|head:]]
行オブジェクトの ''getOID'' メソッドで得られるオブジェクトIDの型は、データベース内部では 1 以上の 64 ビット整数として表現されている。
 しかし、PHP 上では''文字列'' である。したがって、オブジェクトIDに対する四則演算は**''絶対に行ってはならない''**。

この理由は PHP で扱える整数型がほとんどの場合 32 ビット符合付き整数だからである。
 アゼリアではモデル設計上巨大なテーブルが作成されるケースも出てくることが予想される。
 そのため 64 ビットのオブジェクトIDを持たせているが、常に文字列として処理することを心がけよ。

[[カラム型|head:]]
カラム型は以下の表に示す属性からなる連想配列で指定する。
 全ての属性がどの型でも有効なわけではない。
 例えば、非数値型に "unsigned" 属性を指定しても無視される。

カラムに格納する最大領域を ''length'' 属性で指定できる型が存在するが、強い理由がない限り指定してはならない。
 デフォルト値を使用することで無用なトラブルや非互換性を回避できるからである。

[[html]]
<table class=cb_doc_table border="1">
<tr><th nowrap>キー(属性名)</th><th nowrap>値</th><th nowrap>説明</th></tr>
<tr>
<td nowrap>type</td>
<td>"int", "double", "float", "char", "text", "blob", "date", "time", "datetime", "timestamp", "reference", "relation", "weak_relation", "list_index" のいずれか</td>
<td>
必須属性で、以下のようにカラムの型を指定する。
<ul>
<li><b>int</b> - 整数型。<b>length</b> 属性を指定しないと 4 バイト(32 ビット)の値域である。また <b>unsigned</b> 属性を指定しないと符合付き整数となる。
<li><b>double</b> - IEEE 倍精度(64 ビット)浮動小数。<b>unsigned</b> 属性を指定しないと符合付き小数となる。
<li><b>float</b> - double と同じ
<li><b>char</b> - 文字列。<b>length</b> 属性を指定しないと 100 文字(not バイト)が上限。またカラムにインデックスを張る場合、定数 <b>CB_DATABASE_MAX_STRINDEX</b> 以下である必要がある。MySQLの仕様により前後の空白文字がトリムされてしまうため、<b>前後の空白文字を文字列として含めたい場合にはblobを用いる必要がある。</b>
<li><b>text</b> - char と同じ。
<li><b>blob</b> - バイナリオブジェクト(<b>B</b>inary <b>L</b>arge <b>OB</b>ject)。<b>length</b> 属性を指定しないと 65535 バイトが上限。
<li><b>date</b> - 日付型。年/月/日を保持する。[[az:fw.core:CB_Date]] を媒介して取得設定される。
<li><b>time</b> - 時刻型。時:分:秒を保持する。[[az:fw.core:CB_Time]] を媒介して取得設定される。
<li><b>datetime</b> - 日付時刻型。年月日時分秒を保持する。[[az:fw.core:CB_DateTime]] を媒介して取得設定される。
<li><b>timestamp</b> - タイムスタンプ型。Unix epoch(1970年1月1日 00:00:00 GMT)からの通算秒を保持する。[[az:fw.core:CB_TimeStamp]] を媒介して取得設定される。
<li><b>relation</b> - (単方向)リレーション。<b>to</b> 属性で指定したテーブルの行を参照し、参照先の行が削除されると自動的に参照元の行も削除される。<b>自動的にインデックスが作成される。</b>
<li><b>weak_relation</b> - (単方向)リレーション。<b>to</b> 属性で指定したテーブルの行を参照し、参照先の行が削除されると自動的に <b>NULL</b> になる。<b>自動的にインデックスが作成される。</b>
<li><b>reference</b> - 任意のテーブルの行への参照。参照先の行が削除されても自動的な更新は行われない。参照先が削除されている場合に取得を試みると、<b>FALSE</b> が返る。
<li><b>list_index</b> - リストのインデックスを保持する専用型。整数型であるが、初期値が <b>INT_MAX</b> になるため、最後尾への追加を表現できる。
</ul>
</td>
</tr>

<tr>
<td nowrap>length</td>
<td>整数</td>
<td>
整数型、文字列型、BLOB に指定できる、使用領域のバイト数。格納領域の大きさが指定した値以上であることを保証する。マッピングする SQL データ型に応じて、指定した大きさ以上の領域が利用可能である場合がある。
</td>
</tr>

<tr>
<td nowrap>unsigned</td>
<td>TRUE または FALSE</td>
<td>
数値型(int, float, double)に指定できる。TRUE を指定すると符合無しとなる。
</td>
</tr>

<tr>
<td nowrap>notnull</td>
<td>TRUE または FALSE</td>
<td>
全ての型に指定できる。TRUE の場合 NULL (PHP でも <b>null</b>)にならず、数値であれば 0、文字列であれば空文字列になる。
</td>
</tr>

<tr>
<td nowrap>to</td>
<td>文字列(テーブル名)</td>
<td>
リレーション(relation, weak_relation)に指定できる。参照する行があるテーブルの名前。リレーションの場合省略不可。
</td>
</tr>

<tr>
<td nowrap>unique</td>
<td>TRUE または FALSE</td>
<td>
リレーション(relation, weak_relation)に指定できる。リレーションは自動的にインデックスが作成されるが、<b>unique</b> 属性で TRUE を指定しない限り重複値を許可する。この属性に TRUE を指定すると、リレーションカラムに重複値を指定できなくなる。
</td>
</tr>

<tr>
<td nowrap>lazy</td>
<td>TRUE または FALSE</td>
<td>
TRUE を指定すると、後述する<b>遅延ローディング</b>を実現する。
</td>
</tr>

<tr>
<td nowrap>delay</td>
<td>TRUE または FALSE</td>
<td>
<b>lazy</b> 属性の別名。
</td>
</tr>
</table>
[[/html]]

[[インデックス型|head:]]
インデックスの型もカラム型と同様、連想配列で指定する。
 インデックスの効果や作成するべき場面については [[こちら|#index]] に詳述している。
 インデックスを指定できるカラムは以下のいずれかの型に限定される。

[[html]]
<blockquote>
<tt>int, char, double, time, date, datetime, timestamp, relation, weak_relation, list_index</tt>
</blockquote>
[[/html]]

ただし、char 型については定数 ''CB_DATABASE_MAX_STRINDEX'' の大きさまでに限定される。
また、''relation'', ''weak_relation'' 型については自動的にそれらのカラムへの一次元インデックスが作成される。

[[html]]
<table class=cb_doc_table border="1">
<tr><th nowrap>キー(属性名)</th><th nowrap>値</th><th nowrap>説明</th></tr>
<tr>
<td nowrap>cols</td>
<td>カラム名の配列 or カラム名</td>
<td>
インデックスを貼る対象となるカラム名を順に収めた配列。要素が 2 個以上あるときは、多次元インデックスとなる。カラム名の代わりに <b>null</b> を指定すると、OIDへのインデックスとなる。一次元インデックスであれば、配列ではなく直接カラム名文字列を指定することも可能。
</td>
</tr>

<tr>
<td nowrap>unique</td>
<td>TRUE または FALSE</td>
<td>
TRUE を指定すると重複値を許可しない、ユニークインデックスを作成する。デフォルトは重複値を許可する。
</td>
</tr>
</table>
[[/html]]

[[遅延ローディング|head:]]
永続化レイヤーは通常、行の取得時には全てのカラムをまとめて取得する。
 だが、カラム数が多い場合、大きなテキスト、あるいは BLOB などを持つテーブルの行では、使用頻度の低いカラムが存在することがある。

カラムの型指定で "''lazy''" 属性に TRUE を指定すると、行の取得時にはそのカラムのデータは取得されない。
 カラムを実際に使用する際に、動的に取得されるようになる。

''"lazy" 指定はパフォーマンスにのみ影響を与え、それ以外の一切に影響しない。''

[[動的なデータ構造定義|section:dynamic_table]]
サイボウズ製品ではしばしば顧客にデータ型を指定させるものがある。
 代表的なものはデヂエだが、Office/ガルーンのアドレス帳など他にもいくつか存在する。
 そのため、永続化レイヤーでは動的にデータ構造を定義できる機能を要件としている。

具体的な実装は前出の [[az:fw.persistent:CB_TableInfo]] クラスの ''addColumn'' や ''addIndex'' メソッドである。
 これらを使用することで動的にカラムやインデックスを追加可能となっている。

同様にしてカラムやインデックスを削除する機能も用意されている。
 しかし特にカラムの削除は多くのトラブルを招きかねないため、避けるべきである。
 ''カラムは原則として追加のみ行うこと。''ユーザーに見せたくないカラムは削除ではなく、隠蔽するように実装せよ。

また MySQL の仕様上の制限(外部キー制約を DROP できない)から、''リレーションは削除できない。''
"relation" 型で一度作成してしまうと、参照先が削除されると連動して削除されてしまうため、これが望ましくない場合 "weak_relation" を使用せよ。

[[src]]
$manager =& $G_container_base->getInstance( 'table_manager' );
$table =& $manager->getTableInfo( 'hoge' );

$table->addColumn( 'column1', array('type'=>'char') );
$table->addColumn( 'column2', array('type'=>'int') );

$table->createTable();

''$table->delColumn( 'column1' );''
''$table->addColumn( 'column3', array('type'=>'float') );''

''$table->alterTable();''
[[/src]]

上の例では column1, column2 からなるテーブルを作成した後、column1 を削除し column3 を追加してテーブルの型を変更( ''alterTable'' )している。
 繰り返すが、カラムの削除は避けるべきである。

[[静的なデータ構造定義とオブジェクトリレーショナル拡張|section:static_table]]
動的なデータ構造の定義が可能であれば、静的なデータ構造はその拡張として実装できる。
 永続化レイヤーでは静的なデータ構造の定義に PHP のクラス定義(= ''永続化クラス'')を利用する。

また、クラス定義を利用するため行オブジェクトの代わりに永続化クラスのインスタンスを利用することができる。
 すなわち、永続化クラスに定義したメソッドを使用して、行の内容を参照あるいは変更できる。これを''オブジェクトリレーショナル拡張''と呼ぶ。

[[src]]
class Employee extends ''CB_PersistentBase''
{
    function Employee( & $row )
    {
        parent::CB_PersistentBase( $row );
    }

    var $col_name = array( 'type'=>'char' );
    var $col_phone = array( 'type'=>'char' );
    var $col_salary = array( 'type'=>'int', unsigned=>TRUE );

    var $idx_salary = array( 'cols'=>array('salary') );

    function increaseSalary( $increase )
    {
        {{// カラムの操作を、getterメソッドとsetterメソッドで行える}}
        ''$new_salary'' = $this''->get( 'salary' )'' + $increase;
        $this''->set( 'salary', $new_salary )'';
    }
}

$table =& cb_class2table( 'Employee' );

{{// cb_class2table が返すのは CB_TableInfo なので、以前と共通操作}}
$table->createTable();
$employee1 =& $table->newRow();

{{// しかし、CB_Row オブジェクトの代わりに永続化クラスのインスタンス}}
echo get_class( $employee1 );

$employee1->set( 'name', 'Nanasino, Gonbe' );
$employee1->set( 'phone', '03-XXXX-XXXX' );
$employee1->set( 'salary', 1290 );

{{// $employee1 は Employee のインスタンスなので、メソッドが呼べる}}
$employee1->''increaseSalary''( 10 );
[[/src]]

上の例では、"Employee" という名前のテーブルの型定義を [[az:fw.persistent:CB_PersistentBase]] クラスを拡張して行っている。
 永続化クラスのオブジェクトは、後述する [[一時オブジェクト|#temporary_object]] の作成を除いて直接 new で作成することはない。そのためコンストラクタは上記の形式で 1 引数を参照で取り、親クラスのコンストラクタに渡さねばならない。

クラスのプロパティのうち、"''$col_''" で始まるメンバーがカラムの定義である。
"$col_name = array( 'type'=>'char');" であれば、"''name''" というカラムを値の連想配列で指定された型で定義する。

同様にしてクラスのプロパティのうち、"''$idx_''" で始まるメンバーがインデックスの定義である。
"$idx_salary = array( 'cols'=>array('salary') );" であれば、"''salary''" カラムに重複値を許すインデックスを作成する。("$idx_" に続く文字列はインデックスの名前であり、作成されるインデックスに使用するカラムとは無関係。)

永続化クラスを実際に使用するには、動的なデータ構造定義で使用した [[az:fw.persistent:CB_TableInfo]] のテーブルオブジェクトを利用する。
[[az:fw.persistent:include/fw/persistent.csp:cb_class2table]] 関数は新規にテーブルを作成する際に、カラムおよびインデックスをテーブルオブジェクトに追加して返す関数である。
 ''一度 createTable でテーブルを作成後は、CB_TableManager::getTableInfo() メソッドによる取得の方が速い。''

作成したテーブルオブジェクトは動的な場合と同様の挙動を示す。
 例外は、''newRow'' および ''getRow'' メソッドが、''CB_Row'' の代わりに作成元となった永続化クラスのインスタンスを返すことである。
 永続化クラスのベースクラスである [[az:fw.persistent:CB_PersistentBase]] はほぼ [[az:fw.persistent:CB_Row]] と同じメソッドを持つため、違いを意識することはないだろう。
 例中にあるように、永続化クラスで定義されたメソッド(= ''increaseSalary'')が追加で使える程度である。

永続化クラスは通常のクラス同様、継承を使用して拡張可能である。
 この場合、元となるテーブルとは別のテーブルを作成することになる。
[[src]]
class Manager extends ''Employee''
{
    function Manager( & $row )
    {
        parent::Employee( $row );
    }

    var $col_budget = array('type'=>'int', unsigned=>TRUE);
}

$table =& cb_class2table( 'Manager' );
$table->createTable();
[[/src]]

[[一時オブジェクト|head:temporary_object]]
永続化クラスではあっても、一時的にメモリ上のオブジェクトとして、データベースに保存されないオブジェクトを作成したくなる場面がある。

そのような場合に限って、永続化クラスを直接 new して良い。
 下の例のように、コンストラクタに ''null'' を渡すことで一時オブジェクトを得られる。
 プロパティの代入操作などは通常のオブジェクトと同じである。PHP では参照渡しに即値(= ここでは ''null'')が渡せないので、仮の変数を用意している。
[[src]]
class Employee extends CB_PersistentBase
{
    function Employee( & $row )
    {
        parent::CB_PersistentBase( $row );
    }

    {{// ...}}
}

{{// 一時オブジェクトの作成}}
$dummy = ''null'';
$tmp =& new Employee( $dummy );
[[/src]]

[[テーブル型の変更 (ALTER TABLE)|section:alter_table]]
テーブル型の変更とは、一度作成したテーブルの型を変更する操作のことである。
 例えば int 型のカラムを追加したり、インデックスを削除したりすることが該当する。以下に例を挙げる。

*カラムの追加・削除
 ただし前述したように、''relation''型、''weak_relation''型のカラムを削除することはできない。
*カラム型の変更
 例えば以下のように、'lazy' 属性を追加するような場合も含む。
[[src]]
変更前: $col_hoge = array('type'=>'int');
変更後: $col_hoge = array('type'=>'int', {{'lazy'=>TRUE}});
[[/src]]
*インデックスの追加・削除
*インデックス型の変更
 例えば以下のように 'unique' 属性を削除するような場合も含む。
[[src]]
変更前: $idx_hoge = array('cols'=>array('name'), {{'unique'=>TRUE}});
変更後: $idx_hoge = array('cols'=>array('name'));
[[/src]]

''注意''
* **テーブル型の変更はデータ破損を招く恐れがあるので、他の処理と切り離して行うこと**
 これは MySQL がテーブルの操作(作成・変更・削除)をトランザクション保護しないためである。
*''カラムの削除・変更はするべきではない''。不要になったとしても放置することを原則とせよ。

以下に動的な場合、静的な場合それぞれについて具体的な手順とサンプルコードを示す。
[[動的なデータ構造定義の場合|head:]]
#CB_TableInfo オブジェクトに addColumn(), addIndex() などを使用してカラムやインデックスを追加・変更する。同名のカラムやインデックスを指定すると、既存の定義を差し替えることができる。
#CB_TableInfo::alterTable() メソッドを呼び出す。

[[src]]
$manager = CB_TableManager::getInstance();
$table =& $manager->getTableInfo( 'hoge' );

$table->**addColumn**('fuga', array('type'=>'int', 'lazy'=>TRUE));
$table->**alterTable()**;
[[/src]]

[[静的なデータ構造定義の場合|head:]]
#永続化クラス中のカラム定義、インデックス定義を書換える。
#''cb_class2table'' 関数で CB_TableInfo オブジェクトを取得する。
 **この際 CB_TableManager::getTableInfo() メソッドで取得してはならない。**
 cb_class2table 関数はソース中のカラム・インデックス定義を自動的に CB_TableInfo オブジェクトに反映するが、CB_TableManager::getTableInfo() メソッドは現在のテーブル情報を持つ CB_TableInfo オブジェクトを返す違いがあるため。
#CB_TableInfo::alterTable() メソッドを呼び出す。

[[src]]
class Hoge extends CB_PersistentBase
{
    $col_hoge = array('type'=>'int');

    {{// インデックス追加のため↓の行を追加}}
    **$idx_hoge = array('cols'=>array('hoge'));**
}
[[/src]]


[[トランザクション処理とメモリ管理|section:transaction]]
Azalea はウェブアプリケーションのフレームワークである。
 トランザクション処理もウェブアプリケーションに特化しており、リクエストの開始時にトランザクションを開始し、正常終了時にコミット(データベースに保存)する。

トランザクション処理中に作成あるいは変更された永続化オブジェクトは、通常その場では SQL クエリの発行を行わない。
 引き続く変更などで無駄なクエリを多数発行することを回避するためメモリ上に保存し、コミットする直前に SQL を生成するためである。

反面、このような挙動のもとでは多数のオブジェクトを作成あるいは変更すると、メモリを圧迫してしまう。
 また、ユニークインデックスの重複を検査するために、クエリを発行する必要がある場合もある。
 そのため [[az:fw.persistent:CB_Row]] と [[az:fw.persistent:CB_PersistentBase]] クラスは ''registerNow''、''updateNow'' メソッドを持ち、その場でクエリを発行してメモリを解放する機能を持つ。

[[src]]
$table =& ...;
$row1 =& $table->newRow();

$row1->''registerNow''();

$row1->set('column1', 'abcdefg');
$row1->''updateNow()'';
[[/src]]

上の例では、SQL を 2 回明示的に発行することになる。
もし registerNow, updateNow がなければ、コミット直前に $row1 を挿入する SQL が一度発行されるだけとなる。

[[リレーション・リファレンス|section:relation]]
''リレーション''("relation")は''特定のテーブル''の行を参照する抽象型で、参照先の行(オブジェクト)が削除されると連動して自動的に削除される。もし削除される行が他の行に参照されていれば、連鎖的な削除が発生する。

''ウィークリレーション''("weak_relation")はリレーションと同様だが、参照先の行が削除されても行が削除されるわけではなく、リレーションのカラムが NULL になる。通常のリレーションでは削除時にきめ細かな対応ができないため、例えば連動してファイルを消す必要がある場合などの場面で使用する。
 (SQL では "''col_... IS NULL''" として NULL カラムを判別できる)

MySQL に絡む技術的制約から、他のカラム型と異なりリレーションカラムには自動的に一次元インデックスが作成される。このインデックスは通常重複値を許すように作られるので、もしユニークインデックスが必要であれば、下記のように "'''unique'=>TRUE''" をカラムの宣言に追加せよ。

[[src]]
class Foo extends CB_PersistentBase
{
    var $col_relation = array('type'=>'relation',
        'to'=>'''参照するテーブル''', {{'unique'=>TRUE}});
}
[[/src]]

''リファレンス''("reference")は''任意のテーブル''の行を参照する抽象型である。ただし外部キー制約を使用していないため、参照先の行が存在しなくなっている場合がある(その場合カラムの値を参照すると FALSE が返る)。

詳細についてはサンプルソース([[developer/demo_relation.csp]])を参照せよ。

[[リレーション用のテーブル作成と削除|head:]]

リレーション("relation")、および、ウィークリレーション("weak_relation")を使用するテーブルを作成する場合、''参照元のテーブルを参照先のテーブルより先に作成することは出来ない。''また、参照整合性制約により、''参照先のテーブルを参照元のテーブルより先に削除することは出来ない。''このような操作を行った場合は、DBエラーとなるので注意すること。

[[リレーションカラムの値|head:]]

通常の値と同様に、[[az:fw.persistent:CB_Row]]の ''set'', ''get'' メソッドを利用して行う。ただしこの場合、リレーションで参照しているテーブルの行オブジェクトを値としなければならない。

実際にはリレーションカラムの値として、参照先テーブルの行ID(OID)で十分である場合がある。''CB_Row::getId()'' メソッドを使用することで、指定したリレーションカラムの値をオブジェクトIDとして得ることができる。

[[検索 API|section:search]]
永続化レイヤーでの検索とは、条件に合致する「行の集合」を取得することである。
 バックグラウンドの知識として、SQL では条件に合致する行の集合を取得するために ''SELECT'' 文を使用する。
 SELECT 文は''条件の指定''の他、''結果の整列(ソート)''、''検索上限の指定''、平均値などを求める''グループ演算''といった機能を有する。

永続化レイヤーにおいてはこの SELECT 文の持つ機能を [[az:fw.persistent:CB_RowSet]] クラスが抽象化する。
 下の例に示すように、検索対象となるテーブルオブジェクトを指定して作成し、メソッドを通じて各種の条件を指定した後、''iterate'' メソッドにより結果を取得する。
 
[[src]]
$table =& $manager->getTableInfo( 'Employee' );
$rowset = new CB_RowSet( $table );
$rowset->addCondition(
    "''col_salary'' > 3000 AND ''col_name'' LIKE 'Smith %'" );
$rowset->addOrderColumn( '''col_salary''', TRUE );
$rowset->limit( 20, 21 );

while( ! is_null( $row =& $rowset->iterate() ) )
{
    echo 'Employee: ', $row->name;
}
[[/src]]

例で示されている、''addCondition'' メソッドが条件の指定(追加)である。
 条件は SQL の WHERE 節に指定できる文字列で指定する。その際各カラムの値に対する条件は、カラム名を''内部形式''にして指定する必要がある。
 後にまとめるが、カラムの内部形式名は、"''col_''" をカラム名の前に付加したものとなる。

''addOrderColumn'' は結果のソートを指定する。最初の引数にはソートに使用するカラム名を''内部形式''で指定する。ソートは昇順に行われるが、オプションの第 2 引数に TRUE を指定すると降順でソートを行う。

''limit'' は検索を開始するオフセットと、検索上限数を指定する。
 先頭からの検索はオフセット 0、全件数の検索には上限数 -1 を指定する。''limit'' メソッドを呼び出さなければ、先頭から全件数の検索を行う。

最後に ''iterate'' メソッドを呼び出すと実際に検索を実行する。''iterate'' は呼び出されるたびに 1 行ずつ結果を返し、最後に ''null'' を返す。

[[内部形式|head:internal]]
検索条件の指定には SQL の WHERE 節にあたる文字列を指定する。
 その際に必要となるのが、テーブル名やカラム名の内部形式である。以下の表に示す通り。

[[html]]
<table class=cb_doc_table border="1">
<tr><th nowrap>種類</th><th nowrap>名前(例)</th><th nowrap>内部形式(例)</th><th nowrap>説明</th></tr>
<tr>
<td nowrap>データベース名</td>
<td nowrap>cbfw</td>
<td nowrap>cb_cbfw</td>
<td>
データベース名を検索に使用することはほとんどないが、内部形式は「名前を小文字にして先頭に "<b>cb_</b>" を付加」した文字列である。
</td>
</tr>

<tr>
<td nowrap>テーブル名</td>
<td nowrap>CB_Foo</td>
<td nowrap>tab_cb_foo</td>
<td>
テーブル名を指定するのは後述するテーブルの結合操作などで、カラム名を「"テーブル名"."カラム名"」として指定する必要がある場合などである。内部形式は「<b>名前を小文字にして</b>先頭に "<b>tab_</b>" を付加」した文字列。
</td>
</tr>

<tr>
<td nowrap>カラム名</td>
<td nowrap>name</td>
<td nowrap>col_name</td>
<td>
カラム名の内部形式は「名前の先頭に "<b>col_</b>" を付加」した文字列。
</td>
</tr>

<tr>
<td nowrap>オブジェクトID</td>
<td nowrap>&nbsp;</td>
<td nowrap>_id</td>
<td>
オブジェクトIDを格納しているカラムの内部名は '_id' である。オブジェクトIDを指定して特定の行を取得する場合は CB_TableInfo::getRow() を使用するので、通常addCondition()では使用しない。例外的に、JOIN して検索する際に関連する行の条件を指定する際に利用することがある。またaddOrderColumn()を使用し、OIDでソートさせたい場合にはこの内部名を利用する。
</td>
</tr>
</table>
[[/html]]

[[条件指定|head:condition]]
条件の指定は例で示したように、''addCondition'' メソッドにより行う。
 ''addCondition'' は複数回呼び出すことができ、指定された条件は "AND" 結合される。しかし単純に "AND" 結合するために ''addCondition'' を複数回呼び出すべきではない。

''addCondition'' が複数回呼び出し可能であるのは、例えば CB_RowSet を行集合として別のモジュールに渡し、その中でさらなる条件、例えばアクセス権のチェックなどを付加される用途のためである。

[[部分文字列検索 (LIKE検索)|head:like]]
''LIKE'' 演算子を使用すると、簡易なパターンを使用して部分文字列検索を実行できる。
 パターン文字列は LIKE 演算子の右辺に指定し、以下のパターン記号を使用する。

[[html]]
<table class=cb_doc_table border="1">
<tr>
<td nowrap>%</td>
<td>
0 文字以上の任意の文字列にマッチする
</td>
</tr>

<tr>
<td nowrap>_</td>
<td>
1 文字にマッチする
</td>
</tr>
</table>
[[/html]]

% および _ をエスケープするには、''\'' を付加すれば良い。
 しかしながら、通常の文字列のエスケープ規則と合わせると、\ そのものの表現には ''\\\\'' と指定しなくてはならない。(パーザーが文字列のエスケープと見るために倍、さらに LIKE のエスケープのために倍)

[[src]]
col_name LIKE 'Smith %';
[[/src]]

この例では ''name'' カラムの値が "''Smith ''" から始まる文字列である行に適合する。
 これを前方一致といい、文字列のインデックスが有効に使われうるパターンである。(それ以外の部分一致、後方一致ではインデックスは使用されない)
 
[[Caes-sensitivity (大文字小文字)|head:case]]
MySQL-4.1 のコレーション(collation)システムは非常に柔軟にできており、文字列の比較方式を各種のコレーションとして定義でき、また設定で変更可能である。
 もちろん、大文字小文字の区別もコレーション関数次第ということになる。

通常の MySQL では大文字小文字を区別しないコレーション(''utf8_general_ci'')を定義しているのだが、コレーション関数は同値判定にも使用されるためそのままでは "aaa" と "Aaa" が同一文字列となってしまい、ユニーク制約にひっかかるなど不都合が生じる。

そこでアゼリアの MySQL では、サイボウズ独自のコレーション ''utf8_cybozu'' を組み込み、それを使用している。
 このコレーションでは比較時には大文字小文字を区別しないが、同値判定には区別するようにしている。

[[html]]
<!-- 以下の部分は SQL ポータビリティを考慮していない記述なので、一時隠す -->
<!--
<p>
大文字小文字を区別する(case-sensitive)検索を行うには、以下に示すように検索文字列に <b>BINARY</b> 句を付加する。詳細は<a href="http://www.mysql.com/doc/en/Case_Sensitivity_Operators.html">MySQL のマニュアル</a>を参照せよ。
</p>

<pre>
$format = &quot;col_title = '@S' AND col_name LIKE <font color="green">BINARY</font> 'Jonathan @L' &quot;;
$rowset->addCondition( cb_queryf( $format, "Coo's", "Jo%5" ) );
</pre>
-->
[[/html]]

[[文字列のエスケープ|head:escape]]
まず下の例を見てみよ。本来は name カラムの値が $some_name 変数の文字列と同じ行を検索するはずだが、何が起こるか。

[[src]]
$some_name = "'''; DROP TABLE important_table; SELECT \'\' = \'''";
$rowset->addCondition( "col_name = '${some_name}'" );
[[/src]]

おそらく上記の操作の結果、次のようなクエリが発行されることになるだろう。

[[src]]
SELECT * FROM ... WHERE col_name =\'''\'; DROP TABLE important_table;''
    ''SELECT \'\' = \'''';
[[/src]]

この SQL 文は ';' で区切られた 3 つの文からなり、"DROP TABLE important_table" の結果、重要なテーブルを破棄されてしまう。
 こういった攻撃を「''SQL インジェクション''」と呼び、ウェブアプリケーションでは典型的なセキュリティホールである。

これを防止するためには $some_name を適切にエスケープする必要がある。
 最も低レベルには、CB_DatabaseConnection::escape メソッドを利用する。このメソッドは SQL 文に埋め込む文字列として適切なエスケープを施す。

上記よりも高レベルな API として、[[az:fw.persistent:include/fw/database.csp:cb_queryf]] 関数が用意されている。
 この関数を利用すると、通常の文字列と LIKE 検索のパターン両方を printf に似たフォーマット指定子でフォーマットできる。
 
[[src]]
$db =& $G_container_base->getInstance( 'dbconn' );
$query = "SELECT * FROM tab_cb_books WHERE col_title = '@S' AND col_name LIKE 'Jonathan @L'";
$query = ''cb_queryf( $db, $query, "Coo's", "Jo%5" )'';
$db->query( $query );
[[/src]]

上記の '@S' の個所が通常の文字列のエスケープ、'@L' の個所が LIKE パターンを含んだ文字列のエスケープとなる。'@' を含める場合は '@@' とする。

[[az:fw.persistent:include/fw/database.csp:cb_queryf]] 関数を使用する際は、
第一引数にクエリの実行に使用するCB_DatabaseConnectionオブジェクトを指定する必要があることに注意する。

また、[[az:fw.persistent:CB_RowSet]] クラスや[[az:fw.persistent:CB_MultiRowSet]] クラスを用いた検索の場合は、以下のようにオブジェクトのqueryf()メソッドを用いることも可能である。
queryf()メソッドは、第一引数にCB_DatabaseConnectionオブジェクトを指定する必要がないことを除いて、ほぼ同様の方法で使用することができる。

[[src]]
$rowset = new CB_RowSet( $books );
$condition = "col_title = '@S' AND col_name LIKE 'Jonathan @L'";
$condition = ''$rowset->queryf( $condition, "Coo's", "Jo%5" )'';
$rowset->addCondition( $condition );
[[/src]]

[[ソート (整列)|head:sort]]
例中で示したように、''addOrderColumn'' を使用することで指定したカラムに従った整列が可能である。複数回指定した場合、指定した順序でソートされる。以下の例を参照せよ。

[[src]]
{{// 'x', 'y' の順でソートされた結果を得る。}}
echo " x, y\n ------\n";
$rowset->addOrderColumn( 'col_x' );
$rowset->addOrderColumn( 'col_y' );
while ( ! is_null( $row =& $rowset->iterate() ) )
{
    echo sprintf("%2d, %2d\n", $row->get('x'), $row->get('y') );
}
[[/src]]

[[src]]
{{// 結果の例。'x' が大項目となる。}}
 x, y
-----
 1, 3
 1, 8
 2, 1
 2, 2
 2, 4
 3,10
 4, 2
 4, 7
 4, 9
 4,13
[[/src]]

以上は昇順のソートだが、降順でソートする場合は ''addOrderColumn'' の第2引数に ''TRUE'' を指定する。

[[src]]
{{// カラム x の降順でソート}}
$rowset->addOrderColumn( 'col_x', ''TRUE'' );
[[/src]]

オブジェクトIDの順序でソートをする場合も、カラムの内部形式で指定する。
[[src]]
// OID の降順でソート
$rowset->addOrderColumn( '''_id''', TRUE );
[[/src]]

[[インデックスとサーチ・ソート|head:index]]
インデックスは適切に作成すれば、条件による絞り込みやソート操作を高速化する効果を持つ。
 インデックスが存在しなくとも全件検索で遅くなるだけで、結果には影響しない。
 ここでは絞り込みやソートを高速化するための、インデックスの適切な作成方法を解説する。

インデックスは一つあるいは複数のカラムに対して作成する。
 前者を''一次元インデックス''、後者を''多次元インデックス''と呼ぶことにする。
 多次元インデックスではカラムの順序が重要になる。例えば ''name'' カラム、''id'' カラムの順を持つ多次元インデックスは ''id'' カラム、''name'' カラムの順を持つインデックスとは異なったものである。

以下のサンプルコードは、''name'' カラム、''id'' カラムの順で作成された多次元インデックス ''nameid'' を持つ永続化クラスを示している。

[[src]]
class Foo extends CB_PersistentBase
{
    $col_name = array('type'=>'char');
    $col_id   = array('type'=>'int');

    $idx_nameid = array('cols'=>**array('name', 'id')**);
}
[[/src]]

[[html]]
<h5>多次元インデックス</h5>
[[/html]]

'a', 'b', 'c' という順序のカラムに対するインデックスを ''('a', 'b', 'c')'' と表記することにする。例えば上の例では nameid は ('name', 'id') と表記できる。

''一般に、多次元インデックスはより低い次元のインデックスを兼ねる。''
 つまり ('a', 'b', 'c') というインデックスは ('a', 'b') としても、また ('a') としても有効である。だが ('b') としては使えないし、('a', 'c') としても使えない。多次元インデックスとは各カラムを連結した値のインデックスであると理解すると分かりやすい。

*'a', 'b', 'c' の順にソートするとき。
 SQL: SELECT ... ORDER BY a, b, c;
*'a', 'b' の順にソートするとき。
 SQL: SELECT ... ORDER BY a, b;
*'a' の順にソートするとき。
 SQL: SELECT ... ORDER BY a;
*カラム 'a' に対して WHERE 節で同値 or 比較条件を指定し、結果を 'b', 'c' でソートするとき。
 例: SELECT ... WHERE a > 3 ORDER BY b, c;
*カラム 'a' に対して WHERE 節で同値 or 比較条件を指定し、結果を 'b' でソートするとき。
 例: SELECT ... WHERE a > 3 ORDER BY b;
*カラム 'a' に対して WHERE 節で同値 or 比較条件を指定し、さらに AND 条件でカラム 'b' に対する同値 or 比較条件を加え、結果を 'c' でソートするとき。
 例: SELECT ... WHERE a > 3 AND b = 'hoge' ORDER BY c;
*カラム 'a' に対して WHERE 節で同値 or 比較条件を指定し、さらに AND 条件でカラム 'b' に対する同値 or 比較条件を加えるとき。
 例: SELECT ... WHERE a > 3 AND b = 'hoge';
 
SQLデータベースでは、通常オプティマイザが適切なインデックスを使用するように、WHERE 節の条件指定を適用する。そのため条件指定の順序には特に注意しなくても良い。
 その一方、 WHERE 節にて ''"a > 3"'' かつ ''"b = 5"'' という条件を指定した場合、インデックスとしては ''(a, b)'' あるいは ''(b, a)'' のどちらを用意するべきかは検討する必要がある。

例えば、学生の入ったテーブルを考える。"a" が学年、"b" が誕生日とすると、"a" で絞りこむと 1 学年分の学生の集合が得られるのに対して、"b" で絞り込む場合はおよそ全学生の 365 分の 1 の学生の集合が得られる。この場合はまず "b" で絞り込むほうが後の計算量が小さいことが期待できるため、用意するインデックスは ''(b, a)'' とするべきである。

[[html]]
<h5>部分文字列検索とインデックス</h5>
[[/html]]
部分文字列検索(LIKE検索)でインデックスが有効に利用されるのは、''前方一致''の場合のみである。
 後方一致もしくは中間一致の場合にはインデックスは利用されず、全件からの検索となる。

{{○}} a LIKE 'Hoge%'  (a が 'Hoge' から始まる)
 **×** a LIKE '%Fuga'  (a が 'Fuga' で終わる)
 **×** a LIKE '%Go%'  (a が 'Go' を含む)

[[html]]
<h5>暗黙のインデックス</h5>
[[/html]]

以下のカラムに対してはフレームワーク内部で暗黙的に一次元インデックスが作成されている。

*オブジェクトID
*'relation' カラム
*'weak_relation' カラム

[[検索上限とマッチ全件数の取得|head:count]]
''limit'' メソッドを使用すると検索の上限数を指定できる。だが、条件に合致する全件数を取得したい場合もあるだろう。

そのような場合、''setCalcAllMatched'' メソッドを呼び出しておけば、検索後に ''countAllMatched'' メソッドによってマッチする全件数を取得できる。
 但し当然ながら処理が重くなるので、慎重に使用すること。

[[src]]
$rowset->setCalcAllMatched( TRUE );
{{// 最大10件に制限}}
$rowset->limit( 0, 10 );

while( ! is_null( $row =& $rowset->iterate() ) )
{
    {{// 最大10回のループ}}
    ...;
}

{{// 例えばマッチする行が20件あれば、20 が返る}}
echo "# of matched rows: ", $rowset->countAllMatched();
[[/src]]

[[N件送りと頭出し|head:scroll]]
例えば 20 件ずつ表示する場合、''limit'' で最大 21 件と指定して検索を行えば良い。
 1 件増やすことで、もし検索結果数(''count'' メソッドで得られる)が 21 であれば、次の 20 件のリンクを表示するべきか判別できる。

[[src]]
{{// 40件目から、21件検索}}
$rowset->limit( 40, 21 );
$count = $rowset->count();
if ( $count > 20 )
{
    {{// 次の 20 件を検索}}
}
[[/src]]

逆に良くあるケースとして、特定のレコード(オブジェクト)からあるソート順で前後のレコードを参照したい場合がある。
 例えば、デヂエのレコード詳細画面に前後のレコードへのリンクを付加する場合など。
 この場合、そのソート順序で特定レコードを''頭出し''する必要がある。

例えばカラム ''price'' でソートする場合、該当レコードの price よりも大きいとか小さいという比較条件を指定することで頭出しできるというのが基本的なアイデアである。

price カラムが''ユニークインデックスで制約されている場合には''、以下に示すように単純な比較条件を加えるだけで良い。比較とソートを逆にすれば、逆方向に頭出しできる。

[[src]]
class Foo extends CB_PersistentBase
{
    var $col_price = array('type'=>'int');
    {{// ユニークインデックス}}
    var $idx_price = array('cols'=>'price', 'unique'=>TRUE);
}
$table =& cb_class2table( 'Foo' );
$rowset = new CB_RowSet( $table );

{{// $record が該当のレコード}}
''$table->addCondition( "col_price > " . $record->price );''
$table->limit( 0, 21 );
$table->addOrderColumn( 'col_price' );

while( ! is_null( $row =& $rowset->iterate() ) )
{
    {{// 該当レコードより price が大きい 20 件を表示}}
}

{{// 逆方向の場合には条件とソート順序が逆}}
{{// $table->addCondition( "col_price ''<'' " . $record->price );}}
{{// $table->addOrderColumn( 'col_price', ''TRUE'' );}}
[[/src]]

''該当レコードがユニークではない場合には''、オブジェクトIDによる暗黙のソートを後ろに付加して順序を保証するテクニックを用いる。
 この場合、条件式は以下のように多少複雑化する。オブジェクトIDが文字列(%s)として扱われることには注意せよ。

[[src]]
class Foo extends CB_PersistentBase
{
    var $col_price = array('type'=>'int');
    // 高速化のため二次元インデックスを用意しておく (null は OID用)
    var $idx_price = array('cols'=>''array('price', null)'');
}
$table =& cb_class2table( 'Foo' );
$rowset = new CB_RowSet( $table );

{{// ユニークではないので、price がより大きいか、}}
{{// 同じでかつ OID がより大きいという条件にする。}}
$table->addCondition(
    sprintf("(col_price > %d) ''OR (col_price = %d AND _id > %s)''",
    $record->price, $record->price, $record->getOID()) );
$table->limit( 0, 21 );
{{// ソート時に、price に加え OID でさらに順序を保証}}
$table->addOrderColumn( 'col_price' );
''$table->addOrderColumn( '_id' );''

while( ! is_null( $row =&amp; $rowset->iterate() ) )
{
    {{// 該当レコードより price が大きい 20 件を表示}}
}

{{// 逆方向の場合には条件とソート順序が逆}}
{{// $table->addCondition(}}
{{//    sprintf("(col_price ''<'' %d) OR (col_price = %d AND _id ''<'' %s)",}}
{{//    $record->price, $record->price, $record->getOID()) );}}
{{// $table->addOrderColumn( 'col_price', ''TRUE'' );}}
{{// $table->addOrderColumn( '_id', ''TRUE'' );}}
[[/src]]

[[一括削除|section:deleteAllMatched]]
''CB_RowSet''クラスには、検索条件に合致した行を一括削除するAPIも用意されている。

以下のコードは、''col_age''カラムの値が''28''の行を一括削除する。

[[src]]
$rowset->addCondition( "col_age = 28" );
$rowset->deleteAllMatched();
[[/src]]

削除する行数を指定することもできる。
以下のコードは、''col_age''カラムを降順でソートし、先頭から最大100行を一括削除する。

[[src]]
$rowset->addOrderColumn( "col_age", TRUE );
$rowset->deleteAllMatched( 100 );
[[/src]]

**※1 このメソッドは他の手段によって取得されたCB_RowオブジェクトやCB_ServerFileオブジェクトと連動しません。このメソッドによってデータベースのデータを削除しても、テーブルキャッシュは削除されませんので注意して下さい。また、CB_ServerFileオブジェクトのようにファイルシステムと連携しているテーブルのデータをこのメソッドによって削除するのはやめて下さい。**

**※2 このメソッドはaddCondition()メソッドによって指定された削除条件と、addOrderColumn()メソッドによって指定されたソート方法を採用します。その他、例えばlimit()メソッドによって指定されたパラメタは無視されます。**

**※3 このメソッドはテーブルエイリアスを使用しません。addCondition()メソッド、およびaddOrderColumn()メソッドでは、カラム名のみを指定して下さい。（JOINの機能はありませんので、テーブル名を指定する意味はありません。）**

[[グループ関数|section:cooperate]]
SQL には(検索条件にマッチする)行の集合に対して、各カラムの平均や総和を求めるグループ関数を適用する機能がある。

''CB_RowSet'' も、''applyGroupFunctions'' メソッドでグループ関数を適用する機能を持つ。

[[src]]
$rowset->applyGroupFunctions(
                             array( '''count''' => 'COUNT(*)' ),
                             array( '''group''' => 'col_group_id' ),
                             'COUNT(*) > 50'
                             );
[[/src]]

''CB_RowSet::applyGroupFunctions()''の''第一引数''は、''適用するグループ関数のリスト''である。
リストは、''識別名''をキー、''関数表現''を値とする連想配列で指定する。

''関数表現''は ''COUNT(*)'', ''SUM(col_price)'', ''AVG(tab_person.col_age)'' などといった、
内部表現で指定する。上の例では、関数表現が一つだけ指定されているが、
配列要素を追加することで複数の演算を行うことも可能である。

''識別名''には検索内で一意な識別名を指定する。関数の適用結果をソートさせたい場合には、
''CB_RowSet::addOrderColumn()''にこの識別名を指定することで、
通常のカラムと同じようにソートを行うことができる。
また、関数の適用結果はこの識別名をキーとした連想配列で取得される。

[[src]]
{{// 人数の多い順番にソート}}
$rowset->addOrderColumn( '''count''' );
[[/src]]

''CB_RowSet::applyGroupFunctions()''の''第二引数''は、''グループ化対象とするカラムのリスト''である。
これを指定すると、指定したカラムにつき''同じ値を持つ複数の行''を一つのグループとして、''各グループ毎''に関数を適用していくことができる。
リストは、''識別名''をキー、''カラムの内部表現''を値とする連想配列で指定する。グループ化を必要としない場合は''NULL''を指定する。（デフォルト値は''NULL''）

''CB_RowSet::applyGroupFunctions()''の''第三引数''は、''しぼり込み条件''である。
''CB_RowSet::addCondition()''では指定できない''関数の適用結果を用いた条件''を
ここで指定することができる。しぼり込みを必要としない場合は''NULL''を指定する。（デフォルト値は''NULL''）

[[src]]
echo '<h3>50人以上のグループ</h3>'
while( is_null( $row =& $rowset->iterate() ) ) {
    $group = $row['''group'''];
    $count = $row['''count'''];
    echo "$group : $count人<BR>";
}
[[/src]]

関数の適用結果は''CB_RowSet::iterate()''で取得する。第二引数を指定した場合のみ、適用結果は複数の行になる。それぞれのiterate()が返すオブジェクトは、''識別名''をキー、''適用結果''を値とする連想配列となる。

[[html]]
<dd>
[[/html]]
''CB_RowSet::applyGroupFunctions()''の第一引数、および第二引数で、
配列のキーとして指定する''識別名''は''SQL文のカラム名として用いることのできる文字列''を''必ず''
指定する必要がある。配列要素にキーなしの要素を指定したり、数値文字列をキーとする要素を指定した場合は
エラーとなるので注意すること。

また、上でもふれられているが、''識別名''は検索内で一意、すなわち
''第一引数と第二引数をあわせた配列の中で重複しないキー文字列''である必要がある。重複する場合はエラーとなるので注意すること。
[[html]]
</dd>
[[/html]]

[[行数の取得|section:countrow]]
''CB_RowSet''クラスには、検索した行数を取得するための''count()''メソッドと、''countAllMatched()''メソッドが用意されている。また、applyGroupFunctions()メソッドを用いて、MySQLのCOUNT関数を用いることも出来る。

それぞれの違いを以下の表にまとめる。

[[html]]
<table class="cb_doc_table">
<tr>
<th>
方法
</th>
<th>
動作
</th>
<th>
目的
</th>
</tr>
<tr>
<td>
count()メソッド
</td>
<td>
SELECTクエリを実行した際の、結果行数を保持しておき、メソッドのコール時に結果行数を返す。
</td>
<td>
iterate()メソッドと併用して、行数を取得する場合に用いる。可能なイテレーション回数と同じ値を返す。
</td>
</tr>
<tr>
<td>
countAllMatched()メソッド
</td>
<td>
SELECTクエリを実行した際の、結果行数を保持しておき、メソッドのコール時に結果行数を返す。<br>
count()メソッドと違い、LIMITを使用する検索を行った場合でも、全ての対象となる行数を取得することができる。<br>
ただし、このメソッドを用いるためには、LIMITを使用する検索を行う前に、予めsetCalcAllMatched()メソッドにTRUEを指定し、コールする必要がある
</td>
<td>
iterate()メソッドと併用して、行数を取得する場合に用いる。イテレーションはLIMITの範囲内で行うが、行数としては、全ての行を対象とした値が欲しい場合に用いる。
</td>
</tr>
<tr>
<td>
MySQLのCOUNT関数
</td>
<td>
行数をカウントするクエリを発行する。
</td>
<td>
iterate()メソッド、すなわち各行のレコード値を必要とせず、純粋に行数を取得したい場合に用いる。
</td>
</tr>
</table>
[[/html]]

※一度もiterate()を実行せずに、count()およびcountAllMatched()メソッドがコールされた場合、
その時点でクエリを発行し、iterate()のための結果セットを作成してしまいます。
iterate()の必要がない場合は、くれぐれもcount()およびcountAllMatched()メソッドを使用しないで下さい。

[[他テーブルとの連結(JOIN)|section:cooperate]]
SQL の SELECT 文には、検索対象となるテーブルを、他のテーブルと連結(JOIN)して拡張する機能がある。[[az:fw.persistent:CB_RowSet]]はこの機能を限定的な形で連結機能を提供する。

[[src]]
$rowset = new CB_RowSet( $table1 );
$rowset->addJoin(
                 $table2,
                 'tab_table1._id = tab_table2.col_parent',
                 CB_DATABASE_INNER_JOIN,
                 'users'
                 )
);
[[/src]]

''CB_RowSet::addJoin()''の''第一引数''は、''連結されるテーブル''である。
[[az:fw.persistent:CB_TableInfo]]クラスのオブジェクトを指定する。

''CB_RowSet::addJoin()''の''第二引数''は、''連結する条件''を表す文字列である。
指定の仕方は''CB_RowSet::addCondition()''で指定される条件と同様である。
条件の作用の仕方は、第三引数で指定される''連結のタイプ''によって異なる。
条件の指定が必要ない場合は''NULL''を指定する。（デフォルト値は''NULL''）

''CB_RowSet::addJoin()''の''第三引数''は、''連結のタイプ''を表す文字列である。
この値を指定するために、永続化レイヤーでは以下の四つの定数が用意されている。

''CB_DATABASE_INNER_JOIN'' : 
基本となるテーブル行と連結対象のテーブル行との全組み合わせのうち、条件に一致するもののみを対象とする

''CB_DATABASE_LEFT_JOIN'' :
基本となるテーブル行と連結対象のテーブル行との全組み合わせのうちの条件に一致するものと、基本となるテーブル行のうちの条件に一致しなかった行にNULL行を結合させたものとを対象とする（すなわち、基本となるテーブル行は全て残る）

''CB_DATABASE_RIGHT_JOIN : ''
基本となるテーブル行と連結対象のテーブル行との全組み合わせのうちの条件に一致するものと、連結対象のテーブル行のうちの条件に一致しなかった行にNULL行を結合させたものとを対象とする（すなわち、連結対象のテーブル行は全て残る）

''CB_DATABASE_CROSS_JOIN : ''
基本となるテーブル行と連結対象のテーブル行との全組み合わせを対象とする（''連結する条件''はケアされない）

なお、第三引数のデフォルト値は''CB_DATABASE_INNER_JOIN''である。

''CB_RowSet::addJoin()''の''第四引数''は、''テーブルのエイリアス''を表す文字列である。
この値を指定すると、''CB_RowSet::addCondition()''や''CB_RowSet::addOrderColumn()''で
テーブル名を指定する代わりに、この文字列を使用することが出来る。
実際には、同じテーブル同士を結合する際に曖昧さを排除するために、この機能を用いる。

[[az:fw.persistent:CB_RowSet]]クラスは他のテーブルと連結(JOIN)して拡張したテーブルを検索したり、
集計したりする機能は備わっているが、検索結果として複数のテーブルの行を返すことはできない。
これは、[[az:fw.persistent:CB_RowSet]]クラスが表現するのは、あくまで
''基本となるテーブルの部分集合''であることを意識しているからである（グループ関数は別）。
よって、[[az:fw.persistent:CB_RowSet]]クラスは、基本となるテーブルの一つの行が二回条件にかかったとしても、
それらは一つの扱いとして結果を返す。

複数のテーブルの行を取得したい場合には、[[az:fw.persistent:CB_MultiRowSet]]クラスを使用することができる。
[[az:fw.persistent:CB_MultiRowSet]]クラスは[[az:fw.persistent:CB_RowSet]]クラスの提供する全機能をサポートする。
[[src]]
{{//}}
{{// 社員テーブル-部署テーブル-役職テーブル を結合して表示}}
{{//}}
$rowset = new CB_MultiRowSet( $person_table );
$rowset->addJoin(
                 $section_table,
                 'tab_person.col_section = tab_section._id',
                 CB_DATABASE_INNER_JOIN
                 );
$rowset->addJoin(
                 $post_table,
                 'tab_person.col_post = tab_post._id',
                 CB_DATABASE_INNER_JOIN
                 );
$rowset->addOrderColumn('tab_person.col_name');
[[/src]]

[[az:fw.persistent:CB_MultiRowSet]]クラスは、iterateメソッドが返す結果の構成のみ、
[[az:fw.persistent:CB_RowSet]]とは異なる。[[az:fw.persistent:CB_RowSet]]が返すのが
''CB_Rowオブジェクト''であるのに対して、
[[az:fw.persistent:CB_MultiRowSet]]が返すのは''CB_Rowオブジェクトの配列''となる。
配列のキーはそれぞれのテーブルのテーブル名（''内部表現ではない''）か、
もしくは''CB_RowSet::addJoin()''の第四引数で指定したエイリアス文字列となる。

[[src]]
{{//}}
{{// CB_MultiRowSetはCB_Rowオブジェクトの配列を返す}}
{{//}}
while( TRUE ) {
    $result =& $rowset->iterate();
    if ( is_null( $result ) ) break;
    $h_name = $result['''person''']->get( 'name' );
    $s_name = $result['''section''']->get( 'name' );
    $p_name = $result['''post''']->get( 'name' );
    echo "$h_name : $s_name : $p_name<BR>";
}
[[/src]]

[[データベースのトランザクション分離レベル|section:isolation_level]]
[[トランザクション分離レベル(Transaction isolation level)とは|head:]]
トランザクションはACID特性(''A''tomicity, ''C''onsistency, ''I''solation, ''D''urability)という言葉で
謳われているように、その''独立性(Isolation)''が保証されていることが理想です。

独立性とは、すなわち、並列して行われるトランザクションが互いに影響を与えないということであり、
言い換えれば、それらのトランザクションが直列して行われた場合と同様の動作を示すということです。
このような状態を''直列可能(Serializable)''であると言います。

トランザクションの独立性について、前述したように直列可能(Serializable)であることが理想的ですが、
これを実現するためには、頻繁なロック制御が必要となり、多くの場合、パフォーマンスが犠牲になります。
このような状況を回避するため、SQL-92では、トランザクションの分離レベル(=独立性)について、
以下のような4つのレベルを定義し、アプリケーションの用途によって4つのレベルを使い分けられるような
データベースの実装を推奨しています。

なお、以下の4つのレベルは後述されるほど、独立性は強く、パフォーマンスは低くなる傾向にあります。
[[html]]
<table class="cb_doc_table">
<tr>
<th>
分離レベル
</th>
<th>
内容
</th>
</tr>
<tr>
<td>
READ-UNCOMMITTED
</td>
<td>
あるトランザクションのコミットしていない変更が他のトランザクションによって読み取られる。(ダーティリード)
</td>
</tr>
<tr>
<td>
READ-COMMITTED
</td>
<td>
あるトランザクションのコミットした変更が他のトランザクションによって読み取られる。<br>
トランザクション実行中に、他のトランザクションがコミットを行えば、
同じトランザクション中でも、読み取りタイミングによって結果が違うことがあり得る。(反復不可能読み取り)
</td>
</tr>
<tr>
<td>
REPEATABLE-READ
</td>
<td>
同じトランザクションで同じレコードを読み取った結果は、
自らが変更しなければ、同じであることが保証される。<br>
ただし、他のトランザクションがレコードを新規追加したりする場合は、
これをブロックしないため、集計関数の使用時などに、結果が影響を受ける場合がある。
(ファントムリード)
</td>
</tr>
<tr>
<td>
SERIALIZABLE
</td>
<td>
並列して実行される複数トランザクション同士が、互いに全く影響を与えない。
</td>
</tr>
</table>
[[/html]]

MySQLはこの4つの分離レベルを全てサポートしています。

アゼリアでは、パフォーマンスを重視し''READ COMMITTED''をデフォルトの分離レベルとしています。

[[トランザクション分離レベルの変更|head:]]
永続化レイヤーでは静的なトランザクション分離レベルの変更をサポートします。
トランザクション分離レベルの変更は、[[lwc.ini|doc:dev/base/lwc]]の編集により、
実現します。

以下のように、設定ファイル中にある、必要なデータベースオブジェクト(通常は''dbconn'')の
''prop:_isolation''の値を変更します。
[[src]]
[dbconn]
class                   = CB_PersistentDatabaseConnection
require                 = fw/database.csp
prop:_host              = val:localhost
prop:_dbname            = val:cbfw
;; isolation level can be one of `READ-UNCOMMITTED', `READ-COMMITTED',
;; `REPEATABLE-READ', or `SERIALIZABLE'.
''prop:_isolation''       = ''val:READ-COMMITTED''
;; uncomment the follwoing line to log SQL.
;prop:_logfile          = val:/var/www/cgi-bin/cbfw/query.log
[[/src]]
↓
[[src]]
[dbconn]
class                   = CB_PersistentDatabaseConnection
require                 = fw/database.csp
prop:_host              = val:localhost
prop:_dbname            = val:cbfw
;; isolation level can be one of `READ-UNCOMMITTED', `READ-COMMITTED',
;; `REPEATABLE-READ', or `SERIALIZABLE'.
''prop:_isolation''       = ''val:SERIALIZABLE''
;; uncomment the follwoing line to log SQL.
;prop:_logfile          = val:/var/www/cgi-bin/cbfw/query.log
[[/src]]

[[選択(SELECT)時のロック|section:lock:]]
[[az:fw.persistent:CB_TableInfo]]、[[az:fw.persistent:CB_RowSet]]、[[az:fw.persistent:CB_MultiRowSet]]の3つのクラスには、行取得時のロック状態を制御するための、''setLock()''メソッドがある。
また、[[az:fw.persistent:CB_Row]]クラスには、オブジェクト自身が表す行を再度ロックするための''lock()''メソッドがある。

''setLock()''、および''lock()''には以下の定数引数を指定することができる。

''CB_DATABASE_NO_LOCK'' :
行取得時にロックを取得しない

''CB_DATABASE_SHARED_LOCK'' :
行取得時に共有ロックを取得する

''CB_DATABASE_EXCLUSIVE_LOCK'' :
行取得時に排他ロックを取得する

''CB_DATABASE_DEFAULT_LOCK'' :
設定ファイルに記述されたデフォルト動作を行う

ロック処理は著しくパフォーマンスを損なうおそれがあるため、みだりに行うべきではないが、以下のように本質的に排他処理が必要なケースでは明示的に行う必要がある。

[[src]]
$table =& cb_class2table( 'counter' );
/* 排他ロックモードに設定 */
$table->setLock( CB_DATABASE_EXCLUSIVE_LOCK );
/* 排他ロックを獲得してから、行を取得する */
$row =& $table->getRow(1);
/* 値を1増やす */
/* 排他ロックを獲得しているため、他のトランザクションがカウンタを変更する心配はない */
$old_value = $row->get( 'value' );
$row->set( 'value', $old_value + 1 );
[[/src]]

[[リスト処理|section:list]]
リレーショナルデータベース上でリストを表現するには、リスト中の順序を保持するカラムを用意する。
 そこで最小限の実装は、整数型のカラムを用意するだけのものとなる。

永続化レイヤーでは現在実験的にリスト操作を簡便に行うユーティリティクラスおよび関数を用意している。
 これらの使用方法についてはサンプル([[developer/demo_list.csp]])を参照のこと。

**本質的にはモデルのインターフェースと汎用的なリスト VC を作成すれば良い、という話であるはず。 **
(参照:[[プラッガブルVC|cb6:page=FileView&gid=3561&fCID=110555&fFID=110945&cp=fl]])

[[互換性について|section:portability]]
これまでに見てきたように、永続化レイヤーはバックエンドデータベースのほとんどを抽象化している。
 だが効率の観点から一部 SQL を直接使用する個所がある。また完全に抽象化するのが困難である部分も残っている。

そのため、他の主要な商用データベース(Oracle, DB2 など)へのポータビリティを確保するには一定のガイドラインを守る必要がある。
 ガイドラインは [[勉強会資料|cb6:page=FileView&gid=3561&fCID=120332&fFID=120337&cp=fl]] 中にあるので、常に念頭に置いてコーディングを行うこと。

[[設計の経緯と考察|section:detail]]
To be written. Q and A 形式で。↓書きかけ。

Q. ''何故プライマリキーが OID に固定されているのか？''
 A. 旧フレームワークとの親和性やウェブアプリケーションのUIとの親和性を考慮した。
 またプライマリキーを限定することで、リレーション等各種機能の規格化が可能となった。

Q. ''何故リレーションの設定にはオブジェクトを代入するのか？''
 A. 内部的には確かにオブジェクトIDを格納しているが、プログラム上でも数値としてしまうと、果たして本当に望みのテーブル所属のオブジェクトなのか判別できないため。

[[リファレンス|section:reference]]

''サンプルソース''
#動的なテーブル作成 ([[developer/demo_dynamic_table.csp]])
#行の追加・更新・削除 ([[developer/demo_ins_up_del.csp]])
#永続化クラス(静的なテーブルの型宣言 ([[developer/demo_persistent_class.csp]])
#遅延(on demand)ローディング ([[developer/demo_ondemand.csp]])
#検索 API ([[developer/demo_search.csp]])
#グループ関数 ([[developer/demo_groupfunc.csp]])
#リレーション・リファレンス ([[developer/demo_relation.csp]])
#サーバー上のファイル管理 ([[developer/demo_server_file.csp]])
#リスト処理 ([[developer/demo_list.csp]])
#テーブルの結合(CB_RowSet) ([[developer/demo_join.csp]])
#テーブルの結合(CB_MultiRowSet) ([[developer/demo_multijoin.csp]])

''フレームワークソース''
#データベース・テーブル・行・行集合(検索API)の抽象化 ([[include/fw/database.csp]])
#永続化クラス ([[include/fw/persistent.csp]])
#永続化ファイル ([[include/fw/server_file.csp]])
#リスト処理 ([[include/fw/dblist.csp]])
