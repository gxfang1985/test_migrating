[[概要|section:abstract]]

汎用プラグイン機構は開発者がライブラリやモジュールの拡張を簡単に行えるようにするための機構である。
例えば[[doc:dev/base/uum]]（UUM）や[[doc:dev/base/error_handling]]でカスタムサービスプロバイダ（ドライバ）をインストールしたり、
フック（トリガー）関数を登録する手間を軽減する。

具体的には**特定フォルダにファイルを配置**するだけで、
各種の機能追加や変更を行うことが可能となる。
こういった機構を''プラグイン機構''という。
アゼリアは以下に解説するプラグイン機構を開発するための汎用的な仕組みを提供している。

[[用語|section:words]]

[[html]]
<table class="cb_doc_table">
<tr><th nowrap>用語</th><th nowrap>解説</th></tr>

<tr>
<td nowrap>プラグインモジュール</td>
<td>以下で説明するドライバ、フック関数、プラグインスクリプトの総称</td>
</tr>

<tr>
<td nowrap>ドライバ</td>
<td>特定の機能群を実装したプラグインモジュールのこと。</b>アゼリアではクラスオブジェクト</b>として実装する。</td>
</tr>

<tr>
<td nowrap>フック関数</td>
<td>特定のイベント発生時点で呼び出される関数のこと。アゼリアでは関数として実装する。</td>
</tr>

<tr>
<td nowrap>プラグインスクリプト</td>
<td>ドライバでもフック関数でもないが、
プラグイン機構を利用して動的に読み込まれるスクリプトファイル。
アプリケーション別のデータベース初期化スクリプトなどに利用される。</td>
</tr>

<tr>
<td nowap>ローダー (loader)</td>
<td>プラグイン機構を実装する側のモジュール。プラグインモジュールを読み込む。</td>
</tr>

<tr>
<td nowrap>サービスプロバイダ</td>
<td>ドライバの別名</td>
</tr>

<tr>
<td nowrap>トリガー</td>
<td>フック関数の別名</td>
</tr>
</table>
[[/html]]

[[プラグイン仕様|section:spec]]

プラグインモジュールは "(CGI_ROOT)/code/plugin" ディレクトリ以下に配置する。
ここを''プラグイン置場''と呼ぶ。 

ローダーは以下のように [[az:fw.core:CB_PluginLoader]] クラスを利用して作成する。
ローダー毎に一意な''モジュール名''を定義する必要があり、
[[az:fw.core:CB_PluginLoader]] のコンストラクタの引数で指定する。
モジュール名は「英数小文字 + "_"」からなる文字列とする。 

[[src]]
class HogeLoader
{
    function HogeLoader
    {
        {{// CB_PluginLoader が定義されている。}}
        ''require_once( 'fw/plugin.csp' );''

        {{// 'hoge' がモジュール名}}
        $loader = new CB_PluginLoader( '''hoge''' );

        foreach( $loader->loadHooks() as $hook )
        {
            $this->addFugaHook( $hook );
        }
    }

    function addFugaHook( $func )
    {
        ...
    }
}
[[/src]]

**"hoge" モジュールのプラグインは、プラグイン置場の "hoge" サブディレクトリ以下に配置する。**
プラグインモジュールは種類に応じて以下の規則で作成することになる。
条件に従っていない場合、エラーが発生したり（＝ ファイルの内容がおかしいとき）、
無視されたり（＝ ファイル名が規約に従っていないとき）する。

[[ドライバ|head:]]

#クラス名は "plugin_((モジュール名_ドライバ名))" とする。 
#ファイル名は "((ドライバ名を小文字にしたもの)).csp" とする。 
#クラスのコンストラクタは無引数とする。 
#クラスのメソッドおよびメンバーはローダー作成者が定める。 

[[フック関数|head:]]
#関数名は "plugin_((モジュール名_フック名))" とする。 
#ファイル名は "((フック名を小文字にしたもの)).csp" とする。 
#関数の引数および返り値はローダー作成者が定める。 
#ローダー作成者がフック名について特定のプレフィクスを定めることがある。 

[[プラグインスクリプト|head:]]
#ファイル名は ".csp" を拡張子とする。 
#ファイルの内容は無制限。 
#ローダー作成者がファイル名について特定のプレフィクスを定めることがある。 
#**ファイル名を文字列でソートした**順に読み込まれる。 

[[ローダー開発 Step by Step|section:loader]]

1.[[どのプラグイン形式を採用するか|#type]]
 2.[[APIを用意する|#api]]
 3.[[モジュール名を決める|#module]]
 4.[[フック（トリガー）を読み込む|#hook]]
 5.[[ドライバ（サービスプロバイダ）を読み込む|#driver]]
 6.[[プラグインスクリプトを読み込む|#script]]

[[1. どのプラグイン形式を採用するか|head:type]]

**ドライバは実装をすげかえる**場合に利用する。
例えば UUM（統一ユーザー管理）ではログイン処理やロール認証の実装は追加では困る場合があるので、
サービスプロバイダとして実装をすげかえる方式を採用している。
例えばシングルサインオン時には、通常のログイン処理を停止する必要がある。

別の応用として、**ドライバはファクトリパターンと親和性が高い**ことが挙げられる。
つまり、ドライバは名前を指定してロードするので、
ファクトリに名前を与える個所で使用するとプラグインに対応したファクトリができあがる寸法である。
AzLogger の [[az:fw.logger:CB_LogTargetFactory]] が参考になるだろう。

**フック関数は実装を追加する**場合に利用する。
例えば発生したエラーのログを記録する場合など、
処理そのもの（''エラー処理''）は変更せずに別の処理（''ログ記録''）を追加する場合である。 

**プラグインスクリプトは非定型的な処理を追加する**場合に利用する。
関数とするのが面倒である場合（引数無し、返り値無し、処理内容は複雑）に便利だろう。
また、プラグインスクリプトの読み込み順は、ファイル名を工夫することによって制御可能である。
例えば "00hoge.csp", "21fuga.csp", "03geho.csp" の 3 スクリプトがあれば、
"00, 03, 21" の順に読み込むことになる。
これを利用して、依存関係にあるスクリプト（例えば初期化スクリプトなど）をファイル名を規定することでプラグイン可能となる。
[[2. API を用意する|head:api]]

ドライバあるいはフック関数をプラグインする機構を作成する場合、
まずそれらを組み込む API を用意する。 

プラグインフレームワークではドライバはオブジェクト、
フック関数は関数として実装されているため、
以下のようにオブジェクトまたは関数を登録する API を準備する。 

[[src]]
class HogeLoader
{
    {{// $driver は特定のメソッドやプロパティを持ったオブジェクト}}
    {{// 参照 (''&'') で受け取るようにする}}
    function setDriver( & $driver )
    {
        ...
    }

    // $hook はフック関数名(文字列)
    function addHook( $hook )
    {
        ...
    }
}
[[/src]]

[[3. モジュール名を決める|head:module]]

次にモジュール名を決める。
モジュール名は一意である必要があるので他所との関係を十分考慮し調整して決定すること。
アゼリアでは以下が定義済みのプラグインモジュールである。 

*prepend - [[リクエスト前処理|doc:dev/base/request#pre]]
*append - [[リクエスト後処理|doc:dev/base/request#post]]
*uum - [[統一ユーザー管理機構|doc:dev/base/uum]]
*uum_login - [[統一ユーザー管理機構|doc:dev/base/uum]]のログイントリガー用 
*uum_role - [[統一ユーザー管理機構|doc:dev/base/uum]]のロール認証用 
*error - [[doc:dev/base/error_handling]]
*license - [[doc:dev/base/license]]
*logger - [[doc:dev/api/azlogger]]
*init - [[データベース初期化|doc:dev/guideline/initialization]]

[[4. フック（トリガー）を読み込む|head:]]

フック関数を読み込む場合は CB_PluginLoader::loadHooks() を使用する。
このメソッドは読み込んだフック関数名を配列で返すので、
以下に示す例のように foreach で API を呼び出し、追加すれば良い。 

フック関数を読み込むタイミングであるが、
そのモジュールの初期化時などに一度にまとめて行うべきである。
何度も CB_PluginLoader::loadHooks() を呼び出すのは効率が悪い。 

[[src]]
class HogeLoader
{
    function HogeLoader()
    {
        ...

        require_once( 'fw/plugin.csp' );
        $loader = new CB_PluginLoader( 'hoge' );

        {{// フック関数の登録}}
        foreach( $loader->''loadHooks''() as $hook )
        {
            $this->addHook( $hook );
        }
    }
}
[[/src]]

''HogeLoader'' が複数種のフックを持つ場合、
フック関数の名前で分類できる。種類ごとに異なるプレフィクスを用意し、
CB_PluginLoader::loadHooks() に指定する。 

[[src]]
class HogeLoader
{
    function HogeLoader()
    {
        ...

        require_once( 'fw/plugin.csp' );
        $loader = new CB_PluginLoader( 'hoge' );

        {{// 読み込みフックの登録 (プレフィクス "read_" )}}
        foreach( $loader->loadHooks( '''read_''' ) as $hook )
        {
            $this->add''Read''Hook( $hook );
        }

        {{// 書き込みフックの登録 (プレフィクス "write_" )}}
        foreach( $loader->loadHooks( '''write_''' ) as $hook )
        {
            $this->add''Write''Hook( $hook );
        }
    }
}
[[/src]]

[[5. ドライバ（サービスプロバイダ）を読み込む|head:driver]]

ドライバは CB_PluginLoader::loadDriver() にドライバ名を指定して読み込む。
どのドライバを読み込むかは別途 [[common.ini|doc:ext/config#common.ini]] のような設定ファイルなどで指定する。

CB_PluginLoader::loadDriver() はロードしたドライバクラスのインスタンスを返すので、
それをそのまま API で設定すれば良い。 

[[src]]
class HogeLoader
{
    function HogeLoader()
    {
        ...

        require_once( 'fw/plugin.csp' );
        $loader = new CB_PluginLoader( 'hoge' );

        {{// ドライバ名の取得（別途何らかの手段）}}
        $driver_name = ...;

        {{// ドライバの登録}}
        $driver =& $loader->''loadDriver''( $driver_name );
        if( $driver !== FALSE )
        {
            $this->setDriver( $driver );
        }
    }
}
[[/src]]

[[6. プラグインスクリプトを読み込む|head:script]]

プラグインスクリプトは CB_PluginLoader::loadFiles() で読み込む。
フック関数と同様に、種類ごとに異なるプレフィクスを指定もできる。
また前述したように、プラグインスクリプトはファイル名をソートした順序で読み込まれる。 

[[src]]
class HogeLoader
{
    function setup()
    {
        ...

        require_once( 'fw/plugin.csp' );
        $loader = new CB_PluginLoader( 'hoge' );

        {{// セットアップスクリプトの評価}}
        $loader->''loadFiles''();

        {{// "db_" から始まるスクリプトのみ評価する場合}}
        {{// $loader->''loadFiles( 'db_' )'';}}
    }
}
[[/src]]

[[解説|section:explain]]

[[Q. プラグインフレームワークは誰が利用するのか |head:]]

プラグイン（ドライバ・フック関数）作成者と、ローダーの作成者の両方。 

[[Q. プラグイン作成者にとっての利点は何か|head:]]

モジュールの拡張に際して、拡張を組み込むコードを書かずにファイルを配置するだけで良くなる。 

[[Q. ローダーの作成者にとっての利点は何か|head:]]

*若干のコーディングでプラグイン機構を開発できる。 
*統一的な枠組みなので、他のプラグイン機構と親和性があり、
プラグイン作成者への説明コストが省ける。 

[[Q. なぜドライバ、フック関数、プラグインスクリプトの三種類にしたのか|head:]]

既存コードからユースケースを抽出した結果、上記 3 パターンとなった。
それぞれ「実装の置き換え」、「定型的な実装の追加」、
「非定型的な実装の追加」で用途を分類しており、必要十分な仕様と判断した。

[[Q. ローダーの開発はもっと自動化できるのではないか|head:]]

より自動化を目指すと形式の制限が強くなり、汎用性を損なうと判断した。
設計時には 統一ユーザー管理、エラー処理、
アプリケーション初期化の 3 つをターゲットとして考慮したが、
これらを網羅することが可能な汎用性を考えて今のレベルに止めた。

[[Q. なぜ API を用意してからプラグイン機構を作成するのか|head:]]

*API があれば、ファイルを置くよりもより汎用的な用途をカバーできるから。
例えば CSV ファイルのエラー処理では、
[[include/fw/csv.csp]] を読み込んだ時点でフック関数を追加している。
これはプラグイン機構ではできない。
*より汎用的な口を用意することで、コードの二重化を防止できる。
二重化の防止はDRY(Don't Repeat Yourself)原則といい、設計上大事なことである。

[[Q. なぜプラグインスクリプトだけ、読み込み順序を制御可能としたのか|head:]]

フック関数も複数読み込む場合があるが、依存関係を持つ場合は多くないと判断したこと。
および内部実装の都合からフック関数の読み込みをなるべく効率化するためにはソートしない方が都合が良かったことがある。

[[リファレンス|section:reference]]

*[[az:fw.core:CB_PluginLoader]]

[[サンプル|section:sample]]

*UUMサービスプロバイダの組み込み（[[az:fw.uum:CB_Uum]] のコンストラクタ） （[[include/fw/uum.csp]]）
*UUMトリガーの読み込み（[[az:fw.uum:CB_UumCoreAPI]] のコンストラクタ） （[[include/fw/uum_core.csp]]）
*エラー発生時のフック追加（ [[az:fw.core:CB_ErrorHandler]]::errorExit() ） （[[include/fw/error_handler.csp]]）
*プラグイン対応ファクトリ（[[az:fw.logger:CB_LogTargetFactory]]） （[[include/fw/logger.csp]]）
*アプリケーション初期化スクリプト（下の方） （[[command_initialize.csp]]）

[[フレームワークソース|section:source]]

*[[include/fw/plugin.csp]]
